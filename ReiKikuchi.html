<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" > 
  <title>Rei Kikuchi Premium Music Player</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary-color: #8e24aa;
      --secondary-color: #5e35b1;
      --accent-color: #d81b60;
      --text-color: #333;
      --background-color: #f5f5f5;
      --card-color: #fff;
      --border-color: #e0e0e0;
      --vh: 1vh; /* モバイルのビューポート高さ補正用 */
    }

    .dark {
      --primary-color: #bb86fc;
      --secondary-color: #7c4dff;
      --accent-color: #cf6679;
      --text-color: #e0e0e0;
      --background-color: #121212;
      --card-color: #1e1e1e;
      --border-color: #333;
    }
    
    /* オフラインモード用のスタイル */
    .offline-mode .online-only {
      opacity: 0.5;
      pointer-events: none;
    }
    
    #offline-status {
      z-index: 9999;
    }
    
    .offline-badge {
      position: absolute;
      top: 0;
      right: 0;
      background-color: var(--accent-color);
      color: white;
      font-size: 0.6rem;
      padding: 2px 4px;
      border-radius: 4px;
      transform: translate(50%, -50%);
    }
   
    body {
      font-family: 'Poppins', sans-serif;
      transition: background-color 0.3s ease, color 0.3s ease;
      background-color: var(--background-color);
      color: var(--text-color);
      display: flex; /* Flexboxでレイアウト */
      flex-direction: column;
      /* min-height: 100vh; -> height: 100% に変更 */
      height: calc(var(--vh, 1vh) * 100); /* モバイルでの高さ問題を修正 */
    }

    /* UI/UX改善用のスタイル追加 */
    .song-item {
      transition: transform 0.2s ease, background-color 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .song-item:hover {
      transform: translateY(-2px);
      background-color: rgba(142, 36, 170, 0.05);
    }

    .song-item::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 0;
      height: 2px;
      background-color: var(--primary-color);
      transition: width 0.3s ease;
    }

    .song-item:hover::after {
      width: 100%;
    }

    .song-item.active {
      background-color: rgba(142, 36, 170, 0.1);
      border-left: 3px solid var(--primary-color);
    }

    .btn-mode, .btn-control {
      transition: transform 0.2s ease, opacity 0.2s ease;
    }

    .btn-mode:hover, .btn-control:hover {
      transform: scale(1.1);
    }

    .btn-mode:active, .btn-control:active {
      transform: scale(0.95);
    }

    .tab-button {
      position: relative;
      overflow: hidden;
    }

    .tab-button::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      width: 0;
      height: 2px;
      background-color: var(--primary-color);
      transition: width 0.3s ease, left 0.3s ease;
    }

    .tab-button:hover::after {
      width: 100%;
      left: 0;
    }

    .tab-button.active::after {
      width: 100%;
      left: 0;
    }

    /* スマホ向け最適化 */
    @media (max-width: 640px) {
      .song-controls {
        flex-direction: column;
        gap: 0.5rem;
      }
      
      .player-controls {
        flex-wrap: wrap;
        justify-content: center;
      }
      
      .volume-control {
        width: 100%;
        margin-top: 0.5rem;
      }
      
      .song-item {
        padding: 0.75rem;
      }
      
      .song-title {
        font-size: 0.9rem;
      }
      
      .song-duration {
        font-size: 0.8rem;
      }
      
      /* タッチ操作の最適化 */
      .btn-mode, .btn-control, .tab-button, .song-item, .heart-btn {
        min-height: 44px; /* タッチターゲットの最小サイズ */
      }
      
      /* スマホでのスクロールを滑らかに */
      .playlist-container {
        -webkit-overflow-scrolling: touch;
      }
    }

    /* アニメーション効果 */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideUp {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .fade-in {
      animation: fadeIn 0.5s ease forwards;
    }

    .slide-up {
      animation: slideUp 0.5s ease forwards;
    }

    .pulse {
      animation: pulse 1s infinite;
    }

    /* プレイヤーコントロールの改善 */
    .player-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      margin: 1rem 0;
    }

    .progress-container {
      position: relative;
      height: 6px;
      background-color: var(--border-color);
      border-radius: 3px;
      cursor: pointer;
      overflow: hidden;
    }

    .progress-bar {
      height: 100%;
      background-color: var(--primary-color);
      border-radius: 3px;
      transition: width 0.1s linear;
    }

    .progress-thumb {
      position: absolute;
      top: 50%;
      width: 12px;
      height: 12px;
      background-color: var(--primary-color);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
      transition: transform 0.2s ease;
    }

    .progress-container:hover .progress-thumb {
      transform: translate(-50%, -50%) scale(1.2);
    }

    /* ローディングインジケーター */
    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid rgba(142, 36, 170, 0.3);
      border-radius: 50%;
      border-top-color: var(--primary-color);
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* スナックバーの改善 */
    .snackbar {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: var(--card-color);
      color: var(--text-color);
      padding: 12px 24px;
      border-radius: 4px;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
      z-index: 1000;
      font-size: 0.9rem;
      opacity: 0;
      transition: opacity 0.3s, transform 0.3s;
      border-left: 4px solid var(--primary-color);
    }

    .snackbar.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    /* モーダルの改善 */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .modal.show {
      opacity: 1;
      display: flex;
    }

    .modal-content {
      background-color: var(--card-color);
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      max-width: 90%;
      max-height: 90%;
      overflow: auto;
      transform: scale(0.9);
      transition: transform 0.3s ease;
    }

    .modal.show .modal-content {
      transform: scale(1);
    }

    /* スクロールバーのカスタマイズ */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--background-color);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--primary-color);
    }

    /* フォーカス状態の改善 */
    button:focus, input:focus {
      outline: 2px solid var(--primary-color);
      outline-offset: 2px;
    }

    /* キーボードナビゲーション用 */
    .keyboard-focus:focus {
      box-shadow: 0 0 0 3px var(--primary-color);
    }

    /* アクセシビリティ改善 */
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .app-container {
      max-width: 1280px;
      margin: 0 auto;
      /* padding: 20px; -> スマホでは0に */
      width: 100%;
      flex-grow: 1; /* コンテンツエリアを伸ばす */
      display: flex;
      flex-direction: column;
    }

    .app-container > header {
        padding: 10px 15px; /* スマホ用のヘッダーパディング */
        flex-shrink: 0;
    }

    .music-player {
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      background-color: var(--card-color);
      transition: background-color 0.3s ease, box-shadow 0.3s ease;
      flex-grow: 1; /* プレイヤー部分が残りの高さを取る */
      display: flex;
      flex-direction: column;
      padding: 0; /* スマホでは不要 */
    }
/* PCでのスタイルを維持 */
@media (min-width: 1024px) {
      .music-player {
         padding: 1.5rem; /* 24px */
      }
      .app-container > header {
          padding: 0 20px; /* PCでは元のpadding */
      }
    }


    /* Gridレイアウト (PC/Tablet) */
    .music-player-grid {
        display: grid;
        grid-template-columns: 1fr; /* Mobile default */
        gap: 1.5rem; /* 24px */
        flex-grow: 1;
        overflow: hidden; /* Prevent grid itself from scrolling */
    }

    @media (min-width: 1024px) { /* lg breakpoint */
        .music-player-grid {
            grid-template-columns: repeat(3, minmax(0, 1fr));
        }
        .player-main-column {
            grid-column: span 2 / span 2;
        }
        .playlist-column {
            grid-column: span 1 / span 1;
            display: flex;
            flex-direction: column;
        }
    }

    .playlist, .history-list, .favorites-list, .user-playlists-list, .playlist-detail-list {
      max-height: 400px;
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--primary-color) var(--background-color);
      -webkit-overflow-scrolling: touch; /* iOSでのスムーズスクロール */
    }

    .playlist::-webkit-scrollbar,
    .history-list::-webkit-scrollbar,
    .favorites-list::-webkit-scrollbar,
    .user-playlists-list::-webkit-scrollbar,
    .playlist-detail-list::-webkit-scrollbar {
      width: 6px;
    }

    .playlist::-webkit-scrollbar-track,
    .history-list::-webkit-scrollbar-track,
    .favorites-list::-webkit-scrollbar-track,
    .user-playlists-list::-webkit-scrollbar-track,
    .playlist-detail-list::-webkit-scrollbar-track {
      background: var(--background-color);
    }

    .playlist::-webkit-scrollbar-thumb,
    .history-list::-webkit-scrollbar-thumb,
    .favorites-list::-webkit-scrollbar-thumb,
    .user-playlists-list::-webkit-scrollbar-thumb,
    .playlist-detail-list::-webkit-scrollbar-thumb {
      background-color: var(--primary-color);
      border-radius: 6px;
    }

    .playlist-item, .history-item, .favorite-item {
      transition: all 0.2s ease;
      border-left: 3px solid transparent;
    }

    .playlist-item:hover, .history-item:hover, .favorite-item:hover {
      background-color: rgba(142, 36, 170, 0.1);
    }

    .dark .playlist-item:hover, .dark .history-item:hover, .dark .favorite-item:hover {
       background-color: rgba(187, 134, 252, 0.1);
    }

    .playlist-item.active, .history-item.active, .favorite-item.active {
      border-left: 3px solid var(--primary-color);
      background-color: rgba(142, 36, 170, 0.2);
    }

     .dark .playlist-item.active, .dark .history-item.active, .dark .favorite-item.active {
       background-color: rgba(187, 134, 252, 0.2);
     }

    .player-controls button {
      transition: all 0.2s ease;
    }

    .player-controls button:hover {
      transform: scale(1.1);
    }

    .progress-container {
  /* トラックの高さを増やし、色を調整 */
  height: 6px;
  background-color: rgba(0, 0, 0, 0.1);
  border-radius: 3px;
  cursor: pointer;
  transition: background-color 0.3s ease;
  /* タップ領域を明確にするために上下パディングを追加 */
  padding: 8px 0;
  margin: -8px 0;
}

.progress-bar {
  /* 再生済み部分の色を濃く・鮮やかに */
  height: 100%;
  background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
  border-radius: 3px;
  width: 0%;
  transition: width 0.1s linear; /* よりスムーズな更新 */
  position: relative;
}

/* ホバー時のスタイル */
.progress-container:hover {
  height: 8px;
  background-color: rgba(0, 0, 0, 0.15);
}

 /* つまみ */
 .progress-bar::after {
  content: '';
  position: absolute;
  right: 0;
  top: 50%;
  transform: translate(50%, -50%) scale(0); /* 初期状態は非表示 */
  width: 16px;
  height: 16px;
  background: white;
  border: 2px solid var(--primary-color);
  border-radius: 50%;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
  transition: transform 0.2s ease;
  z-index: 2;
}

/* ホバー時やアクティブ時に表示 */
.progress-container:hover .progress-bar::after,
.progress-container:active .progress-bar::after {
  transform: translate(50%, -50%) scale(1);
}

.progress-bar:not([style*="width: 0%"])::after,
.progress-bar[style*="width: 0."]::after {
  transform: translate(50%, -50%) scale(1);
}

.dark .progress-container {
  background-color: rgba(255, 255, 255, 0.1);
}

.dark .progress-bar {
  box-shadow: 0 0 8px rgba(187, 134, 252, 0.3);
}

.dark .progress-bar::after {
  background: var(--background-color);
  border-color: var(--primary-color);
}

    

 /* モバイル用の調整 */
 @media (max-width: 1023px) {
  .progress-container {
    height: 8px;
    padding: 10px 0;
    margin: -10px 0 5px;
  }
  
  .progress-bar::after {
    width: 18px;
    height: 18px;
    transform: translate(50%, -50%) scale(1); /* モバイルでは常に表示 */
  }
}

   /* 音量スライダーもタップしやすく */
   .volume-control input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 8px; /* 少し太く */
      background: var(--border-color);
      border-radius: 8px;
      outline: none;
      transition: background 0.3s ease;
      padding: 5px 0; /* 上下のタップ領域 */
      margin: -5px 0; /* パディング相殺 */
    }
     /* Style for the track */
    .volume-control input[type="range"]::-webkit-slider-runnable-track {
        height: 8px;
        background: var(--border-color);
        border-radius: 8px;
    }
    .volume-control input[type="range"]::-moz-range-track {
        height: 8px;
        background: var(--border-color);
        border-radius: 8px;
    }
     /* Style for the thumb */
    .volume-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px; /* 少し大きく */
      height: 18px;
      background: var(--primary-color);
      border-radius: 50%;
      cursor: pointer;
      margin-top: -5px; /* Center thumb vertically */
       transition: background 0.3s ease;
    }
    .volume-control input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        background: var(--primary-color);
        border-radius: 50%;
        cursor: pointer;
        border: none;
         transition: background 0.3s ease;
    }


    .btn-mode {
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }

    .btn-active {
      color: white;
      background-color: var(--primary-color);
    }
     .dark .btn-active {
        color: var(--background-color); /* Ensure contrast in dark mode */
        background-color: var(--primary-color);
     }

    .btn-inactive {
      color: var(--text-color);
      background-color: var(--border-color);
    }

    .search-container {
      position: relative;
    }

    .search-input {
      padding-left: 40px;
      background-color: var(--card-color);
      border: 1px solid var(--border-color);
      color: var(--text-color);
       transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }

    .search-icon {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-color);
      transition: color 0.3s ease;
    }

    .tabs {
      display: flex;
      border-bottom: 1px solid var(--border-color);
      margin-bottom: 16px;
      flex-wrap: wrap;
       transition: border-color 0.3s ease;
       flex-shrink: 0; /* タブ自体は縮まない */
    }

    .tab {
      padding: 10px 15px; /* 少し調整 */
      cursor: pointer;
      transition: all 0.3s ease;
      border-bottom: 2px solid transparent;
      text-align: center;
      flex-grow: 1; /* タブを均等配置 */
      font-size: 0.9rem;
    }
     @media (min-width: 640px) { /* PCでは元の設定に戻す */
         .tab {
             flex-grow: 0;
             padding: 10px 20px;
             font-size: 1rem;
         }
         .tabs {
             flex-wrap: nowrap;
         }
     }

     .tab.active {
      color: var(--primary-color);
      border-bottom: 2px solid var(--primary-color);
      font-weight: 600;
    }
    .tab-content {
       /* height: 100%; */ /* Will be handled by flex-grow on parent */
       overflow-y: auto;
       -webkit-overflow-scrolling: touch;
       flex-grow: 1; /* Make tab content take remaining space */
    }
    /* Remove fixed height from lists */
    .tab-content .scrollable-list-area {
        max-height: none;
        height: auto; /* Let flex/content determine size */
    }
    .visualizer-container {
      height: 60px; /* スマホでは少し小さく */
      background-color: rgba(0, 0, 0, 0.05);
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      transition: background-color 0.3s ease;
    }
     @media (min-width: 1024px) {
         .visualizer-container {
            height: 100px; /* PCでは元の高さ */
         }
     }


    .dark .visualizer-container {
      background-color: rgba(255, 255, 255, 0.05);
    }

    canvas#visualizer { /* Specificity added */
      width: 100%;
      height: 100%;
      display: block; /* Remove potential extra space */
    }

    .youtube-container {
      position: relative;
      padding-bottom: 56.25%; /* 16:9 Aspect Ratio */
      height: 0;
      overflow: hidden;
      border-radius: 12px; /* Apply border radius */
      background-color: #000; /* Black background for loading */
      margin-bottom: 10px; /* Add some space below video */
    }

    .youtube-container iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .badge {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: var(--accent-color);
      color: white;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.75rem;
      z-index: 10;
    }

    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
      padding: 15px; /* Add padding for mobile view */
    }

    .modal-content {
      background-color: var(--card-color);
      padding: 20px;
      border-radius: 10px;
      width: 100%; /* Use padding on modal for spacing */
      max-width: 500px;
      max-height: 85vh; /* Adjust max height */
      overflow-y: auto;
      position: relative;
       transition: background-color 0.3s ease;
      -webkit-overflow-scrolling: touch;
    }

    .modal-close-btn {
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 1.8rem; /* Larger tap target */
      line-height: 1;
      background: none;
      border: none;
      cursor: pointer;
      color: var(--text-color);
      padding: 8px; /* Larger tap target */
      margin: -8px; /* Offset padding */
       transition: color 0.3s ease;
    }
     .modal-close-btn:hover {
         color: var(--accent-color);
     }


     .snackbar {
      position: fixed;
      bottom: -100px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 12px 24px;
      border-radius: 4px;
      z-index: 1001;
      transition: bottom 0.3s ease-out, opacity 0.3s ease-out; /* Added opacity */
      opacity: 0;
      pointer-events: none;
      text-align: center;
      max-width: 90%;
      /* Ensure it's above mobile bottom controls */
      margin-bottom: calc(env(safe-area-inset-bottom, 0px) + 10px); /* Adjust for safe area + margin */
    }
     /* Adjust position if bottom controls are visible */
     body.has-bottom-controls .snackbar {
        margin-bottom: calc(env(safe-area-inset-bottom, 0px) + 70px + 10px); /* Controls height + margin */
     }
     .snackbar.show {
        bottom: 20px; /* Base position */
        opacity: 1;
        pointer-events: auto;
     }


    @media print {
      .scrollable-list-area {
        max-height: none;
        overflow: visible;
      }
    }


    /* Custom Playlist Styles */
    .user-playlist-item {
      padding: 10px;
      border-radius: 6px;
      margin-bottom: 5px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background-color: rgba(142, 36, 170, 0.05);
      transition: background-color 0.2s ease;
    }

    .user-playlist-item:hover {
      background-color: rgba(142, 36, 170, 0.15);
    }
     .dark .user-playlist-item {
         background-color: rgba(187, 134, 252, 0.1);
     }
     .dark .user-playlist-item:hover {
         background-color: rgba(187, 134, 252, 0.2);
     }

    .user-playlist-actions {
      display: flex;
      gap: 10px;
    }
    .playlist-count {
      padding: 2px 8px;
      background-color: var(--primary-color);
      color: white;
      border-radius: 10px;
      font-size: 0.75rem;
      margin-left: 8px;
       transition: background-color 0.3s ease;
    }
     .dark .playlist-count {
         color: var(--background-color);
     }

     /* Dropdown Styling */
     .dropdown-menu {
      background-color: var(--card-color);
      border: 1px solid var(--border-color);
      transition: background-color 0.3s ease, border-color 0.3s ease;
    }
    .dropdown-menu a:hover {
       background-color: rgba(142, 36, 170, 0.1);
    }
     .dark .dropdown-menu a:hover {
        background-color: rgba(187, 134, 252, 0.15);
     }

    /* --- Mobile Specific Adjustments --- */
    @media (max-width: 1023px) { /* Below lg breakpoint */
      .app-container {
         padding: 0;
      }
       .app-container > header {
           /* Mobile header layout */
           flex-direction: column;
           align-items: flex-start;
           gap: 10px;
       }
       .app-container > header .flex.items-center.gap-4 { /* Search + buttons */
           width: 100%;
           justify-content: space-between;
       }
       .app-container > header .search-container {
           flex-grow: 1;
           margin-right: 10px;
       }
       .app-container > header .search-input {
           width: 100%;
       }
       .app-container > header .text-2xl { /* Main title */
           font-size: 1.5rem; /* text-xl */
       }
        .app-container > header .text-sm { /* Subtitle */
            font-size: 0.8rem;
        }
        .app-container > header .fa-music {
             font-size: 2rem; /* text-3xl */
        }


       .music-player {
           border-radius: 0;
           box-shadow: none;
       }

       /* Hide desktop controls */
       .player-controls { display: none; }
       #desktop-volume-control { display: none; } /* Give desktop volume control a specific ID if needed */

       .player-main-column {
           padding: 10px 10px 0 10px; /* Padding around player elements */
           flex-shrink: 0; /* Prevent shrinking */
           display: flex;
           flex-direction: column;
       }

       .playlist-column {
           padding: 0 10px 0 10px; /* Horizontal padding */
           display: flex;
           flex-direction: column;
           flex-grow: 1;
           overflow: hidden;
           padding-bottom: 80px; /* Space for fixed controls + safe area */
           padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 70px); /* Adjust height */
       }

        .tabs {
            margin-bottom: 5px;
        }

       .scrollable-list-area {
           scrollbar-width: none; /* Hide scrollbar */
       }
       .scrollable-list-area::-webkit-scrollbar {
           display: none; /* Hide scrollbar */
       }
       .playlist-item, .history-item, .favorite-item {
          padding: 10px 5px; /* Adjust padding */
       }
       .playlist-item h3, .history-item h3, .favorite-item h3 { font-size: 0.9rem; }
       .playlist-item p, .history-item p, .favorite-item p { font-size: 0.75rem; }
       .playlist-item .w-10, .history-item .w-10, .favorite-item .w-10 { width: 36px; height: 36px; }

       /* Progress bar touch */
       .progress-container {
           height: 8px;
           border-radius: 8px;
           padding-top: 12px;
           padding-bottom: 12px;
           margin-top: -12px;
           margin-bottom: 5px; /* Space below progress */
       }
       .progress-bar { border-radius: 8px; }

       /* Time display */
       /* 時間表示のコンテナ */
.time-display {
  display: flex;
  justify-content: space-between;
  margin-top: 8px;
}

/* 個々の時間表示 */
#current-time, #total-time {
  font-size: 0.85rem;
  font-family: 'Poppins', sans-serif;
  font-weight: 500;
  color: var(--text-color);
  opacity: 0.8;
}


    } /* End mobile styles */


    /* Fixed Bottom Controls (Mobile Only) */
    #bottom-controls {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background-color: var(--card-color);
        border-top: 1px solid var(--border-color);
        padding: 10px 15px;
        padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 10px); /* iOS Safe Area */
        display: flex;
        align-items: center;
        justify-content: space-between;
        z-index: 500; /* Ensure above content, below modals */
        transition: background-color 0.3s ease, border-color 0.3s ease;
        height: 70px; /* Fixed height */
        height: calc(env(safe-area-inset-bottom, 0px) + 70px); /* Add safe area to height */
    }
    /* Adjust button sizes */
    #bottom-controls button { padding: 5px; }
    #bottom-controls #btn-play-mobile { width: 50px; height: 50px; font-size: 1.8rem; flex-shrink: 0; }
    #bottom-controls #btn-prev-mobile, #bottom-controls #btn-next-mobile { font-size: 1.6rem; flex-shrink: 0; }
    #bottom-controls #btn-shuffle-mobile, #bottom-controls #btn-loop-mobile { font-size: 1.2rem; width: 35px; height: 35px; flex-shrink: 0; }

    /* Control layout for mobile */
    #bottom-controls .controls-left { order: 1; display: flex; align-items: center; gap: 15px; }
    #bottom-controls .controls-center { order: 2; display: flex; align-items: center; gap: 25px; flex-grow: 1; justify-content: center; }
    #bottom-controls .controls-right { order: 3; /* Currently empty, could hold volume toggle */ }

    /* Hide bottom controls on larger screens */
    @media (min-width: 1024px) {
        #bottom-controls { display: none; }
    }


  </style>
</head>

<body>
  <div class="app-container" id="app">
    <header class="flex flex-col md:flex-row justify-between items-center mb-6 gap-4">
      <div class="flex items-center">
        <i class="fas fa-music text-4xl mr-3" style="color: var(--primary-color)"></i>
        <h1 class="text-2xl md:text-3xl font-bold">Rei Kikuchi <span class="text-sm md:text-base font-normal">Premium Music Player</span></h1>
      </div>
      <div class="flex items-center gap-4">
        <div class="search-container">
          <i class="fas fa-search search-icon"></i>
          <input type="text" id="search-input" class="search-input px-4 py-2 rounded-full w-full md:w-64" placeholder="曲名を検索...">
        </div>
        <button id="theme-toggle" class="btn-mode btn-inactive" aria-label="テーマ切り替え">
          <i class="fas fa-moon"></i>
        </button>
        <button id="account-btn" class="btn-mode btn-inactive" aria-label="アカウント">
          <i class="fas fa-user"></i>
        </button>
      </div>
    </header>
    
    <!-- プロフィールセクション -->
    <div id="profile-section" class="bg-gradient-to-r from-purple-100 to-indigo-100 dark:from-purple-900 dark:to-indigo-900 rounded-lg p-4 mb-6 shadow-md transition-all duration-300 ease-in-out">
      <div class="flex flex-col md:flex-row items-center justify-between">
        <div class="flex items-center mb-4 md:mb-0">
          <div class="w-16 h-16 md:w-20 md:h-20 rounded-full overflow-hidden border-4 border-white dark:border-gray-800 shadow-lg mr-4 flex-shrink-0">
            <img src="https://i.ytimg.com/vi/o3BudA6Qm6Y/hqdefault.jpg" alt="Rei Kikuchi" class="w-full h-full object-cover">
          </div>
          <div>
            <h2 class="text-xl md:text-2xl font-bold">Rei Kikuchi</h2>
            <p class="text-sm md:text-base opacity-75">音楽クリエイター / Riffusion アーティスト</p>
          </div>
        </div>
        <div class="flex flex-wrap gap-3 justify-center md:justify-end">
          <a href="https://www.youtube.com/channel/UCYAuSEKhuk3v4ZKzm5Lqb1Q" target="_blank" rel="noopener noreferrer" class="flex items-center px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-full transition-colors duration-200 shadow-md">
            <i class="fab fa-youtube mr-2 text-lg"></i>
            <span>YouTube</span>
          </a>
          <a href="https://www.instagram.com/youtube_rei_kikuchi/" target="_blank" rel="noopener noreferrer" class="flex items-center px-4 py-2 bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white rounded-full transition-colors duration-200 shadow-md">
            <i class="fab fa-instagram mr-2 text-lg"></i>
            <span>Instagram</span>
          </a>
          <a href="https://www.riffusion.com/u/REI_KIKUCHI" target="_blank" rel="noopener noreferrer" class="flex items-center px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-full transition-colors duration-200 shadow-md">
            <i class="fas fa-music mr-2 text-lg"></i>
            <span>Riffusion</span>
          </a>
        </div>
      </div>
    </div>

    <div class="music-player p-4 md:p-6">
      <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <!-- Player Section -->
        <div class="lg:col-span-2">
          <div class="youtube-container mb-4">
            <div id="youtube-player"></div>
            <span id="now-playing-badge" class="badge hidden">NOW PLAYING</span>
          </div>
          <div class="flex justify-end mb-2 gap-2">
            <button id="share-btn" class="px-3 py-1 rounded-md text-sm disabled:opacity-50" style="background-color: var(--border-color);" disabled>
              <i class="fas fa-share-alt mr-1"></i> 共有
            </button>
            <button id="open-youtube-btn" class="px-3 py-1 rounded-md text-sm disabled:opacity-50" style="background-color: var(--border-color);" disabled>
              <i class="fab fa-youtube mr-1"></i> YouTubeで開く
            </button>
          </div>
          <div class="visualizer-container mb-4">
            <canvas id="visualizer"></canvas>
          </div>
          <div class="player-info mb-4">
            <h2 id="current-song-title" class="text-xl font-bold truncate">選択された曲はありません</h2>
            <p id="current-song-duration" class="text-sm opacity-75">--:--</p>
          </div>
          <div class="progress-container mb-4">
            <div class="progress-bar" id="progress-bar"></div>
          </div>
          <div class="flex items-center justify-between mb-4">
            <span id="current-time">00:00</span>
            <span id="total-time">00:00</span>
          </div>
          <div class="player-controls flex items-center justify-between mb-6">
            <div class="flex items-center gap-4">
              <button id="btn-shuffle" class="text-xl btn-inactive rounded-full w-10 h-10 flex items-center justify-center" aria-label="シャッフル">
                <i class="fas fa-random"></i>
              </button>
              <button id="btn-loop" class="text-xl btn-inactive rounded-full w-10 h-10 flex items-center justify-center" aria-label="リピート">
                <i class="fas fa-repeat"></i>
              </button>
            </div>
            <div class="flex items-center gap-4">
              <button id="btn-prev" class="text-2xl" aria-label="前の曲">
                <i class="fas fa-step-backward"></i>
              </button>
              <button id="btn-play" class="text-4xl btn-active rounded-full w-16 h-16 flex items-center justify-center" aria-label="再生">
                <i class="fas fa-play"></i>
              </button>
              <button id="btn-next" class="text-2xl" aria-label="次の曲">
                <i class="fas fa-step-forward"></i>
              </button>
            </div>
            <div class="flex items-center gap-2">
              <i class="fas fa-volume-up text-sm" aria-hidden="true"></i>
              <div class="volume-control">
                <input type="range" id="volume-slider" min="0" max="100" value="100" aria-label="音量調整">
              </div>
            </div>
          </div>
        </div>

        <!-- Playlist Section -->
        <div class="lg:col-span-1">
          <div class="tabs">
            <div class="tab active" data-tab="playlist" role="tab" aria-selected="true">プレイリスト</div>
            <div class="tab" data-tab="history" role="tab" aria-selected="false">再生履歴</div>
            <div class="tab" data-tab="favorites" role="tab" aria-selected="false">お気に入り</div>
            <div class="tab" data-tab="user-playlists" role="tab" aria-selected="false">マイプレイリスト</div>
          </div>

          <div id="playlist-tab" class="tab-content" role="tabpanel">
            <div class="playlist" id="playlist">
              <div class="text-center py-8 text-gray-500">
                <i class="fas fa-spinner fa-spin text-3xl mb-4"></i>
                <p>楽曲を読み込み中...</p>
              </div>
            </div>
          </div>

          <div id="history-tab" class="tab-content hidden" role="tabpanel">
            <div class="playlist history-list" id="history-list">
              <div class="text-center py-8 text-gray-500">
                <p>再生履歴はありません</p>
              </div>
            </div>
          </div>

          <div id="favorites-tab" class="tab-content hidden" role="tabpanel">
            <div class="playlist favorites-list" id="favorites-list">
              <div class="text-center py-8 text-gray-500">
                <p>お気に入りに登録された曲はありません</p>
              </div>
            </div>
          </div>

          <!-- マイプレイリストタブ部分（HTML） -->
<div id="user-playlists-tab" class="tab-content hidden" role="tabpanel">
  <div class="mb-4">
    <button id="create-playlist-btn" class="px-3 py-1 rounded-md text-sm mb-4" style="background-color: var(--primary-color); color: white;">
      <i class="fas fa-plus mr-1"></i> 新しいプレイリスト
    </button>
  </div>
  <div class="playlist user-playlists-list" id="user-playlists-list">
    <div class="text-center py-8 text-gray-500">
      <p>マイプレイリストはありません</p>
              </div>
            </div>
          </div>          
        </div>
      </div>
    </div>

    <!-- Modal Dialogs -->
    <div id="create-playlist-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="create-playlist-modal-title">
      <div class="modal-content">
        <div class="flex justify-between items-center mb-4">
          <h3 id="create-playlist-modal-title" class="text-lg font-bold">新しいプレイリストを作成</h3>
          <button class="modal-close-btn close-modal-btn" data-modal-id="createPlaylist" aria-label="閉じる">×</button>
        </div>
        <div class="mb-4">
          <label for="playlist-name-input" class="block text-sm mb-2">プレイリスト名</label>
          <input type="text" id="playlist-name-input" class="w-full px-3 py-2 border rounded focusable" style="border-color: var(--border-color); background-color: var(--card-color);">
        </div>
        <div>
          <button id="save-playlist-btn" class="px-4 py-2 rounded text-white focusable" style="background-color: var(--primary-color);">保存</button>
        </div>
      </div>
    </div>

    <div id="share-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="share-modal-title">
      <div class="modal-content">
        <div class="flex justify-between items-center mb-4">
          <h3 id="share-modal-title" class="text-lg font-bold">共有</h3>
          <button class="modal-close-btn close-modal-btn" data-modal-id="share" aria-label="閉じる">×</button>
        </div>
        <p id="share-object-title" class="mb-4"></p>
        <div class="flex gap-4 mb-4">
          <button class="share-option flex-1 px-3 py-2 rounded text-white focusable" style="background-color: #1DA1F2;">
            <i class="fab fa-twitter mr-2"></i> Twitter
          </button>
          <button class="share-option flex-1 px-3 py-2 rounded text-white focusable" style="background-color: #4267B2;">
            <i class="fab fa-facebook-f mr-2"></i> Facebook
          </button>
        </div>
        <div class="mb-4">
          <label for="share-link-input" class="block text-sm mb-2">共有リンク</label>
          <div class="flex">
            <input type="text" id="share-link-input" class="flex-1 px-3 py-2 border rounded-l focusable" style="border-color: var(--border-color); background-color: var(--card-color);" readonly>
            <button id="copy-link-btn" class="px-3 py-2 rounded-r text-white focusable" style="background-color: var(--primary-color);">コピー</button>
          </div>
        </div>
      </div>
    </div>

  <!-- アカウントモーダル（アップグレード版） -->
<div id="account-modal" class="fixed inset-0 flex items-center justify-center bg-black bg-opacity-50 z-50 hidden" role="dialog" aria-modal="true" aria-labelledby="account-modal-title">
  <div class="bg-white dark:bg-gray-800 rounded-lg shadow-lg max-w-md w-full p-6">
    <!-- ヘッダー -->
    <div class="flex justify-between items-center mb-4">
      <h3 id="account-modal-title" class="text-lg font-bold text-gray-800 dark:text-gray-200">アカウント設定</h3>
      <button class="modal-close-btn text-2xl leading-none" data-modal-id="account" aria-label="閉じる">×</button>
    </div>

    <!-- ログインセクション -->
    <div id="login-section">
      <div class="mb-4">
        <label for="login-email" class="block text-sm mb-2 text-gray-700 dark:text-gray-300">メールアドレス</label>
        <input type="email" id="login-email" class="w-full px-3 py-2 border rounded focus:outline-none" style="border-color: var(--border-color); background-color: var(--card-color);">
      </div>
      <div class="mb-4">
        <label for="login-password" class="block text-sm mb-2 text-gray-700 dark:text-gray-300">パスワード</label>
        <input type="password" id="login-password" class="w-full px-3 py-2 border rounded focus:outline-none" style="border-color: var(--border-color); background-color: var(--card-color);">
      </div>
      <div class="mb-4 flex space-x-2">
        <button id="login-btn" class="px-4 py-2 rounded text-white focus:outline-none" style="background-color: var(--primary-color);">ログイン</button>
        <button id="show-register-btn" class="px-4 py-2 rounded focus:outline-none" style="background-color: var(--border-color);">新規登録</button>
      </div>
    </div>

    <!-- 登録セクション -->
    <div id="register-section" class="hidden">
      <div class="mb-4">
        <label for="register-name" class="block text-sm mb-2 text-gray-700 dark:text-gray-300">ユーザー名</label>
        <input type="text" id="register-name" class="w-full px-3 py-2 border rounded focus:outline-none" style="border-color: var(--border-color); background-color: var(--card-color);">
      </div>
      <div class="mb-4">
        <label for="register-email" class="block text-sm mb-2 text-gray-700 dark:text-gray-300">メールアドレス</label>
        <input type="email" id="register-email" class="w-full px-3 py-2 border rounded focus:outline-none" style="border-color: var(--border-color); background-color: var(--card-color);">
      </div>
      <div class="mb-4">
        <label for="register-password" class="block text-sm mb-2 text-gray-700 dark:text-gray-300">パスワード</label>
        <input type="password" id="register-password" class="w-full px-3 py-2 border rounded focus:outline-none" style="border-color: var(--border-color); background-color: var(--card-color);">
      </div>
      <div class="mb-4 flex space-x-2">
        <button id="register-btn" class="px-4 py-2 rounded text-white focus:outline-none" style="background-color: var(--primary-color);">登録</button>
        <button id="show-login-btn" class="px-4 py-2 rounded focus:outline-none" style="background-color: var(--border-color);">ログインに戻る</button>
      </div>
    </div>

    <!-- アカウント情報セクション -->
    <div id="account-info-section" class="hidden">
      <div class="mb-4 text-center">
        <div class="w-16 h-16 rounded-full bg-gray-300 dark:bg-gray-600 flex items-center justify-center mx-auto mb-2">
          <i class="fas fa-user text-3xl text-gray-700 dark:text-gray-200"></i>
        </div>
        <h4 id="user-name" class="font-bold text-gray-800 dark:text-gray-200"></h4>
        <p id="user-email" class="text-sm opacity-75 text-gray-700 dark:text-gray-300"></p>
      </div>
      <div class="mb-4 space-y-2">
        <button id="sync-data-btn" class="w-full px-4 py-2 rounded focus:outline-none" style="background-color: var(--border-color);">
          <i class="fas fa-sync mr-2"></i> データを同期
        </button>
        <button id="logout-btn" class="w-full px-4 py-2 rounded text-white focus:outline-none" style="background-color: var(--accent-color);">
          <i class="fas fa-sign-out-alt mr-2"></i> ログアウト
        </button>
      </div>
    </div>
  </div>
</div>



    <div id="playlist-detail-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="playlist-detail-modal-title">
       <div class="modal-content max-h-[80vh]">
         <div class="flex justify-between items-center mb-4">
           <h3 id="playlist-detail-title" class="text-lg font-bold">プレイリスト</h3>
           <button class="modal-close-btn close-modal-btn" data-modal-id="playlistDetail" aria-label="閉じる">×</button>
         </div>
         <div id="playlist-detail-content" class="playlist-detail-list">
           <p class="text-center py-8 text-gray-500">プレイリストを読み込み中...</p>
         </div>
         <div class="flex gap-2 mt-4">
           <button id="remove-from-playlist-btn" class="px-3 py-1 rounded text-sm hidden focusable" style="background-color: var(--accent-color); color: white;">
             <i class="fas fa-minus mr-1"></i> 選択を削除
           </button>
           <button id="share-playlist-btn" class="px-3 py-1 rounded text-sm ml-auto focusable" style="background-color: var(--primary-color); color: white;">
             <i class="fas fa-share-alt mr-1"></i> 共有
           </button>
         </div>
       </div>
     </div>


    <div id="snackbar" class="snackbar"></div>

    <footer class="mt-8 text-center text-sm opacity-75">
      <p>© 2025 Rei Kikuchi Music Player | このプレイヤーはRei Kikuchiによって作られました</p>
    </footer>
  </div>

  <!-- YouTube API -->
  <script src="https://www.youtube.com/iframe_api"></script>
  <script>
    // Constants
    const MAX_HISTORY = 20;
    const VOLUME_STEP = 5; // For keyboard control
    const SEEK_STEP = 5; // For keyboard control (seconds)

    // Data and State Management
    const appState = {
      player: null,
      songs: [],
      filteredSongs: [], // Currently displayed songs in the main playlist tab
      currentSongIndex: -1, // Index within the original `songs` array
      isPlaying: false,
      isShuffle: false,
      loopMode: 'none', // 'none', 'one', 'all'
      currentTab: 'playlist',
      volume: 100,
      progressInterval: null,
      history: [],
      favorites: [],
      userPlaylists: [],
      currentSelectedPlaylist: null, // ID of the playlist being viewed/edited
      loggedInUser: null,
      snackbarTimeoutId: null, // For managing snackbar display
      activeModalId: null, // Track the currently open modal
      isPlayerReady: false,
      visualizer: {
          context: null,
          analyser: null,
          animationFrameId: null,
          bufferLength: 0,
          dataArray: null,
          canvas: null,
          canvasCtx: null,
      }
    };
    async function loadSongsFromYouTube() {
  try {
    // 最新15件の動画データを取得
    const videos = await youtubeAPI.getLatestVideos(15);
    if (videos.length === 0) {
      showSnackbar("新しい動画は見つかりませんでした");
      return;
    }
    // 動画IDの配列を作成（前後の空白を除去）
    const videoIds = videos.map(video => video.id.trim());
    // 動画詳細情報を取得（duration など）
    const videoDetails = await youtubeAPI.getVideoDetails(videoIds);
    
    // 各動画データに正しい duration をマージして設定する
    appState.songs = videos.map(video => {
      // getVideoDetails の中から該当する動画を探す
      const details = videoDetails.find(detail => detail.id === video.id) || {};
      return {
        id: video.id.trim(),
        title: video.title,
        duration: details.duration || '--:--',  // 正しい duration があれば上書き
        thumbnail: video.thumbnail
      };
    });
    // フィルタリング用の配列も更新
    appState.filteredSongs = [...appState.songs];
    renderPlaylist(); // プレイリストの表示を更新
  } catch (error) {
    console.error("動画データの取得に失敗しました", error);
    showSnackbar("動画データの取得に失敗しました");
  }
}


    // Elements (Cache DOM elements)
    const elements = {
      app: document.getElementById('app'),
      playlist: document.getElementById('playlist'),
      historyList: document.getElementById('history-list'),
      favoritesList: document.getElementById('favorites-list'),
      userPlaylistsList: document.getElementById('user-playlists-list'),
      currentSongTitle: document.getElementById('current-song-title'),
      currentSongDuration: document.getElementById('current-song-duration'),
      progressBar: document.getElementById('progress-bar'),
      progressContainer: document.querySelector('.progress-container'),
      currentTime: document.getElementById('current-time'),
      totalTime: document.getElementById('total-time'),
      btnPlay: document.getElementById('btn-play'),
      btnPrev: document.getElementById('btn-prev'),
      btnNext: document.getElementById('btn-next'),
      btnShuffle: document.getElementById('btn-shuffle'),
      btnLoop: document.getElementById('btn-loop'),
      volumeSlider: document.getElementById('volume-slider'),
      themeToggle: document.getElementById('theme-toggle'),
      searchInput: document.getElementById('search-input'),
      tabs: document.querySelectorAll('.tab'),
      tabContents: document.querySelectorAll('.tab-content'),
      visualizerCanvas: document.getElementById('visualizer'),
      nowPlayingBadge: document.getElementById('now-playing-badge'),
      openYouTubeBtn: document.getElementById('open-youtube-btn'), // Changed from download
      shareBtn: document.getElementById('share-btn'),
      createPlaylistBtn: document.getElementById('create-playlist-btn'),
      modals: {
        createPlaylist: document.getElementById('create-playlist-modal'),
        playlistDetail: document.getElementById('playlist-detail-modal'),
        share: document.getElementById('share-modal'),
        account: document.getElementById('account-modal')
      },
      modalCloseBtns: document.querySelectorAll('.close-modal-btn'),
      modalButtons: {
        savePlaylist: document.getElementById('save-playlist-btn'),
        removeFromPlaylist: document.getElementById('remove-from-playlist-btn'),
        sharePlaylist: document.getElementById('share-playlist-btn'),
        copyLink: document.getElementById('copy-link-btn'),
        login: document.getElementById('login-btn'),
        showRegister: document.getElementById('show-register-btn'),
        register: document.getElementById('register-btn'),
        showLogin: document.getElementById('show-login-btn'),
        syncData: document.getElementById('sync-data-btn'),
        logout: document.getElementById('logout-btn'),
        account: document.getElementById('account-btn')
      },
      accountSections: {
        login: document.getElementById('login-section'),
        register: document.getElementById('register-section'),
        accountInfo: document.getElementById('account-info-section')
      },
      accountFields: {
        loginEmail: document.getElementById('login-email'),
        loginPassword: document.getElementById('login-password'),
        registerName: document.getElementById('register-name'),
        registerEmail: document.getElementById('register-email'),
        registerPassword: document.getElementById('register-password'),
        userName: document.getElementById('user-name'),
        userEmail: document.getElementById('user-email')
      },
      playlistElements: {
        nameInput: document.getElementById('playlist-name-input'),
        detailTitle: document.getElementById('playlist-detail-title'),
        detailContent: document.getElementById('playlist-detail-content'),
        shareObjectTitle: document.getElementById('share-object-title'), // Renamed for clarity
        shareLinkInput: document.getElementById('share-link-input')
      },
      snackbar: document.getElementById('snackbar')
    };

    // Initialize YouTube Player
    function onYouTubeIframeAPIReady() {
      try {
        appState.player = new YT.Player('youtube-player', {
          height: '100%',
          width: '100%',
          videoId: '', // Start empty
          playerVars: {
            'autoplay': 0,
            'controls': 0, // Hide native controls
            'rel': 0,
            'showinfo': 0,
            'modestbranding': 1,
            'fs': 0, // Disable fullscreen button
            'playsinline': 1 // Important for mobile web
          },
          events: {
            'onReady': onPlayerReady,
            'onStateChange': onPlayerStateChange,
            'onError': onPlayerError // Add error handler
          }
        });
      } catch (error) {
          console.error("Error initializing YouTube Player:", error);
          showSnackbar("プレイヤーの初期化に失敗しました。");
      }
    }

    function onPlayerReady(event) {
  console.log("Player Ready");
  appState.isPlayerReady = true;
  elements.volumeSlider.value = appState.volume;
  event.target.setVolume(appState.volume);

  // loadSongs();  // 旧モックデータの読み込みはコメントアウト
  loadSongsFromYouTube();  // APIから最新動画を取得して読み込む

  loadUserData();
  initAudioAnalyser();
  setupEventListeners();
  handleUrlParams();
}


    function onPlayerStateChange(event) {
      console.log("Player State Changed:", event.data);
      const playerState = event.data;

      if (playerState === YT.PlayerState.ENDED) { // 0: Ended
        handleSongEnd();
      } else if (playerState === YT.PlayerState.PLAYING) { // 1: Playing
        elements.btnPlay.innerHTML = '<i class="fas fa-pause"></i>';
        elements.btnPlay.setAttribute('aria-label', '一時停止');
        appState.isPlaying = true;
        elements.nowPlayingBadge.classList.remove('hidden');
        startProgressUpdate();
        if (appState.currentSongIndex !== -1) {
            const currentSong = appState.songs[appState.currentSongIndex];
            addToHistory(currentSong);
            renderHistoryList(); // Update history tab immediately
            // Enable buttons that require a playing song
            elements.shareBtn.disabled = false;
            elements.openYouTubeBtn.disabled = false;
        }
        // Start visualizer animation
        if (appState.visualizer.animationFrameId === null) {
            drawVisualizer();
        }
      } else if (playerState === YT.PlayerState.PAUSED) { // 2: Paused
        elements.btnPlay.innerHTML = '<i class="fas fa-play"></i>';
        elements.btnPlay.setAttribute('aria-label', '再生');
        appState.isPlaying = false;
        elements.nowPlayingBadge.classList.add('hidden');
        stopProgressUpdate();
        // Stop visualizer animation smoothly
        if (appState.visualizer.animationFrameId !== null) {
            cancelAnimationFrame(appState.visualizer.animationFrameId);
            appState.visualizer.animationFrameId = null;
            // Optionally clear canvas or draw a static state
            if (appState.visualizer.canvasCtx) {
                 setTimeout(() => { // Delay clearing slightly for smoother transition
                    appState.visualizer.canvasCtx.clearRect(0, 0, appState.visualizer.canvas.width, appState.visualizer.canvas.height);
                 }, 100);
            }
        }
      } else if (playerState === YT.PlayerState.BUFFERING) { // 3: Buffering
          // Optionally show a loading indicator?
          console.log("Buffering...");
      } else if (playerState === YT.PlayerState.CUED) { // 5: Cued
          // Song loaded, ready to play
          console.log("Song Cued");
          updateProgress(); // Update time display immediately
          elements.shareBtn.disabled = true; // Disable until actually playing
          elements.openYouTubeBtn.disabled = false; // Can open YT page even if cued
          elements.nowPlayingBadge.classList.add('hidden');
          if (appState.visualizer.animationFrameId !== null) {
             cancelAnimationFrame(appState.visualizer.animationFrameId);
             appState.visualizer.animationFrameId = null;
             if (appState.visualizer.canvasCtx) {
                  appState.visualizer.canvasCtx.clearRect(0, 0, appState.visualizer.canvas.width, appState.visualizer.canvas.height);
             }
          }
      }
    }

     function onPlayerError(event) {
         console.error("YouTube Player Error:", event.data);
         let errorMessage = "動画の再生中にエラーが発生しました。";
         switch (event.data) {
             case 2: // Invalid parameter
                 errorMessage = "再生リクエストが無効です。";
                 break;
             case 5: // HTML5 Player Error
                 errorMessage = "プレイヤー内部のエラーが発生しました。";
                 break;
             case 100: // Video not found
                 errorMessage = "動画が見つからないか、削除されました。";
                 break;
             case 101: // Playback denied
             case 150: // Playback denied
                 errorMessage = "この動画は埋め込み再生が許可されていません。";
                 // Automatically try playing the next song?
                 // playNextSong();
                 break;
             default:
                 errorMessage = `不明なエラーが発生しました (コード: ${event.data})。`;
         }
         showSnackbar(errorMessage);
         // Reset player state visually
         elements.btnPlay.innerHTML = '<i class="fas fa-play"></i>';
         elements.btnPlay.setAttribute('aria-label', '再生');
         appState.isPlaying = false;
         elements.nowPlayingBadge.classList.add('hidden');
         stopProgressUpdate();
         resetPlayerInfo();
     }

    // App Initialization Functions
    function loadSongs() {
      // Using mock data
      appState.songs = [...mockSongs];
      appState.filteredSongs = [...mockSongs];
      renderPlaylist();
      console.log("Songs loaded:", appState.songs.length);
    }

    function loadUserData() {
      // Load from localStorage
      const storedHistory = localStorage.getItem('reiKikuchiPlayerHistory');
      const storedFavorites = localStorage.getItem('reiKikuchiPlayerFavorites');
      const storedPlaylists = localStorage.getItem('reiKikuchiPlayerPlaylists');
      const storedUser = localStorage.getItem('reiKikuchiPlayerUser');
      const savedTheme = localStorage.getItem('reiKikuchiPlayerTheme');

      appState.history = storedHistory ? JSON.parse(storedHistory) : [];
      appState.favorites = storedFavorites ? JSON.parse(storedFavorites) : [];
      appState.userPlaylists = storedPlaylists ? JSON.parse(storedPlaylists) : [];
      appState.loggedInUser = storedUser ? JSON.parse(storedUser) : null;

      // Apply theme preference
      if (savedTheme === 'dark') {
        document.body.classList.add('dark');
        elements.themeToggle.innerHTML = '<i class="fas fa-sun"></i>';
        elements.themeToggle.classList.add('btn-active');
        elements.themeToggle.classList.remove('btn-inactive');
      } else {
        document.body.classList.remove('dark');
        elements.themeToggle.innerHTML = '<i class="fas fa-moon"></i>';
        elements.themeToggle.classList.remove('btn-active');
        elements.themeToggle.classList.add('btn-inactive');
      }

      // Render lists based on loaded data
      renderHistoryList();
      renderFavoritesList();
      renderUserPlaylists();
      updateAccountUI(!!appState.loggedInUser); // Update account section based on login state
      console.log("User data loaded.");
    }

    function initAudioAnalyser() {
      // Note: We cannot access the actual audio stream from the YouTube iframe due to security restrictions.
      // This visualizer will simulate audio based on player state (playing/paused).
      try {
        appState.visualizer.canvas = elements.visualizerCanvas;
        if (!appState.visualizer.canvas) {
            console.error("Visualizer canvas not found.");
            return;
        }
        appState.visualizer.canvasCtx = appState.visualizer.canvas.getContext('2d');
        appState.visualizer.bufferLength = 128; // Reduced complexity for simulation
        appState.visualizer.dataArray = new Uint8Array(appState.visualizer.bufferLength);

        resizeCanvas(); // Initial size calculation
        // Don't start drawing animation here, only when playing

      } catch (error) {
        console.error('Visualizer setup failed:', error);
        // Disable visualizer related stuff if failed?
        elements.visualizerCanvas.style.display = 'none'; // Hide it
      }
    }

    function setupEventListeners() {
      // Player Controls
      elements.btnPlay.addEventListener('click', togglePlayPause);
      elements.btnNext.addEventListener('click', playNextSong);
      elements.btnPrev.addEventListener('click', playPreviousSong);
      elements.btnShuffle.addEventListener('click', toggleShuffle);
      elements.btnLoop.addEventListener('click', toggleLoopMode);
      elements.volumeSlider.addEventListener('input', handleVolumeChange);
      elements.progressContainer.addEventListener('click', seekToPosition);

      // Header Controls
      elements.themeToggle.addEventListener('click', toggleTheme);
      elements.searchInput.addEventListener('input', handleSearch);
      elements.modalButtons.account.addEventListener('click', showAccountModal); // Open Account Modal

       // Action Buttons
       elements.shareBtn.addEventListener('click', showShareModal);
       elements.openYouTubeBtn.addEventListener('click', handleOpenYouTube); // Changed from download

      // Tab switching
      elements.tabs.forEach(tab => {
        tab.addEventListener('click', () => switchTab(tab.dataset.tab));
      });

      // ---- Event Delegation for Lists ----
      setupListEventListeners(elements.playlist, handlePlaylistClick);
      setupListEventListeners(elements.historyList, handleHistoryClick);
      setupListEventListeners(elements.favoritesList, handleFavoritesClick);
      setupListEventListeners(elements.userPlaylistsList, handleUserPlaylistsClick);
      setupListEventListeners(elements.playlistElements.detailContent, handlePlaylistDetailClick);

      // My Playlists Tab Button
      elements.createPlaylistBtn.addEventListener('click', showCreatePlaylistModal);

      // Modal Buttons (Common close logic + specific actions)
      elements.modalCloseBtns.forEach(btn => {
        btn.addEventListener('click', () => hideModal(btn.dataset.modalId));
      });
      elements.modalButtons.savePlaylist.addEventListener('click', saveNewPlaylist);
      elements.modalButtons.removeFromPlaylist.addEventListener('click', removeSongFromPlaylist);
      elements.modalButtons.sharePlaylist.addEventListener('click', sharePlaylist);
      elements.modalButtons.copyLink.addEventListener('click', copyShareLink);
      // Account Modal Buttons
      elements.modalButtons.showRegister.addEventListener('click', () => switchAuthSection('register'));
      elements.modalButtons.showLogin.addEventListener('click', () => switchAuthSection('login'));
      elements.modalButtons.login.addEventListener('click', handleLogin);
      elements.modalButtons.register.addEventListener('click', handleRegister);
      elements.modalButtons.logout.addEventListener('click', handleLogout);
      elements.modalButtons.syncData.addEventListener('click', syncUserData);

       // Close modals when clicking outside the content
      Object.values(elements.modals).forEach(modal => {
         modal.addEventListener('click', (e) => {
             if (e.target === modal) { // Clicked on the backdrop
                hideModal(modal.id.replace('-modal', '').replace('-', ''));
             }
         });
      });

       // Global Keydowns for player control & modals
       document.addEventListener('keydown', handleGlobalKeyDown);

      // Window Resize Handler
      window.addEventListener('resize', resizeCanvas);

      console.log("Event listeners set up.");
    }

     // Helper for setting up delegated event listeners on lists
    function setupListEventListeners(listElement, handler) {
        if (listElement) {
            listElement.addEventListener('click', handler);
        } else {
            console.warn("List element not found for event delegation.");
        }
    }

    // --- Event Handlers for Delegated List Clicks ---

    function handlePlaylistClick(event) {
  const target = event.target;
  const playlistItem = target.closest('.playlist-item');
  const favoriteBtn = target.closest('.favorite-btn');
  const addToPlaylistBtn = target.closest('.add-to-playlist-btn');
  const selectPlaylistLink = target.closest('.select-playlist'); // ドロップダウン内のリンクのクリック処理

  if (favoriteBtn && playlistItem) {
    event.stopPropagation();
    const songId = favoriteBtn.dataset.id;
    toggleFavorite(songId);
  } else if (addToPlaylistBtn && playlistItem) {
    event.stopPropagation();
    togglePlaylistDropdown(addToPlaylistBtn);
  } else if (selectPlaylistLink) {
    event.preventDefault();
    event.stopPropagation();
    const songId = selectPlaylistLink.dataset.id;
    const playlistId = selectPlaylistLink.dataset.playlistid;
    addSongToPlaylist(songId, playlistId);
    // ドロップダウンを閉じる
    const dropdown = selectPlaylistLink.closest('.dropdown-menu');
    if (dropdown) dropdown.classList.add('hidden');
  } else if (playlistItem) {
    // クリックされたアイテムの data-id 属性を利用して曲を特定する
    const songId = playlistItem.dataset.id;
    const originalIndex = appState.songs.findIndex(song => song.id === songId);
    if (originalIndex !== -1) {
      playSong(originalIndex);
    }
  } else {
    // 特定のアイテム以外がクリックされた場合、ドロップダウンを閉じるなど
    closeAllPlaylistDropdowns();
  }
}


     function handleHistoryClick(event) {
         const target = event.target;
         const historyItem = target.closest('.history-item');
         const favoriteBtn = target.closest('.favorite-btn');
         const addToPlaylistBtn = target.closest('.add-to-playlist-btn');
         const selectPlaylistLink = target.closest('.select-playlist');

         if (favoriteBtn && historyItem) {
             event.stopPropagation();
             const songId = favoriteBtn.dataset.id;
             toggleFavorite(songId);
         } else if (addToPlaylistBtn && historyItem) {
             event.stopPropagation();
             togglePlaylistDropdown(addToPlaylistBtn);
         } else if (selectPlaylistLink) {
             event.preventDefault();
             event.stopPropagation();
             const songId = selectPlaylistLink.dataset.id;
             const playlistId = selectPlaylistLink.dataset.playlistid;
             addSongToPlaylist(songId, playlistId);
             const dropdown = selectPlaylistLink.closest('.dropdown-menu');
             if (dropdown) dropdown.classList.add('hidden');
         } else if (historyItem) {
             const songId = historyItem.dataset.id;
             const originalIndex = appState.songs.findIndex(song => song.id === songId);
             if (originalIndex !== -1) {
                 playSong(originalIndex);
             }
         } else {
             closeAllPlaylistDropdowns();
         }
     }

     function handleFavoritesClick(event) {
         const target = event.target;
         const favoriteItem = target.closest('.favorite-item');
         const favoriteBtn = target.closest('.favorite-btn');
         const addToPlaylistBtn = target.closest('.add-to-playlist-btn');
         const selectPlaylistLink = target.closest('.select-playlist');

         if (favoriteBtn && favoriteItem) {
             event.stopPropagation();
             const songId = favoriteBtn.dataset.id;
             toggleFavorite(songId); // Will remove it from favorites
         } else if (addToPlaylistBtn && favoriteItem) {
             event.stopPropagation();
             togglePlaylistDropdown(addToPlaylistBtn);
         } else if (selectPlaylistLink) {
             event.preventDefault();
             event.stopPropagation();
             const songId = selectPlaylistLink.dataset.id;
             const playlistId = selectPlaylistLink.dataset.playlistid;
             addSongToPlaylist(songId, playlistId);
             const dropdown = selectPlaylistLink.closest('.dropdown-menu');
             if (dropdown) dropdown.classList.add('hidden');
         } else if (favoriteItem) {
             const songId = favoriteItem.dataset.id;
             const originalIndex = appState.songs.findIndex(song => song.id === songId);
             if (originalIndex !== -1) {
                 playSong(originalIndex);
             }
         } else {
             closeAllPlaylistDropdowns();
         }
     }

     function handleUserPlaylistsClick(event) {
         const target = event.target;
         const playlistItem = target.closest('.user-playlist-item');
         const playBtn = target.closest('.playlist-play-btn');
         const editBtn = target.closest('.playlist-edit-btn');
         const deleteBtn = target.closest('.playlist-delete-btn');

         if (playBtn && playlistItem) {
             event.stopPropagation();
             const playlistId = playBtn.dataset.id;
             playPlaylist(playlistId);
         } else if (editBtn && playlistItem) {
             event.stopPropagation();
             const playlistId = editBtn.dataset.id;
             viewPlaylist(playlistId);
         } else if (deleteBtn && playlistItem) {
             event.stopPropagation();
             const playlistId = deleteBtn.dataset.id;
             deletePlaylist(playlistId);
         } else if (playlistItem) {
             // Click on the playlist item itself defaults to edit/view
             const playlistId = playlistItem.dataset.id;
             viewPlaylist(playlistId);
         }
     }

      function handlePlaylistDetailClick(event) {
          const target = event.target;
          const playlistItem = target.closest('.playlist-item');
          const favoriteBtn = target.closest('.favorite-btn');
          const checkbox = target.closest('.song-select');

          if (favoriteBtn && playlistItem) {
              event.stopPropagation();
              const songId = favoriteBtn.dataset.id;
              toggleFavorite(songId); // Updates localStorage and icon state
              // No need to manually update icon here, toggleFavorite calls renderers
          } else if (checkbox && playlistItem) {
              // Checkbox click, allow default behavior (checking/unchecking)
              event.stopPropagation(); // Prevent song play
          } else if (playlistItem) {
              // Clicked on the item itself (not buttons/checkbox)
              const songId = playlistItem.dataset.id;
              const originalIndex = appState.songs.findIndex(song => song.id === songId);
              if (originalIndex !== -1) {
                  playSong(originalIndex);
                  hideModal('playlistDetail'); // Close modal after selecting song
              }
          }
      }


     // Helper to toggle playlist dropdown visibility
     function togglePlaylistDropdown(buttonElement) {
         const dropdown = buttonElement.nextElementSibling;
         if (!dropdown || !dropdown.classList.contains('dropdown-menu')) return;

         const isHidden = dropdown.classList.contains('hidden');
         // Close all other dropdowns first
         closeAllPlaylistDropdowns();
         // Toggle the current one
         if (isHidden) {
             dropdown.classList.remove('hidden');
         }
         // No else needed because closeAllPlaylistDropdowns handles closing it if it was open.
     }

     // Helper to close all open playlist dropdowns
     function closeAllPlaylistDropdowns() {
         document.querySelectorAll('.dropdown-menu').forEach(d => {
             d.classList.add('hidden');
         });
     }

      // Add a listener to close dropdowns when clicking anywhere else in the app
      document.addEventListener('click', (e) => {
          if (!e.target.closest('.dropdown')) { // If the click is not inside a dropdown container
              closeAllPlaylistDropdowns();
          }
      });


    // Render UI Functions
    function renderPlaylist() {
  const items = appState.filteredSongs;
  const container = elements.playlist;
  container.innerHTML = ''; // 一旦クリア
  let index = 0;
  const chunkSize = 20; // 一度にレンダリングする件数

  function renderChunk() {
    const chunk = items.slice(index, index + chunkSize);
    chunk.forEach((song, i) => {
      // お気に入り状態を判定
      const isFavorite = appState.favorites.some(fav => fav.id === song.id);
      container.innerHTML += `
  <div class="playlist-item p-3 flex items-center justify-between cursor-pointer" data-id="${song.id}">
    <div class="flex items-center overflow-hidden mr-2 flex-grow min-w-0">
      <div class="w-10 h-10 rounded overflow-hidden mr-3 flex-shrink-0">
        <img src="${song.thumbnail}" alt="${escapeHTML(song.title)}" class="w-full h-full object-cover" loading="lazy">
      </div>
      <div class="flex-grow overflow-hidden min-w-0">
        <h3 class="text-sm font-medium truncate">${escapeHTML(song.title)}</h3>
        <!-- 時間表示は削除 -->
      </div>
    </div>
    <div class="flex items-center flex-shrink-0 ml-2">
      <button class="favorite-btn text-lg mr-2 focusable" data-id="${song.id}" aria-label="${isFavorite ? 'お気に入り解除' : 'お気に入り登録'}">
        <i class="fas fa-heart ${isFavorite ? 'text-red-500' : 'text-gray-400'}"></i>
      </button>
    </div>
  </div>
`;

    });
    index += chunkSize;
    if (index < items.length) {
      setTimeout(renderChunk, 0); // イベントループに処理を譲る
    } else {
      updateActiveListItem();
    }
  }
  renderChunk();
}


    function renderHistoryList() {
      // Display history in reverse chronological order (newest first)
      renderList(
          elements.historyList,
          [...appState.history].reverse(),
          'history-item',
          (song) => `data-id="${song.id}"`, // Identify by ID
          true
      );
        updateActiveListItem();
    }

    function renderFavoritesList() {
      renderList(
          elements.favoritesList,
          appState.favorites,
          'favorite-item',
          (song) => `data-id="${song.id}"`, // Identify by ID
          true
      );
        updateActiveListItem();
    }

     // Generic list rendering function
     function renderList(container, items, itemClass, dataAttributeFn, showActions) {
         if (!container) return;

         let listHTML = '';
         const currentSongId = appState.currentSongIndex !== -1 ? appState.songs[appState.currentSongIndex].id : null;

         if (items.length === 0) {
             let message = "曲が見つかりません";
             if (container === elements.historyList) message = "再生履歴はありません";
             else if (container === elements.favoritesList) message = "お気に入りに登録された曲はありません";
             else if (container === elements.playlist && appState.searchInput.value) message = "検索結果はありません";
             else if (container === elements.playlist) message = "プレイリストは空です"; // Should not happen with mock data

             listHTML = `<div class="text-center py-8 text-gray-500"><p>${message}</p></div>`;
         } else {
             items.forEach((song, index) => {
                 if (!song || !song.id) { // Basic check for valid song object
                     console.warn("Invalid song data encountered:", song);
                     return; // Skip invalid entries
                 }
                 const isActive = song.id === currentSongId;
                 const isFavorite = appState.favorites.some(fav => fav.id === song.id);
                 let playlistActionsHTML = '';

                 if (showActions) {
                     const canAddToPlaylist = appState.loggedInUser && appState.userPlaylists.length > 0;
                     playlistActionsHTML = `
                         <button class="favorite-btn text-lg mr-2 focusable" data-id="${song.id}" aria-label="${isFavorite ? 'お気に入り解除' : 'お気に入り登録'}">
                             <i class="fas fa-heart ${isFavorite ? 'text-red-500' : 'text-gray-400'}"></i>
                         </button>
                         ${appState.loggedInUser ? `
                         <div class="dropdown relative inline-block">
                             <button class="add-to-playlist-btn text-lg mr-2 focusable ${canAddToPlaylist ? '' : 'opacity-50 cursor-not-allowed'}" data-id="${song.id}" ${canAddToPlaylist ? '' : 'disabled aria-disabled="true"'} aria-label="プレイリストに追加">
                                 <i class="fas fa-plus"></i>
                             </button>
                             ${canAddToPlaylist ? `
                             <div class="dropdown-menu absolute right-0 mt-2 w-48 rounded-md shadow-lg hidden z-20" style="background-color: var(--card-color); border: 1px solid var(--border-color);">
                                 <div class="py-1 max-h-32 overflow-y-auto">
                                     ${appState.userPlaylists.map(playlist => `
                                         <a href="#" class="block px-4 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-700 select-playlist focusable" data-id="${song.id}" data-playlistid="${playlist.id}">
                                             ${escapeHTML(playlist.name)} <span class="playlist-count">${playlist.songs?.length ?? 0}</span>
                                         </a>
                                     `).join('')}
                                 </div>
                             </div>
                             ` : ''}
                         </div>
                         ` : ''}
                     `;
                 }

                 listHTML += `
                     <div class="${itemClass} p-3 flex items-center justify-between cursor-pointer ${isActive ? 'active' : ''}" ${dataAttributeFn(song, index)}>
                         <div class="flex items-center overflow-hidden mr-2 flex-grow min-w-0">
                             <div class="w-10 h-10 rounded overflow-hidden mr-3 flex-shrink-0">
                                 <img src="${song.thumbnail}" alt="${escapeHTML(song.title)}" class="w-full h-full object-cover" loading="lazy">
                             </div>
                             <div class="flex-grow overflow-hidden min-w-0">
                                 <h3 class="text-sm font-medium truncate">${escapeHTML(song.title)}</h3>
                                
                             </div>
                         </div>
                         ${showActions ? `
                         <div class="flex items-center flex-shrink-0 ml-2">
                             ${playlistActionsHTML}
                         </div>
                         ` : ''}
                     </div>
                 `;
             });
         }
         container.innerHTML = listHTML;
     }


    // ユーザープレイリスト用の状態を保存する配列（既存の appState.userPlaylists を利用）
// 初期化：localStorage からユーザープレイリストを読み込み
appState.userPlaylists = JSON.parse(localStorage.getItem('userPlaylists')) || [];

// プレイリスト一覧描画用関数
function renderUserPlaylists() {
  const container = document.getElementById('user-playlists-list');
  container.innerHTML = ''; // まずクリア

  if (appState.userPlaylists.length === 0) {
    container.innerHTML = `<div class="text-center py-8 text-gray-500"><p>マイプレイリストはありません</p></div>`;
    return;
  }

  appState.userPlaylists.forEach(playlist => {
    const div = document.createElement('div');
    div.className = 'user-playlist-item p-3 flex items-center justify-between cursor-pointer';
    div.dataset.id = playlist.id;
    div.innerHTML = `
      <span class="font-medium truncate mr-2">${playlist.name}</span>
      <button class="playlist-delete-btn text-sm text-red-500" data-id="${playlist.id}">削除</button>
    `;
    container.appendChild(div);
  });
}

// イベントリスナー：新規プレイリスト作成
document.getElementById('create-playlist-btn').addEventListener('click', () => {
  // ログインチェック（未ログインの場合は作成不可）
  if (!appState.loggedInUser) {
    showSnackbar('プレイリストを作成するにはログインしてください');
    return;
  }

  // シンプルに prompt を利用してプレイリスト名を入力（必要なら専用モーダルに置き換え）
  const playlistName = prompt('新しいプレイリストの名前を入力してください:');
  if (!playlistName) return; // キャンセル時は何もしない

  // 新規プレイリスト作成
  const newPlaylist = {
    id: 'pl_' + Date.now(), // 一意なID（簡易版）
    name: playlistName,
    songs: [] // 初期は空のリスト
  };

  appState.userPlaylists.push(newPlaylist);
  localStorage.setItem('userPlaylists', JSON.stringify(appState.userPlaylists));
  renderUserPlaylists();
  showSnackbar(`プレイリスト「${playlistName}」を作成しました`);
});

// イベントリスナー：プレイリスト削除（イベントデリゲーション）
document.getElementById('user-playlists-list').addEventListener('click', function(e) {
  const deleteBtn = e.target.closest('.playlist-delete-btn');
  if (deleteBtn) {
    const playlistId = deleteBtn.dataset.id;
    if (confirm('このプレイリストを削除してもよろしいですか？')) {
      appState.userPlaylists = appState.userPlaylists.filter(p => p.id !== playlistId);
      localStorage.setItem('userPlaylists', JSON.stringify(appState.userPlaylists));
      renderUserPlaylists();
      showSnackbar('プレイリストを削除しました');
    }
  }
});

// 初期化時に一覧を描画
renderUserPlaylists();


    function renderPlaylistDetail(playlist) {
      if (!playlist || !playlist.id) {
          console.error("Invalid playlist object passed to renderPlaylistDetail");
          elements.playlistElements.detailContent.innerHTML = `<p class="text-red-500 text-center py-4">プレイリストの表示中にエラーが発生しました。</p>`;
          return;
      }

      elements.playlistElements.detailTitle.textContent = playlist.name;
      const songsInPlaylist = playlist.songs
                                .map(songId => appState.songs.find(s => s.id === songId))
                                .filter(song => song); // Filter out any songs not found in the main list

      if (songsInPlaylist.length === 0) {
        elements.playlistElements.detailContent.innerHTML = `
          <div class="text-center py-8 text-gray-500">
            <p>このプレイリストには曲が追加されていません</p>
          </div>
        `;
        elements.modalButtons.removeFromPlaylist.classList.add('hidden');
        return;
      }

      let songsHTML = '';
       const currentSongId = appState.currentSongIndex !== -1 ? appState.songs[appState.currentSongIndex].id : null;

      songsInPlaylist.forEach(song => {
        const isFavorite = appState.favorites.some(fav => fav.id === song.id);
         const isActive = song.id === currentSongId;
        songsHTML += `
          <div class="playlist-item p-3 flex items-center justify-between cursor-pointer ${isActive ? 'active' : ''}" data-id="${song.id}">
            <div class="flex items-center overflow-hidden mr-2 flex-grow min-w-0">
               <input type="checkbox" class="song-select mr-3 flex-shrink-0 focusable" data-id="${song.id}" aria-label="${escapeHTML(song.title)}を選択">
              <div class="w-10 h-10 rounded overflow-hidden mr-3 flex-shrink-0">
                <img src="${song.thumbnail}" alt="${escapeHTML(song.title)}" class="w-full h-full object-cover" loading="lazy">
              </div>
              <div class="flex-grow overflow-hidden min-w-0">
                <h3 class="text-sm font-medium truncate">${escapeHTML(song.title)}</h3>
               
              </div>
            </div>
            <div class="flex items-center flex-shrink-0 ml-2">
              <button class="favorite-btn text-lg mr-2 focusable" data-id="${song.id}" aria-label="${isFavorite ? 'お気に入り解除' : 'お気に入り登録'}">
                <i class="fas fa-heart ${isFavorite ? 'text-red-500' : 'text-gray-400'}"></i>
              </button>
              <!-- Maybe add play button here too? -->
            </div>
          </div>
        `;
      });
      elements.playlistElements.detailContent.innerHTML = songsHTML;
      elements.modalButtons.removeFromPlaylist.classList.remove('hidden');
      updateActiveListItem(); // Highlight active song if present
    }

    // --- Player Control Functions ---
    function playSong(originalIndex) {
  if (!appState.isPlayerReady) {
    showSnackbar("プレイヤーの準備ができていません。");
    console.warn("playSong called before player is ready.");
    return;
  }
  if (originalIndex >= 0 && originalIndex < appState.songs.length) {
    appState.currentSongIndex = originalIndex;
    const currentSong = appState.songs[originalIndex];

    if (!currentSong || !currentSong.id) {
      console.error("Invalid song data at index:", originalIndex);
      showSnackbar("曲データの読み込みに失敗しました。");
      return;
    }

    // 動画IDを trim() して不要な空白を除去
    const cleanVideoId = currentSong.id.trim();

    elements.currentSongTitle.textContent = currentSong.title;
    elements.currentSongDuration.textContent = currentSong.duration || '--:--';

    try {
      if (appState.player && typeof appState.player.loadVideoById === 'function') {
        console.log(`Loading video: ${cleanVideoId} (${currentSong.title})`);
        appState.player.loadVideoById(cleanVideoId);
        // loadVideoById の直後に少し遅延させてから再生開始
        setTimeout(() => {
          appState.player.playVideo();
        }, 500);
      } else {
        throw new Error("Player or loadVideoById not available.");
      }
    } catch (error) {
      console.error("Error loading video:", error);
      showSnackbar("動画の読み込みに失敗しました。");
      resetPlayerInfo();
      return;
    }

    updateActiveListItem(); // 再生中の曲をハイライト

    // 再生に伴うUI更新（共有ボタンなど）
    elements.shareBtn.disabled = true;
    elements.openYouTubeBtn.disabled = true;
  } else {
    console.warn("Invalid song index requested:", originalIndex);
  }
}

    function togglePlayPause() {
        if (!appState.isPlayerReady) {
            showSnackbar("プレイヤーの準備ができていません。");
            return;
        }
        if (appState.currentSongIndex === -1 && appState.songs.length > 0) {
            // No song selected, play the first song from the main list
            playSong(0);
            return;
        }
        if (appState.currentSongIndex === -1) {
             showSnackbar("再生する曲がありません。");
             return;
        }

        try {
            const playerState = appState.player.getPlayerState();
            if (playerState === YT.PlayerState.PLAYING) {
                appState.player.pauseVideo();
            } else {
                appState.player.playVideo();
            }
        } catch (error) {
            console.error("Error toggling play/pause:", error);
            showSnackbar("再生/一時停止中にエラーが発生しました。");
        }
    }

    function playNextSong() {
        if (appState.songs.length === 0) return;
        if (appState.currentSongIndex === -1) { // If nothing is playing, start from first
             playSong(0);
             return;
        }

        let nextIndex;
        if (appState.isShuffle) {
            let randomIndex;
            if (appState.songs.length <= 1) {
                randomIndex = 0; // Only one song, just replay or stop based on loop
            } else {
                 do {
                     randomIndex = Math.floor(Math.random() * appState.songs.length);
                 } while (randomIndex === appState.currentSongIndex);
            }
            nextIndex = randomIndex;
        } else {
            nextIndex = (appState.currentSongIndex + 1) % appState.songs.length;
        }
        playSong(nextIndex);
    }

    function playPreviousSong() {
        if (appState.songs.length === 0) return;
        if (appState.currentSongIndex === -1) { // If nothing is playing, maybe play last? Or first? Let's play first.
             playSong(0);
             return;
        }

        try {
            // If current time is more than 3 seconds, restart the song instead of going previous
            if (appState.player.getCurrentTime() > 3) {
                appState.player.seekTo(0);
                return;
            }
        } catch (error) {
            console.warn("Could not get current time for previous song logic:", error);
            // Proceed with changing song anyway
        }


        let prevIndex;
        if (appState.isShuffle) {
             let randomIndex;
             if (appState.songs.length <= 1) {
                 randomIndex = 0;
             } else {
                  do {
                      randomIndex = Math.floor(Math.random() * appState.songs.length);
                  } while (randomIndex === appState.currentSongIndex);
             }
             prevIndex = randomIndex;
        } else {
             prevIndex = appState.currentSongIndex - 1;
             if (prevIndex < 0) {
                 prevIndex = appState.songs.length - 1; // Loop back to the end
             }
        }
        playSong(prevIndex);
    }

    function handleSongEnd() {
        console.log("Song ended. Loop mode:", appState.loopMode);
        switch (appState.loopMode) {
            case 'one':
                try {
                   appState.player.seekTo(0);
                   appState.player.playVideo(); // Explicitly play again
                } catch (error) {
                   console.error("Error replaying song:", error);
                   playNextSong(); // Fallback to next song
                }
                break;
            case 'all':
                playNextSong();
                break;
            case 'none':
            default:
                // Stop playing only if it was the very last song in non-shuffle mode
                if (!appState.isShuffle && appState.currentSongIndex === appState.songs.length - 1) {
                    try {
                        // Don't stop automatically, just pause and reset UI
                        // appState.player.stopVideo(); // stopVideo() is drastic, pause is better
                        appState.player.pauseVideo(); // Pause at the end
                        appState.player.seekTo(0); // Reset to beginning
                    } catch (error) {
                         console.error("Error pausing/seeking at end:", error);
                    }
                    // Update UI in onPlayerStateChange(PAUSED)
                    // resetPlayerInfo(); // Reset display
                } else {
                    // Play next song (even in 'none' mode, unless it was the absolute last)
                    playNextSong();
                }
                break;
        }
    }

    function toggleShuffle() {
      appState.isShuffle = !appState.isShuffle;
      elements.btnShuffle.classList.toggle('btn-active', appState.isShuffle);
      elements.btnShuffle.classList.toggle('btn-inactive', !appState.isShuffle);
      elements.btnShuffle.setAttribute('aria-pressed', appState.isShuffle);
      showSnackbar(`シャッフル: ${appState.isShuffle ? 'オン' : 'オフ'}`);
    }

    function toggleLoopMode() {
      switch (appState.loopMode) {
        case 'none':
          appState.loopMode = 'all';
          elements.btnLoop.innerHTML = '<i class="fas fa-repeat"></i>';
          elements.btnLoop.classList.add('btn-active');
          elements.btnLoop.classList.remove('btn-inactive');
          showSnackbar('リピート: 全曲');
          elements.btnLoop.setAttribute('aria-label', 'リピート: 全曲');
          break;
        case 'all':
          appState.loopMode = 'one';
          // FontAwesome 6 uses fa-1 for repeat-1 icon
          elements.btnLoop.innerHTML = '<i class="fas fa-1" style="font-size: 0.8em; position: relative; top: -0.1em; margin-left: -0.2em;"></i><i class="fas fa-repeat"></i>';
          // Keep btn-active class
          showSnackbar('リピート: 1曲');
           elements.btnLoop.setAttribute('aria-label', 'リピート: 1曲');
          break;
        case 'one':
          appState.loopMode = 'none';
          elements.btnLoop.innerHTML = '<i class="fas fa-repeat"></i>';
          elements.btnLoop.classList.remove('btn-active');
          elements.btnLoop.classList.add('btn-inactive');
          showSnackbar('リピート: オフ');
           elements.btnLoop.setAttribute('aria-label', 'リピート: オフ');
          break;
      }
    }

    function handleVolumeChange() {
        const volume = parseInt(elements.volumeSlider.value);
        setVolume(volume);
    }

     function setVolume(volume) {
         volume = Math.max(0, Math.min(100, volume)); // Clamp volume between 0 and 100
         appState.volume = volume;
         elements.volumeSlider.value = volume; // Update slider position
         if (appState.isPlayerReady && appState.player && typeof appState.player.setVolume === 'function') {
              try {
                 appState.player.setVolume(volume);
              } catch (error) {
                  console.error("Error setting volume:", error);
              }
         }
         // console.log("Volume set to:", volume);
     }

    function adjustVolume(delta) {
        const newVolume = appState.volume + delta;
        setVolume(newVolume); // setVolume handles clamping and updating player/UI
    }


    function seekToPosition(event) {
        if (!appState.isPlayerReady || appState.currentSongIndex === -1) return;

        const progressContainer = elements.progressContainer;
        const rect = progressContainer.getBoundingClientRect();
        const clickX = event.clientX;
        // Ensure click is within the bounds of the progress bar horizontally
        if (clickX < rect.left || clickX > rect.right) {
             return;
        }

        const percent = (clickX - rect.left) / rect.width;

        try {
            const duration = appState.player.getDuration();
            if (duration > 0) {
                const seekTime = duration * percent;
                appState.player.seekTo(seekTime, true); // true allows seek ahead
                updateProgress(); // Update UI immediately after seek
            }
        } catch (error) {
            console.error("Error seeking:", error);
            showSnackbar("シーク中にエラーが発生しました。");
        }
    }

     function seekRelative(deltaSeconds) {
         if (!appState.isPlayerReady || appState.currentSongIndex === -1) return;
         try {
             const currentTime = appState.player.getCurrentTime();
             const duration = appState.player.getDuration();
             if (duration > 0) {
                 let seekTime = currentTime + deltaSeconds;
                 seekTime = Math.max(0, Math.min(seekTime, duration)); // Clamp within bounds
                 appState.player.seekTo(seekTime, true);
                 updateProgress(); // Update UI immediately
             }
         } catch (error) {
             console.error("Error seeking relative:", error);
         }
     }

    function startProgressUpdate() {
      stopProgressUpdate(); // Clear any existing interval
      appState.progressInterval = setInterval(updateProgress, 500); // Update twice per second
      updateProgress(); // Initial update
    }

    function stopProgressUpdate() {
      if (appState.progressInterval) {
        clearInterval(appState.progressInterval);
        appState.progressInterval = null;
      }
    }

    function updateProgress() {
        console.log("updateProgress running..."); // 関数が実行されているか確認
        const progressBar = elements.progressBar;

        if (!appState.isPlayerReady || !appState.player || typeof appState.player.getCurrentTime !== 'function' || appState.currentSongIndex === -1) {
            // console.log("updateProgress: Player not ready or no song.");
            if (progressBar.style.width !== '0%') { // 不要な更新を避ける
                progressBar.style.width = '0%';
                console.log("updateProgress: Reset width to 0%"); // リセット時にログ出力
            }
            elements.currentTime.textContent = '00:00';
            const song = appState.songs[appState.currentSongIndex];
            elements.totalTime.textContent = song?.duration || '00:00';
            return;
        }

        try {
            const currentTime = appState.player.getCurrentTime();
            const duration = appState.player.getDuration();

            // 値を出力して確認
            console.log(`API Values: currentTime=${currentTime?.toFixed(2)}, duration=${duration?.toFixed(2)}`);

            if (typeof currentTime === 'number' && typeof duration === 'number' && duration > 0) {
                const percent = Math.min(100, Math.max(0, (currentTime / duration) * 100));

                if (!isNaN(percent)) {
                    const newWidth = `${percent}%`;
                    // 適用しようとしている幅と、現在の幅を出力
                    console.log(`Calculated: percent=${percent.toFixed(2)}%, newWidth=${newWidth}, currentStyleWidth=${progressBar.style.width}`);
                    // スタイルを適用
                    progressBar.style.width = newWidth;
                    // 適用後のスタイルを再確認 (デバッグ用、通常は不要)
                    // console.log(`Applied width: ${progressBar.style.width}`);
                } else {
                    console.warn(`updateProgress: Calculated percent is NaN (currentTime=${currentTime}, duration=${duration})`);
                    if (progressBar.style.width !== '0%') {
                        progressBar.style.width = '0%';
                        console.log("updateProgress: Reset width to 0% due to NaN");
                    }
                }

                elements.currentTime.textContent = formatTime(currentTime);
                const formattedDuration = formatTime(duration);
                if (elements.totalTime.textContent !== formattedDuration) {
                    elements.totalTime.textContent = formattedDuration;
                    const songDurationDisplay = document.getElementById('current-song-duration');
                    if (songDurationDisplay) songDurationDisplay.textContent = formattedDuration;
                }
            } else if (currentTime === 0 && duration === 0) {
                if (progressBar.style.width !== '0%') {
                    progressBar.style.width = '0%';
                    console.log("updateProgress: Reset width to 0% (times are zero)");
                }
                elements.currentTime.textContent = '00:00';
                const song = appState.songs[appState.currentSongIndex];
                elements.totalTime.textContent = song?.duration || '00:00';
            } else {
                 // 不正値の場合もログ出力
                 console.warn(`updateProgress: Invalid time values (currentTime=${currentTime}, duration=${duration}) - width not updated.`);
            }
        } catch (error) {
            console.error("Error updating progress:", error);
        }
    }

     function resetPlayerInfo() {
         elements.currentSongTitle.textContent = "選択された曲はありません";
         elements.currentSongDuration.textContent = "--:--";
         elements.progressBar.style.width = '0%';
         elements.currentTime.textContent = "00:00";
         elements.totalTime.textContent = "00:00";
         elements.shareBtn.disabled = true;
         elements.openYouTubeBtn.disabled = true;
         elements.nowPlayingBadge.classList.add('hidden');
         updateActiveListItem(); // Clear any active highlights
     }

    // --- Playlist Functions ---
    function showCreatePlaylistModal() {
  if (!appState.loggedInUser) {
    showAccountModal(); // ログイン促す
    showSnackbar('プレイリストを作成するにはログインしてください');
    return;
  }
  elements.playlistElements.nameInput.value = '';
  // 少し遅延させることでブラウザの再描画処理のタイミングをずらす
  setTimeout(() => {
    showModal('createPlaylist');
    elements.playlistElements.nameInput.focus();
  }, 50);
}


    function saveNewPlaylist() {
      const name = elements.playlistElements.nameInput.value.trim();
      if (!name) {
        showSnackbar('プレイリスト名を入力してください');
        elements.playlistElements.nameInput.focus();
        return;
      }
      const newPlaylist = {
        id: `pl_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`, // More robust unique ID
        name: name,
        songs: [],
        created: new Date().toISOString()
      };
      appState.userPlaylists.push(newPlaylist);
      saveUserPlaylists();
      renderUserPlaylists();
       // Re-render other lists in case "Add to Playlist" buttons need to be enabled/updated
       renderPlaylist();
       renderHistoryList();
       renderFavoritesList();
      hideModal('createPlaylist');
      showSnackbar(`プレイリスト「${escapeHTML(name)}」を作成しました`);
    }

     function deletePlaylist(playlistId) {
        const playlistIndex = appState.userPlaylists.findIndex(p => p.id === playlistId);
        if (playlistIndex === -1) return;

        const playlist = appState.userPlaylists[playlistIndex];
        if (confirm(`プレイリスト「${escapeHTML(playlist.name)}」を削除してもよろしいですか？ これによりプレイリスト内の曲は削除されません。`)) {
            appState.userPlaylists.splice(playlistIndex, 1);
            saveUserPlaylists();
            renderUserPlaylists(); // Re-render the list
             // Re-render other lists to update "Add to Playlist" dropdowns
             renderPlaylist();
             renderHistoryList();
             renderFavoritesList();

             if (appState.currentSelectedPlaylist === playlistId) {
                // If the deleted playlist was being viewed, close the detail modal
                hideModal('playlistDetail');
                appState.currentSelectedPlaylist = null;
            }
            showSnackbar(`プレイリスト「${escapeHTML(playlist.name)}」を削除しました`);
        }
    }

    function addSongToPlaylist(songId, playlistId) {
      const playlist = appState.userPlaylists.find(p => p.id === playlistId);
      const song = appState.songs.find(s => s.id === songId);

      if (!playlist || !song) {
           console.error("Playlist or Song not found for adding:", playlistId, songId);
           showSnackbar("エラーが発生しました。");
           return;
      }
      if (!playlist.songs) {
          playlist.songs = []; // Initialize songs array if missing
      }

      // Check if song already exists in playlist
      if (!playlist.songs.includes(songId)) {
        playlist.songs.push(songId);
        saveUserPlaylists();
        renderUserPlaylists(); // Update counts in the main list
        if (appState.currentSelectedPlaylist === playlistId && elements.modals.playlistDetail.style.display === 'flex') {
             // If the detail view is open for this playlist, re-render it
             renderPlaylistDetail(playlist);
        }
         // Update count in dropdowns (re-render lists)
         renderPlaylist();
         renderHistoryList();
         renderFavoritesList();
         showSnackbar(`「${escapeHTML(song.title)}」をプレイリスト「${escapeHTML(playlist.name)}」に追加しました`);
      } else {
        showSnackbar(`「${escapeHTML(song.title)}」は既にプレイリスト「${escapeHTML(playlist.name)}」に存在します`);
      }
       // Close dropdown (might be redundant if handled by global click listener)
       closeAllPlaylistDropdowns();
    }

    function viewPlaylist(playlistId) {
      const playlist = appState.userPlaylists.find(p => p.id === playlistId);
      if (!playlist) {
          showSnackbar("プレイリストが見つかりません。");
          return;
      }
      appState.currentSelectedPlaylist = playlistId;
      renderPlaylistDetail(playlist);
      showModal('playlistDetail');
    }

    function playPlaylist(playlistId) {
      const playlist = appState.userPlaylists.find(p => p.id === playlistId);
      if (!playlist || !playlist.songs || playlist.songs.length === 0) {
          showSnackbar("このプレイリストは空か、再生できる曲がありません。");
          return;
      }
      // Find first song in playlist that exists in the main song list
      let firstPlayableOriginalIndex = -1;
      for (const songId of playlist.songs) {
          const originalIndex = appState.songs.findIndex(song => song && song.id === songId);
          if (originalIndex !== -1) {
              firstPlayableOriginalIndex = originalIndex;
              break;
          }
      }

      if (firstPlayableOriginalIndex !== -1) {
          // TODO: Implement playlist context for next/prev?
          // For now, just play the first song.
          playSong(firstPlayableOriginalIndex);
          showSnackbar(`プレイリスト「${escapeHTML(playlist.name)}」を再生します`);
      } else {
          showSnackbar("プレイリスト内の曲がアプリのライブラリに見つかりません。");
      }
    }


    function removeSongFromPlaylist() {
      const playlistId = appState.currentSelectedPlaylist;
      const playlist = appState.userPlaylists.find(p => p.id === playlistId);
      if (!playlist || !playlist.songs) return;

      const selectedCheckboxes = elements.playlistElements.detailContent.querySelectorAll('.song-select:checked');
      const selectedSongIds = Array.from(selectedCheckboxes).map(el => el.dataset.id);

      if (selectedSongIds.length === 0) {
        showSnackbar('削除する曲を選択してください');
        return;
      }

      const initialLength = playlist.songs.length;
      playlist.songs = playlist.songs.filter(songId => !selectedSongIds.includes(songId));
      const removedCount = initialLength - playlist.songs.length;

      if (removedCount > 0) {
           saveUserPlaylists();
           renderUserPlaylists(); // Update counts in the main list
           renderPlaylistDetail(playlist); // Re-render the detail view (checkboxes will be unchecked)
           showSnackbar(`${removedCount}曲をプレイリストから削除しました`);
      } else {
           showSnackbar("選択された曲は見つかりませんでした。"); // Should not happen if checkboxes were checked
      }
    }

    function sharePlaylist() {
        const playlistId = appState.currentSelectedPlaylist;
        const playlist = appState.userPlaylists.find(p => p.id === playlistId);
        if (!playlist) {
            showSnackbar("共有するプレイリストが見つかりません。");
            return;
        }

        // Generate a shareable link (can be enhanced later)
        const shareLink = `${window.location.origin}${window.location.pathname}?sharedPlaylistId=${playlistId}`;
        const shareTitle = `プレイリスト: ${escapeHTML(playlist.name)}`;

        elements.playlistElements.shareLinkInput.value = shareLink;
        elements.playlistElements.shareObjectTitle.textContent = shareTitle;
        hideModal('playlistDetail'); // Close detail modal first
        showModal('share'); // Show the generic share modal
    }


    // --- Share Functions ---
    function showShareModal() {
        let shareLink = '';
        let shareTitle = '';
        let currentSong = null;

        if (appState.currentSongIndex !== -1 && appState.songs[appState.currentSongIndex]) {
            currentSong = appState.songs[appState.currentSongIndex];
            shareLink = `https://www.youtube.com/watch?v=${currentSong.id}`;
            shareTitle = `曲: ${escapeHTML(currentSong.title)}`;
        } else {
            showSnackbar('共有する曲を再生してください');
            return;
        }

        elements.playlistElements.shareLinkInput.value = shareLink;
        elements.playlistElements.shareObjectTitle.textContent = shareTitle;

        // Setup social media share buttons (basic example)
        const encodedLink = encodeURIComponent(shareLink);
        const encodedTitle = encodeURIComponent(shareTitle + " via Rei Kikuchi Premium Player");

        const twitterBtn = elements.modals.share.querySelector('button[style*="1DA1F2"]'); // Twitter Blue
        if (twitterBtn) {
            twitterBtn.onclick = () => window.open(`https://twitter.com/intent/tweet?text=${encodedTitle}&url=${encodedLink}`, '_blank');
        }

        const facebookBtn = elements.modals.share.querySelector('button[style*="4267B2"]'); // Facebook Blue
        if (facebookBtn) {
             facebookBtn.onclick = () => window.open(`https://www.facebook.com/sharer/sharer.php?u=${encodedLink}`, '_blank');
        }


        showModal('share');
    }

    function copyShareLink() {
      const shareLinkInput = elements.playlistElements.shareLinkInput;
      if (!shareLinkInput.value) {
          showSnackbar('コピーするリンクがありません。');
          return;
      }

      navigator.clipboard.writeText(shareLinkInput.value).then(() => {
          showSnackbar('リンクをクリップボードにコピーしました');
      }).catch(err => {
          console.error('Failed to copy link using Clipboard API: ', err);
          // Fallback for older browsers/insecure contexts
          shareLinkInput.select();
          shareLinkInput.setSelectionRange(0, 99999); // For mobile devices
          try {
              const successful = document.execCommand('copy');
              if (successful) {
                  showSnackbar('リンクをクリップボードにコピーしました (Fallback)');
              } else {
                  showSnackbar('リンクのコピーに失敗しました');
              }
          } catch (errFallback) {
              console.error('Fallback copy failed: ', errFallback);
              showSnackbar('リンクのコピーに失敗しました');
          }
          window.getSelection()?.removeAllRanges(); // Deselect text
      });
    }

    // --- "Open on YouTube" Function ---
    function handleOpenYouTube() {
      if (appState.currentSongIndex === -1 || !appState.songs[appState.currentSongIndex]) {
          showSnackbar('再生中の曲がありません。');
          return;
      }
      const currentSong = appState.songs[appState.currentSongIndex];
      const youtubeUrl = `https://www.youtube.com/watch?v=${currentSong.id}`;
      window.open(youtubeUrl, '_blank'); // Open in new tab
    }

    function showAccountModal() {
  console.log("showAccountModal() が呼ばれました");
  if (appState.loggedInUser) {
    updateAccountUI(true);
    switchAuthSection('account');  // この中で accountInfo から hidden を削除
  } else {
    updateAccountUI(false);
    switchAuthSection('login');
  }
  showModal('account');
}



function switchAuthSection(section) {
    console.log("切り替え処理：", section);
    elements.accountSections.login.classList.add('hidden');
    elements.accountSections.register.classList.add('hidden');
    elements.accountSections.accountInfo.classList.add('hidden');

    const sectionToShow = elements.accountSections[section];
    if (sectionToShow) {
        sectionToShow.classList.remove('hidden');
        // フォーカス設定などもここで行う
        console.log(`${section} セクションが表示されました`);
    } else {
        console.warn("無効なセクション:", section);
    }
}


    // Mock login/register/logout/sync remain the same as before, adding focus management

    function handleLogin() {
      // ... (validation) ...
      console.log("Attempting mock login for:", email);
      showLoadingState(elements.modalButtons.login, true);
      setTimeout(() => {
          // ... (mock user creation) ...
          appState.loggedInUser = mockUser;
          saveToLocalStorage('reiKikuchiPlayerUser', mockUser);
          updateAccountUI(true); // This already re-renders lists as needed
          showSnackbar('ログインしました！');
          hideModal('account');
          showLoadingState(elements.modalButtons.login, false);
          // loadUserData(); // REMOVE THIS CALL?
      }, 1000);
        return false; // Prevent default form submission
    }

    function handleRegister() {
       // ... (validation) ...
        console.log("Attempting mock registration for:", name, email);
        showLoadingState(elements.modalButtons.register, true);
        setTimeout(() => {
           // ... (mock user creation) ...
            appState.loggedInUser = mockUser;
            saveToLocalStorage('reiKikuchiPlayerUser', mockUser);
            updateAccountUI(true); // This already re-renders lists as needed
            showSnackbar('登録が完了しました。ようこそ！');
            hideModal('account');
            showLoadingState(elements.modalButtons.register, false);
             // loadUserData(); // REMOVE THIS CALL?
        }, 1500);
        return false; // Prevent default form submission
    }

    function handleLogout() {
        if (confirm("ログアウトしてもよろしいですか？")) {
            appState.loggedInUser = null;
            localStorage.removeItem('reiKikuchiPlayerUser');
            // Decide whether to clear local playlists/favs/history on logout
            // Example: Keep them locally unless explicitly synced/cleared
            // appState.userPlaylists = [];
            // localStorage.removeItem('reiKikuchiPlayerPlaylists');
            updateAccountUI(false); // This will call render functions
            showSnackbar('ログアウトしました');
            hideModal('account');
            loadUserData(); // Reload data to reflect logged-out state
        }
    }


    function syncUserData() {
        if (!appState.loggedInUser) {
            showSnackbar("同期するにはログインしてください。");
            return;
        }
        // --- Mock Sync ---
        console.log("Attempting data sync for user:", appState.loggedInUser.email);
        showSnackbar("データをサーバーと同期中...");
        setTimeout(() => {
            // Simulate receiving data and merging...
            showSnackbar('データ同期が完了しました (デモ)');
            // Re-render lists in case data changed
            renderFavoritesList();
            renderHistoryList();
            renderUserPlaylists();
        }, 2000);
    }


    function updateAccountUI(isLoggedIn) {
  if (isLoggedIn && appState.loggedInUser) {
    // ユーザー情報を設定
    elements.accountFields.userName.textContent = appState.loggedInUser.name;
    elements.accountFields.userEmail.textContent = appState.loggedInUser.email;
    elements.modalButtons.account.innerHTML = '<i class="fas fa-user-check"></i>';
    elements.modalButtons.account.classList.remove('btn-inactive');
    elements.modalButtons.account.classList.add('btn-active');
    elements.modalButtons.account.setAttribute('aria-label', 'アカウント (ログイン済み)');
    
    // ログイン済みならアカウント情報セクションを表示
    elements.accountSections.accountInfo.classList.remove('hidden');
  } else {
    elements.modalButtons.account.innerHTML = '<i class="fas fa-user"></i>';
    elements.modalButtons.account.classList.add('btn-inactive');
    elements.modalButtons.account.classList.remove('btn-active');
    elements.modalButtons.account.setAttribute('aria-label', 'アカウント (未ログイン)');
    
    // 未ログインならログインセクションを表示
    elements.accountSections.login.classList.remove('hidden');
  }
  
  // その他のリストの再描画処理…
  if (elements.playlist && elements.historyList && elements.favoritesList && elements.userPlaylistsList) {
    renderPlaylist();
    renderHistoryList();
    renderFavoritesList();
    renderUserPlaylists();
  }
}

    // --- Utility Functions ---
    function formatTime(seconds) {
      if (isNaN(seconds) || seconds < 0) {
        return '00:00';
      }
      seconds = Math.floor(seconds);
      const minutes = Math.floor(seconds / 60);
      seconds = seconds % 60;
      return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }

    function toggleTheme() {
        document.body.classList.toggle('dark');
        const isDark = document.body.classList.contains('dark');
        elements.themeToggle.innerHTML = isDark ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
        elements.themeToggle.classList.toggle('btn-active', isDark);
        elements.themeToggle.classList.toggle('btn-inactive', !isDark);
        elements.themeToggle.setAttribute('aria-pressed', isDark);
        localStorage.setItem('reiKikuchiPlayerTheme', isDark ? 'dark' : 'light');
        // Visualizer colors are handled dynamically in drawVisualizer based on dark class
        // Re-draw visualizer immediately if it's currently static (paused)
        if (!appState.isPlaying && appState.visualizer.canvasCtx) {
             appState.visualizer.canvasCtx.clearRect(0, 0, appState.visualizer.canvas.width, appState.visualizer.canvas.height);
        }
    }


    function handleSearch() {
      const searchTerm = elements.searchInput.value.toLowerCase().trim();
      appState.filteredSongs = appState.songs.filter(song =>
          song.title.toLowerCase().includes(searchTerm)
      );
      renderPlaylist(); // Re-render the main playlist with filtered results
      // Optional: Switch back to playlist tab if user searches while on another tab
      if (appState.currentTab !== 'playlist') {
          switchTab('playlist');
      }
    }

    function switchTab(tabName) {
        if (appState.currentTab === tabName) return; // Already on this tab

        appState.currentTab = tabName;
        // Update tab styles
        elements.tabs.forEach(tab => {
            const isSelected = tab.dataset.tab === tabName;
            tab.classList.toggle('active', isSelected);
            tab.setAttribute('aria-selected', isSelected);
        });
        // Show/hide tab content
        elements.tabContents.forEach(content => {
            content.classList.toggle('hidden', content.id !== `${tabName}-tab`);
        });

        // Update active state highlight when switching to a relevant tab
        updateActiveListItem();
        console.log("Switched to tab:", tabName);
    }

    function addToHistory(song) {
      if (!song || !song.id) return; // Ensure valid song object

      // Remove if already exists to move it to the end (most recent)
      appState.history = appState.history.filter(item => item.id !== song.id);

      // Add to the end
      appState.history.push(song);

      // Limit history size
      if (appState.history.length > MAX_HISTORY) {
        appState.history = appState.history.slice(appState.history.length - MAX_HISTORY);
      }

      saveToLocalStorage('reiKikuchiPlayerHistory', appState.history);
      // RenderHistoryList is called from onPlayerStateChange(PLAYING)
    }

    function toggleFavorite(songId) {
        const songIndexInFavorites = appState.favorites.findIndex(song => song && song.id === songId);
        const song = appState.songs.find(s => s && s.id === songId);

        if (!song) {
            console.warn("Cannot toggle favorite for unknown song ID:", songId);
            return;
        }

        if (songIndexInFavorites > -1) {
            // Remove from favorites
            appState.favorites.splice(songIndexInFavorites, 1);
            showSnackbar(`「${escapeHTML(song.title)}」をお気に入りから削除しました`);
        } else {
            // Add to favorites (add a copy to avoid mutation issues if needed)
            appState.favorites.push({ ...song });
            showSnackbar(`「${escapeHTML(song.title)}」をお気に入りに追加しました`);
        }

        saveToLocalStorage('reiKikuchiPlayerFavorites', appState.favorites);

        // 常に全てのリストを更新する（タブに関係なく）
        renderPlaylist();
        renderHistoryList();
        renderFavoritesList();
        
        // お気に入りボタンの表示を更新（全ての曲リストで）
        updateFavoriteButtons(songId);
        
        // Also update if the playlist detail modal is open showing this song
        if (elements.modals.playlistDetail.style.display === 'flex' && appState.currentSelectedPlaylist) {
            const playlist = appState.userPlaylists.find(p => p.id === appState.currentSelectedPlaylist);
            if (playlist && playlist.songs.includes(songId)) {
                 renderPlaylistDetail(playlist);
            }
        }
    }
    
    // お気に入りボタンの表示を更新する関数
    function updateFavoriteButtons(songId) {
        // 全てのお気に入りボタンを取得
        const favoriteButtons = document.querySelectorAll(`.favorite-btn[data-id="${songId}"]`);
        const isFavorite = appState.favorites.some(fav => fav.id === songId);
        
        // 各ボタンの表示を更新
        favoriteButtons.forEach(button => {
            const icon = button.querySelector('i');
            if (icon) {
                if (isFavorite) {
                    icon.classList.add('text-red-500');
                    icon.classList.remove('text-gray-400');
                    button.setAttribute('aria-label', 'お気に入り解除');
                } else {
                    icon.classList.remove('text-red-500');
                    icon.classList.add('text-gray-400');
                    button.setAttribute('aria-label', 'お気に入り登録');
                }
            }
        });
    }

    function saveUserPlaylists() {
      saveToLocalStorage('reiKikuchiPlayerPlaylists', appState.userPlaylists);
    }

     function saveToLocalStorage(key, data) {
         try {
             localStorage.setItem(key, JSON.stringify(data));
         } catch (error) {
             console.error("Error saving to localStorage:", key, error);
             showSnackbar("設定の保存中にエラーが発生しました。");
         }
     }

    // --- Modal Management ---
    let lastFocusedElement = null; // Store element focused before modal opens

    function showModal(modalId, elementToFocusInitially = null) {
      const modal = elements.modals[modalId];
      // modalが存在しないか、既に表示されている場合は何もしない
      if (!modal || modal.classList.contains('show')) {
        // 既に表示されている場合は、念のためフォーカスを設定し直す試み（オプション）
        if (modal && modal.classList.contains('show')) {
           const targetElement = elementToFocusInitially || modal.querySelector('button, [href], input:not([type="hidden"]), select, textarea, [tabindex]:not([tabindex="-1"])');
           setTimeout(() => (targetElement || modal)?.focus(), 50); // Re-focus attempt
        }
        return;
      }


      console.log("Showing modal:", modalId);
      lastFocusedElement = document.activeElement; // Store focus before modal opens

      modal.style.display = 'flex'; // Make it visible for transition
      // Force reflow before adding 'show' class to ensure transition works
      void modal.offsetWidth;
      modal.classList.add('show');
      appState.activeModalId = modalId;
      elements.body.style.overflow = 'hidden'; // Prevent background scroll

      // Focus trap setup
      // Find *visible* focusable elements
      const focusableElements = Array.from(
          modal.querySelectorAll('button, [href], input:not([type="hidden"]), select, textarea, [tabindex]:not([tabindex="-1"])')
      ).filter(el => el.offsetParent !== null && !el.disabled); // Filter for visible and enabled elements

      const firstFocusable = focusableElements[0];
      const lastFocusable = focusableElements[focusableElements.length - 1];

      // Add keydown listener for focus trapping and Escape key
      // Remove previous listener if any (safety check)
      if (modal._keyDownListener) {
          modal.removeEventListener('keydown', modal._keyDownListener);
      }
      modal._keyDownListener = (e) => handleModalKeyDown(e, firstFocusable, lastFocusable, modalId);
      modal.addEventListener('keydown', modal._keyDownListener);

      // Set initial focus after animation (usually first focusable or a specific element)
      setTimeout(() => {
          // Determine the target element for initial focus
          let targetElement = elementToFocusInitially;

          // If no specific element is provided, try finding one based on modalId convention
          if (!targetElement) {
              if (modalId === 'createPlaylist') targetElement = elements.playlistElements.nameInput;
              else if (modalId === 'account' && !appState.loggedInUser) targetElement = elements.accountFields.loginEmail;
              else if (modalId === 'account' && appState.loggedInUser) targetElement = elements.modalButtons.syncData;
              else if (modalId === 'share') targetElement = elements.modalButtons.copyLink;
              // Add more specific focus targets for other modals if needed
          }

          // Fallback to the first focusable element if no specific target found or provided
          if (!targetElement) {
              targetElement = firstFocusable;
          }

          // Finally, focus the target element or the modal itself as a last resort
          (targetElement || modal)?.focus();
          console.log("Attempted to focus:", targetElement || modal);

      }, 150); // Delay should be slightly longer than CSS transition duration
    }

     function hideModal(modalId) {
         const modal = elements.modals[modalId];
         if (modal && appState.activeModalId === modalId) { // Only hide if it's the active one
             modal.style.display = 'none';
             appState.activeModalId = null;

             // Remove the specific keydown listener for this modal
             if (modal.currentKeyDownListener) {
                 modal.removeEventListener('keydown', modal.currentKeyDownListener);
                 modal.currentKeyDownListener = null; // Clean up
             }

             // Restore focus to the element that had focus before the modal opened
             if (lastFocusedElement) {
                 lastFocusedElement.focus();
                 lastFocusedElement = null; // Reset
             }

             // Restore body scrolling only if no other modals are open
             const anyModalOpen = Object.values(elements.modals).some(m => m.style.display === 'flex');
             if (!anyModalOpen) {
                 document.body.style.overflow = '';
             }
             console.log("Modal hidden:", modalId);
             // Reset specific modal states if necessary (e.g., playlist detail selection)
             if (modalId === 'playlistDetail') {
                 appState.currentSelectedPlaylist = null;
             }
         }
     }

     function handleModalKeyDown(e, firstFocusable, lastFocusable, modalId) {
         if (e.key === 'Escape') {
             hideModal(modalId);
             return;
         }

         if (e.key === 'Tab') {
             // Focus trapping logic
             if (e.shiftKey) { // Shift + Tab
                 if (document.activeElement === firstFocusable) {
                     if (lastFocusable) lastFocusable.focus();
                     e.preventDefault();
                 }
             } else { // Tab
                 if (document.activeElement === lastFocusable) {
                     if (firstFocusable) firstFocusable.focus();
                     e.preventDefault();
                 }
             }
              // If there's only one focusable element, prevent tabbing away
             if (firstFocusable === lastFocusable && (document.activeElement === firstFocusable || document.activeElement === lastFocusable)) {
                e.preventDefault();
             }
         }
     }
     function hideModal(modalId) {
         const modal = elements.modals[modalId];
         // modalが存在しないか、既に非表示の場合は何もしない
         if (!modal || !modal.classList.contains('show')) return;

         console.log("Hiding modal:", modalId);
         modal.classList.remove('show'); // Start fade out transition
         appState.activeModalId = null;

         // Actions after transition completes
         setTimeout(() => {
             // Check if another modal hasn't been opened in the meantime
             if (appState.activeModalId === null) { // Ensure no other modal is now active
                modal.style.display = 'none'; // Actually hide it
                // Remove the specific keydown listener for this modal
                 if (modal._keyDownListener) {
                     modal.removeEventListener('keydown', modal._keyDownListener);
                     delete modal._keyDownListener; // Clean up property
                     console.log("Removed keydown listener for modal:", modalId);
                 }

                 // Restore focus only if no other modals are open
                 const anyModalOpen = Object.values(elements.modals).some(m => m?.classList.contains('show'));
                 if (!anyModalOpen) {
                     elements.body.style.overflow = ''; // Restore body scroll
                     if (lastFocusedElement && typeof lastFocusedElement.focus === 'function') {
                         console.log("Restoring focus to:", lastFocusedElement);
                         lastFocusedElement.focus();
                     }
                     lastFocusedElement = null;
                 } else {
                      console.log("Another modal is open, not restoring focus or body scroll yet.");
                 }
             } else {
                  // If another modal was opened quickly, just ensure this one is hidden
                  modal.style.display = 'none';
                   if (modal._keyDownListener) { // Still clean up listener
                       modal.removeEventListener('keydown', modal._keyDownListener);
                       delete modal._keyDownListener;
                   }
             }

             // Reset specific modal states if necessary
             if (modalId === 'playlistDetail') {
                 appState.currentSelectedPlaylistId = null;
                 elements.playlistElements.detailContent.innerHTML = '<div class="list-empty-message"><p>プレイリストを選択してください</p></div>'; // Reset content
             }
              if (modalId === 'share') {
                   elements.shareElements.linkInput.value = ''; // Clear share link
              }
              if (modalId === 'createPlaylist') {
                  elements.playlistElements.nameInput.value = ''; // Clear name input on close
              }

         }, 300); // Match CSS transition duration (0.3s)
     }


    // handleModalKeyDown 関数は変更なしでOK
     function handleModalKeyDown(e, firstFocusable, lastFocusable, modalId) {
         if (e.key === 'Escape') {
             hideModal(modalId);
             return;
         }

         // Trap focus only if there are focusable elements
         if (e.key === 'Tab' && firstFocusable) {
             if (e.shiftKey) { // Shift + Tab
                 // If focused on the first element, wrap to the last
                 if (document.activeElement === firstFocusable) {
                     lastFocusable?.focus();
                     e.preventDefault();
                 }
             } else { // Tab
                 // If focused on the last element, wrap to the first
                 if (document.activeElement === lastFocusable) {
                     firstFocusable?.focus();
                     e.preventDefault();
                 }
             }
              // Handle case with only one focusable element (prevent tabbing away)
             if (firstFocusable === lastFocusable && document.activeElement === firstFocusable) {
                  e.preventDefault();
             }
         }
     }


    // showCreatePlaylistModal 関数を修正 (setTimeout削除)
    function showCreatePlaylistModal() {
      if (!appState.loggedInUser) {
        showAccountModal(); // Prompt login
        showSnackbar('プレイリスト作成にはログインが必要です');
        return; // Important: Stop execution if not logged in
      }
      elements.playlistElements.nameInput.value = ''; // Clear input

      // showModalを呼び出し、フォーカスしたい要素を渡す
      showModal('createPlaylist', elements.playlistElements.nameInput);
    }
    // --- Snackbar ---
    function showSnackbar(message) {
        if (!elements.snackbar) return;
        elements.snackbar.textContent = message;

        // Clear existing timeout if snackbar is currently shown or fading out
        if (appState.snackbarTimeoutId) {
            clearTimeout(appState.snackbarTimeoutId);
            elements.snackbar.classList.remove('show'); // Reset animation state
        }

        // Force reflow to restart animation if needed
        void elements.snackbar.offsetWidth;

        // Show the snackbar
        elements.snackbar.classList.add('show');

        // Set timeout to hide it
        appState.snackbarTimeoutId = setTimeout(() => {
            elements.snackbar.classList.remove('show');
            appState.snackbarTimeoutId = null;
        }, 3000); // 3 seconds
    }

     // --- Global Keydown Handler ---
    function handleGlobalKeyDown(event) {
        // Ignore keydowns if focus is inside an input field, textarea, or select
        const activeElement = document.activeElement;
        const isInputFocused = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'SELECT');

         // Also ignore if a modal is active (modal handles its own keys like Esc/Tab)
        if (appState.activeModalId) {
            // Allow Escape key even if input is focused inside modal? Maybe not.
            return;
        }

        if (isInputFocused && event.key !== 'Escape') { // Allow Esc even from inputs? Maybe not needed.
            return; // Don't interfere with typing
        }

        switch (event.key) {
            case ' ': // Space bar
                event.preventDefault(); // Prevent page scroll
                togglePlayPause();
                break;
            case 'ArrowRight':
                event.preventDefault();
                 if (event.ctrlKey || event.metaKey) { // Seek forward with Ctrl/Cmd
                      seekRelative(SEEK_STEP);
                 } else {
                      playNextSong();
                 }
                break;
            case 'ArrowLeft':
                event.preventDefault();
                if (event.ctrlKey || event.metaKey) { // Seek backward with Ctrl/Cmd
                     seekRelative(-SEEK_STEP);
                } else {
                     playPreviousSong();
                }
                break;
            case 'ArrowUp':
                event.preventDefault();
                adjustVolume(VOLUME_STEP);
                break;
            case 'ArrowDown':
                event.preventDefault();
                adjustVolume(-VOLUME_STEP);
                break;
             case 'm': // Mute/Unmute toggle (example)
             case 'M':
                // TODO: Implement mute toggle if desired
                break;
            // Add more shortcuts if needed (e.g., 's' for shuffle, 'l' for loop)
        }
    }


    // --- Visualizer Drawing ---
    function drawVisualizer() {
        if (!appState.visualizer.canvasCtx || !appState.visualizer.dataArray) {
             appState.visualizer.animationFrameId = null; // Stop requesting frames if context is gone
             return;
        }

        // Request next frame
        appState.visualizer.animationFrameId = requestAnimationFrame(drawVisualizer);

        // Simulate audio data based on playing state
        const bufferLength = appState.visualizer.bufferLength;
        const dataArray = appState.visualizer.dataArray;
        const isPlaying = appState.isPlaying; // Use cached state

        for (let i = 0; i < bufferLength; i++) {
            if (isPlaying) {
                // More dynamic simulation: use sine wave + randomness for variation
                 const timeFactor = Date.now() * 0.005 + i * 0.1; // Slow moving wave
                 const randomFactor = Math.random() * 50;
                 const sineValue = (Math.sin(timeFactor) + 1) / 2; // Normalize to 0-1
                 dataArray[i] = Math.max(0, Math.min(255, (sineValue * 150) + randomFactor + 20)); // Base level + sine + randomness
            } else {
                 // Fade out effect when paused
                 dataArray[i] = Math.max(0, dataArray[i] * 0.95 - 1); // Decay quickly
            }
        }

        const canvas = appState.visualizer.canvas;
        const canvasCtx = appState.visualizer.canvasCtx;
        const width = canvas.width;
        const height = canvas.height;

        // Clear canvas
        canvasCtx.clearRect(0, 0, width, height);

        // Determine colors based on theme
        const isDarkMode = document.body.classList.contains('dark');
        const primaryColor = isDarkMode ? getComputedStyle(document.documentElement).getPropertyValue('--primary-color') : getComputedStyle(document.documentElement).getPropertyValue('--primary-color');
        const secondaryColor = isDarkMode ? getComputedStyle(document.documentElement).getPropertyValue('--secondary-color') : getComputedStyle(document.documentElement).getPropertyValue('--secondary-color');
        const backgroundColor = isDarkMode ? 'rgba(30, 30, 30, 0.1)' : 'rgba(245, 245, 245, 0.1)';

        // Optional background fill
        canvasCtx.fillStyle = backgroundColor;
        canvasCtx.fillRect(0, 0, width, height);

        // Create gradient for bars
        const gradient = canvasCtx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0, primaryColor);
        gradient.addColorStop(1, secondaryColor);
        canvasCtx.fillStyle = gradient;

        const barWidth = (width / bufferLength) * 1.5; // Slightly narrower bars
        let x = 0;

        for (let i = 0; i < bufferLength; i++) {
            const barHeight = (dataArray[i] / 255) * height * 0.8; // Max height 80% of canvas

             // Draw rounded bars (optional)
             const borderRadius = barWidth / 3;
             canvasCtx.beginPath();
             canvasCtx.moveTo(x + borderRadius, height);
             canvasCtx.lineTo(x + borderRadius, height - barHeight + borderRadius);
             canvasCtx.arcTo(x + borderRadius, height - barHeight, x + barWidth - borderRadius, height - barHeight, borderRadius); // Top-left to top-right arc
             canvasCtx.lineTo(x + barWidth - borderRadius, height - barHeight + borderRadius);
             canvasCtx.lineTo(x + barWidth - borderRadius, height);
             canvasCtx.closePath();
             canvasCtx.fill();


            // Simple rectangular bars:
            // canvasCtx.fillRect(x, height - barHeight, barWidth, barHeight);

            x += barWidth + 2; // Add spacing between bars
        }
    }


    // --- Canvas Resize ---
    function resizeCanvas() {
        if (!appState.visualizer.canvas) return;
        const canvas = appState.visualizer.canvas;
        const parent = canvas.parentElement;
        if (!parent) return;

        const rect = parent.getBoundingClientRect();
        // Check if dimensions actually changed to avoid unnecessary redraws
        if (canvas.width !== rect.width || canvas.height !== rect.height) {
            canvas.width = rect.width;
            canvas.height = rect.height;
            console.log("Resized visualizer canvas to:", canvas.width, canvas.height);
            // Visualizer will redraw on the next animation frame, no need to call draw explicitly
        }
    }

     // --- Highlight Active Song ---
     function updateActiveListItem() {
         const currentSongId = appState.currentSongIndex !== -1 ? appState.songs[appState.currentSongIndex]?.id : null;

         // Select all potential list item containers
         const listContainers = [
             elements.playlist,
             elements.historyList,
             elements.favoritesList,
             elements.playlistElements.detailContent // Playlist detail modal
         ];

         listContainers.forEach(container => {
             if (container) {
                 // Remove active class from all items within this container first
                 container.querySelectorAll('.active').forEach(item => item.classList.remove('active'));

                 // Add active class to the current song if it exists in this container
                 if (currentSongId) {
                     // Find item by data-id or data-index depending on the list type
                     let activeItem = container.querySelector(`[data-id="${currentSongId}"]`);
                     if (!activeItem && container === elements.playlist) {
                         // Playlist uses data-index based on filteredSongs
                         const filteredIndex = appState.filteredSongs.findIndex(song => song.id === currentSongId);
                         if (filteredIndex !== -1) {
                            activeItem = container.querySelector(`[data-index="${filteredIndex}"]`);
                         }
                     }

                     if (activeItem) {
                         activeItem.classList.add('active');
                         // Scroll into view if necessary and the list is currently visible
                          const tabContent = activeItem.closest('.tab-content');
                          const modalContent = activeItem.closest('.modal-content');
                          const isVisible = (tabContent && !tabContent.classList.contains('hidden')) || (modalContent && modalContent.closest('.modal')?.style.display === 'flex');

                         if (isVisible) {
                             activeItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                         }
                     }
                 }
             }
         });
     }

      // --- Handle URL Parameters ---
      function handleUrlParams() {
          const urlParams = new URLSearchParams(window.location.search);
          const sharedPlaylistId = urlParams.get('sharedPlaylistId');
          const songIdToPlay = urlParams.get('playSongId'); // Optional: direct link to play a song

          if (sharedPlaylistId) {
              // Find and display the shared playlist
              // Needs userPlaylists to be loaded first (happens in onPlayerReady)
              const playlist = appState.userPlaylists.find(p => p.id === sharedPlaylistId);
              if (playlist) {
                  showSnackbar(`共有されたプレイリスト「${escapeHTML(playlist.name)}」を表示します`);
                  viewPlaylist(sharedPlaylistId);
                  // Optionally switch to the "My Playlists" tab?
                  switchTab('user-playlists');
              } else {
                  // If playlists are user-specific and user isn't logged in, this might fail.
                  // Handle case where playlist isn't found (maybe it's public later?)
                  showSnackbar("共有されたプレイリストが見つかりませんでした。");
              }
              // Clear the param from URL? Optional. history.replaceState({}, '', window.location.pathname);
          } else if (songIdToPlay) {
               const originalIndex = appState.songs.findIndex(song => song && song.id === songIdToPlay);
               if (originalIndex !== -1) {
                   playSong(originalIndex);
                    showSnackbar(`共有された曲を再生します`);
               } else {
                   showSnackbar("共有された曲が見つかりませんでした。");
               }
               // Clear the param from URL? Optional. history.replaceState({}, '', window.location.pathname);
          }
      }

      // --- HTML Escaping Utility ---
      function escapeHTML(str) {
          if (!str) return '';
          return str.replace(/[&<>"']/g, function(match) {
              switch (match) {
                  case '&': return '&';
                  case '<': return '<';
                  case '>': return '>';
                  case '"': return '"';
                  case "'": return "'"; // Escape single quote
                  default: return match;
              }
          });
      }


    // Let the YouTube API load and call onYouTubeIframeAPIReady automatically
    console.log("Player script initialized. Waiting for YouTube API...");

    // YouTube API関連の機能
    const youtubeAPI = {
      // APIキー（実際の使用時には自分のAPIキーに置き換える必要があります）
      apiKey: 'AIzaSyCbzvjP9vFa5I8N1qLI5H9LUpYim0nkQS4',
      
      // チャンネルID
      channelId: 'UCYAuSEKhuk3v4ZKzm5Lqb1Q',
      
      // 最新の動画を取得する関数
      async getLatestVideos() {
  try {
    // チャンネル情報取得
    const channelResponse = await fetch(
      `https://www.googleapis.com/youtube/v3/channels?part=contentDetails&id=${this.channelId}&key=${this.apiKey}`
    );
    if (!channelResponse.ok) {
      throw new Error('チャンネル情報の取得に失敗しました');
    }
    const channelData = await channelResponse.json();
    if (!channelData.items || channelData.items.length === 0) {
      throw new Error('チャンネルが見つかりません');
    }
    const uploadsPlaylistId = channelData.items[0].contentDetails.relatedPlaylists.uploads;

    // ページネーションで全動画を取得（最大5ページ）
    let videos = [];
    let nextPageToken = '';
    let pageCount = 0;
    const maxPages = 5;
    do {
      let url = `https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&maxResults=50&playlistId=${uploadsPlaylistId}&key=${this.apiKey}`;
      if (nextPageToken) {
        url += `&pageToken=${nextPageToken}`;
      }
      const playlistResponse = await fetch(url);
      if (!playlistResponse.ok) {
        throw new Error('プレイリスト情報の取得に失敗しました');
      }
      const playlistData = await playlistResponse.json();
      if (playlistData.items) {
        videos.push(...playlistData.items);
      }
      nextPageToken = playlistData.nextPageToken;
      pageCount++;
      if (pageCount >= maxPages) {
        console.log(`最大ページ数 ${maxPages} に達しました。`);
        break;
      }
    } while (nextPageToken);

    // 必要な情報だけを抽出（duration は空にしておく）
    return videos.map(item => {
      const snippet = item.snippet;
      return {
        id: snippet.resourceId.videoId,
        title: snippet.title,
        description: snippet.description,
        thumbnail: snippet.thumbnails.high.url,
        publishedAt: snippet.publishedAt,
        duration: null  // duration は後で上書きする
      };
    });
  } catch (error) {
    console.error('YouTube APIエラー:', error);
    showSnackbar('YouTube動画の取得に失敗しました');
    return [];
  }
}
,
      
      // 動画の詳細情報を取得する関数（長さなど）
      async getVideoDetails(videoIds) {
        if (!videoIds || videoIds.length === 0) return [];
        
        try {
          const response = await fetch(
            `https://www.googleapis.com/youtube/v3/videos?part=contentDetails,statistics&id=${videoIds.join(',')}&key=${this.apiKey}`
          );
          
          if (!response.ok) {
            throw new Error('動画詳細の取得に失敗しました');
          }
          
          const data = await response.json();
          
          if (!data.items || data.items.length === 0) {
            return [];
          }
          
          return data.items.map(item => {
            // ISO 8601形式の期間を分:秒形式に変換
            const duration = this.convertDuration(item.contentDetails.duration);
            
            return {
              id: item.id,
              duration: duration,
              viewCount: item.statistics.viewCount
            };
          });
        } catch (error) {
          console.error('YouTube APIエラー (動画詳細):', error);
          return [];
        }
      },
      
      // ISO 8601形式の期間を分:秒形式に変換する関数
      convertDuration(isoDuration) {
        const match = isoDuration.match(/PT(\d+H)?(\d+M)?(\d+S)?/);
        
        const hours = (match[1] && match[1].replace('H', '')) || 0;
        const minutes = (match[2] && match[2].replace('M', '')) || 0;
        const seconds = (match[3] && match[3].replace('S', '')) || 0;
        
        let result = '';
        
        if (hours > 0) {
          result += `${hours}:`;
          result += `${minutes.toString().padStart(2, '0')}:`;
        } else {
          result += `${minutes}:`;
        }
        
        result += seconds.toString().padStart(2, '0');
        
        return result;
      },
      
      // 新しい曲をプレイリストに追加する関数
      async updatePlaylist() {
        try {
          showSnackbar('YouTubeから最新の曲を取得中...');
          
          // 最新の動画を取得
          const latestVideos = await this.getLatestVideos(15); // 最新15件を取得
          
          if (latestVideos.length === 0) {
            showSnackbar('新しい曲は見つかりませんでした');
            return;
          }
          
          // 動画IDのリストを作成
          const videoIds = latestVideos.map(video => video.id);
          
          // 動画の詳細情報を取得
          const videoDetails = await this.getVideoDetails(videoIds);
          
          // 詳細情報を結合
          const videosWithDetails = latestVideos.map(video => {
            const details = videoDetails.find(detail => detail.id === video.id) || {};
            return {
              ...video,
              duration: details.duration || video.duration
            };
          });
          
          // 既存の曲リストと比較して新しい曲だけを追加
          const newSongs = videosWithDetails.filter(video => 
            !appState.songs.some(song => song.id === video.id)
          );
          
          if (newSongs.length === 0) {
            showSnackbar('新しい曲は見つかりませんでした');
            return;
          }
          
          // 新しい曲をプレイリストに追加
          newSongs.forEach(video => {
            appState.songs.unshift({
              id: video.id,
              title: video.title,
              duration: video.duration,
              thumbnail: video.thumbnail
            });
          });
          
          // フィルタリングされた曲リストも更新
          appState.filteredSongs = [...appState.songs];
          
          // UIを更新
          renderPlaylist();
          
          showSnackbar(`${newSongs.length}曲の新しい曲を追加しました`);
        } catch (error) {
          console.error('プレイリスト更新エラー:', error);
          showSnackbar('プレイリストの更新に失敗しました');
        }
      },
      
      // 定期的に新曲をチェックする関数
      startAutoSync(intervalMinutes = 60) {
        // 初回実行
        this.updatePlaylist();
        
        // 定期的に実行（デフォルトは1時間ごと）
        const intervalId = setInterval(() => {
          this.updatePlaylist();
        }, intervalMinutes * 60 * 1000);
        
        // intervalIdを返して、必要に応じて停止できるようにする
        return intervalId;
      }
    };

    // 同期ボタンを追加する関数
    function setupYouTubeSync() {
      // 同期ボタンを追加
      const syncButton = document.createElement('button');
      syncButton.id = 'youtube-sync-btn';
      syncButton.className = 'px-3 py-1 rounded-md text-sm';
      syncButton.style.backgroundColor = 'var(--primary-color)';
      syncButton.style.color = 'white';
      syncButton.innerHTML = '<i class="fab fa-youtube mr-1"></i> 新曲を同期';
      
      // ボタンを適切な場所に追加
      const buttonContainer = document.querySelector('.flex.justify-end.mb-2.gap-2');
      if (buttonContainer) {
        buttonContainer.prepend(syncButton);
        
        // クリックイベントを追加
        syncButton.addEventListener('click', () => {
          youtubeAPI.updatePlaylist();
        });
      }
      
      // 自動同期を開始（1時間ごと）
      youtubeAPI.startAutoSync(60);
    }

    // オフライン再生機能のためのスクリプト
    const offlinePlayback = {
      // Service Workerの登録
      registerServiceWorker: async function() {
        if ('serviceWorker' in navigator) {
          try {
            const registration = await navigator.serviceWorker.register('/service-worker.js');
            console.log('Service Worker 登録成功:', registration.scope);
            return registration;
          } catch (error) {
            console.error('Service Worker 登録失敗:', error);
            return null;
          }
        } else {
          console.warn('Service Worker はこのブラウザでサポートされていません');
          return null;
        }
      },

      // オフラインステータスの監視
      setupOfflineDetection: function() {
        const updateOfflineStatus = () => {
          const isOffline = !navigator.onLine;
          document.body.classList.toggle('offline-mode', isOffline);
          
          // オフラインステータスを表示
          const statusElement = document.getElementById('offline-status');
          if (!statusElement) {
            const statusDiv = document.createElement('div');
            statusDiv.id = 'offline-status';
            statusDiv.className = 'fixed top-0 left-0 right-0 p-2 text-center text-white bg-red-600 transform transition-transform duration-300';
            statusDiv.style.zIndex = '9999';
            statusDiv.style.transform = isOffline ? 'translateY(0)' : 'translateY(-100%)';
            statusDiv.textContent = 'オフラインモード - インターネット接続がありません';
            document.body.appendChild(statusDiv);
          } else {
            statusElement.style.transform = isOffline ? 'translateY(0)' : 'translateY(-100%)';
          }
          
          if (isOffline) {
            showSnackbar('オフラインモードに切り替わりました。キャッシュされた曲のみ再生できます。');
          } else {
            showSnackbar('オンラインに戻りました。すべての機能が利用可能です。');
          }
        };
        
        // 初期状態の設定
        updateOfflineStatus();
        
        // オンライン/オフライン状態の変化を監視
        window.addEventListener('online', updateOfflineStatus);
        window.addEventListener('offline', updateOfflineStatus);
        
        return updateOfflineStatus;
      },

      // 現在の曲をキャッシュに追加
      cacheCurrentSong: function() {
        if (!navigator.serviceWorker.controller) return;
        
        const currentSongIndex = appState.currentSongIndex;
        if (currentSongIndex === -1) return;
        
        const currentSong = appState.songs[currentSongIndex];
        if (!currentSong || !currentSong.id) return;
        
        // YouTube動画IDからサムネイル画像URLを取得してキャッシュ
        const thumbnailUrl = `https://i.ytimg.com/vi/${currentSong.id}/hqdefault.jpg`;
        
        // Service Workerにキャッシュするよう指示
        navigator.serviceWorker.controller.postMessage({
          type: 'CACHE_MUSIC',
          url: thumbnailUrl
        });
        
        console.log('現在の曲をキャッシュに追加:', currentSong.title);
      },

      // お気に入りの曲をすべてキャッシュ
      cacheFavoriteSongs: function() {
        if (!navigator.serviceWorker.controller) return;
        
        appState.favorites.forEach(songId => {
          const song = appState.songs.find(s => s.id === songId);
          if (song) {
            const thumbnailUrl = `https://i.ytimg.com/vi/${song.id}/hqdefault.jpg`;
            
            navigator.serviceWorker.controller.postMessage({
              type: 'CACHE_MUSIC',
              url: thumbnailUrl
            });
            
            console.log('お気に入りの曲をキャッシュに追加:', song.title);
          }
        });
        
        showSnackbar(`${appState.favorites.length}曲のお気に入りをオフライン再生用にキャッシュしました`);
      },

      // オフラインモード用のUIを追加
      addOfflineUI: function() {
        // オフラインモード切替ボタンを追加
        const headerControls = document.querySelector('.flex.items-center.gap-4');
        if (headerControls) {
          const offlineBtn = document.createElement('button');
          offlineBtn.id = 'offline-mode-btn';
          offlineBtn.className = 'btn-mode';
          offlineBtn.setAttribute('aria-label', 'オフラインモード');
          offlineBtn.innerHTML = '<i class="fas fa-cloud-download-alt"></i>';
          
          headerControls.appendChild(offlineBtn);
          
          // クリックイベントを追加
          offlineBtn.addEventListener('click', () => {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.id = 'offline-modal';
            modal.innerHTML = `
              <div class="modal-content p-6 max-w-md">
                <div class="flex justify-between items-center mb-4">
                  <h2 class="text-xl font-bold">オフライン再生</h2>
                  <button class="modal-close text-2xl">&times;</button>
                </div>
                <p class="mb-4">オフライン再生のために曲をキャッシュします。キャッシュした曲はインターネット接続がなくても再生できます。</p>
                <div class="flex flex-col gap-3">
                  <button id="cache-current-btn" class="btn-primary py-2 px-4 rounded">
                    <i class="fas fa-music mr-2"></i>現在の曲をキャッシュ
                  </button>
                  <button id="cache-favorites-btn" class="btn-primary py-2 px-4 rounded">
                    <i class="fas fa-heart mr-2"></i>お気に入りをすべてキャッシュ
                  </button>
                  <button id="clear-cache-btn" class="btn-secondary py-2 px-4 rounded">
                    <i class="fas fa-trash mr-2"></i>キャッシュをクリア
                  </button>
                </div>
              </div>
            `;
            
            document.body.appendChild(modal);
            
            // モーダルを表示
            setTimeout(() => {
              modal.style.display = 'flex';
            }, 10);
            
            // 閉じるボタンのイベント
            modal.querySelector('.modal-close').addEventListener('click', () => {
              modal.style.display = 'none';
              setTimeout(() => {
                modal.remove();
              }, 300);
            });
            
            // 現在の曲をキャッシュするボタン
            modal.querySelector('#cache-current-btn').addEventListener('click', () => {
              this.cacheCurrentSong();
            });
            
            // お気に入りをキャッシュするボタン
            modal.querySelector('#cache-favorites-btn').addEventListener('click', () => {
              this.cacheFavoriteSongs();
            });
            
            // キャッシュをクリアするボタン
            modal.querySelector('#clear-cache-btn').addEventListener('click', async () => {
              if ('caches' in window) {
                try {
                  const cacheNames = await caches.keys();
                  await Promise.all(
                    cacheNames.map(cacheName => caches.delete(cacheName))
                  );
                  showSnackbar('キャッシュをクリアしました');
                } catch (error) {
                  console.error('キャッシュのクリアに失敗しました:', error);
                  showSnackbar('キャッシュのクリアに失敗しました');
                }
              }
            });
          });
        }
      },

      // 初期化
      init: async function() {
        // Service Workerを登録
        await this.registerServiceWorker();
        
        // オフライン検出を設定
        this.setupOfflineDetection();
        
        // オフラインモード用のUIを追加
        this.addOfflineUI();
        
        console.log('オフライン再生機能が初期化されました');
      }
    };
    document.addEventListener('DOMContentLoaded', function() {
        console.log("DOM fully loaded and parsed.");
        // Check if YouTube API might already be ready (rare case)
        if (typeof YT !== 'undefined' && YT.Player) {
            console.log("YT API was ready before DOMContentLoaded listener.");
            // You might need to manually trigger the player setup if onYouTubeIframeAPIReady didn't fire
            // This scenario is less likely if the script tag is at the end.
        }
        // Set initial viewport height
        setCorrectViewportHeight();
    });

    // ページ読み込み完了時に実行
    document.addEventListener('DOMContentLoaded', function() {
      // 既存の初期化コードの後に追加
      if (typeof onPlayerReady === 'function') {
        const originalOnPlayerReady = onPlayerReady;
        onPlayerReady = function(event) {
          originalOnPlayerReady(event);
          setupYouTubeSync();
          offlinePlayback.init();
        };
      } else {
        // onPlayerReadyが定義されていない場合は直接実行
        window.addEventListener('load', () => {
          setupYouTubeSync();
          offlinePlayback.init();
        });
      }
    });
    document.addEventListener('DOMContentLoaded', function() {
  const loginBtn = document.getElementById('login-btn');
  if (loginBtn) {
    loginBtn.addEventListener('click', () => {
      console.log("直接設定：ログインボタンがクリックされました");
      handleLogin();
    });
  } else {
    console.error("login-btn が見つかりません");
  }
});

  </script>
</body>

</html>

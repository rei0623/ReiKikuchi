<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" >
  <title>Rei Kikuchi Premium Music Player</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary-color: #8e24aa;
      --secondary-color: #5e35b1;
      --accent-color: #d81b60;
      --text-color: #333;
      --background-color: #f5f5f5;
      --card-color: #fff;
      --border-color: #e0e0e0;
      --vh: 1vh; /* モバイルのビューポート高さ補正用 */
    }

    .dark {
      --primary-color: #bb86fc;
      --secondary-color: #7c4dff;
      --accent-color: #cf6679;
      --text-color: #e0e0e0;
      --background-color: #121212;
      --card-color: #1e1e1e;
      --border-color: #333;
    }

    /* オフラインモード用のスタイル */
    .offline-mode .online-only {
      opacity: 0.5;
      pointer-events: none;
    }

    #offline-status {
      z-index: 9999;
    }

    .offline-badge {
      position: absolute;
      top: 0;
      right: 0;
      background-color: var(--accent-color);
      color: white;
      font-size: 0.6rem;
      padding: 2px 4px;
      border-radius: 4px;
      transform: translate(50%, -50%);
    }

    body {
      font-family: 'Poppins', sans-serif;
      transition: background-color 0.3s ease, color 0.3s ease;
      background-color: var(--background-color);
      color: var(--text-color);
      display: flex; /* Flexboxでレイアウト */
      flex-direction: column;
      /* min-height: 100vh; -> height: 100% に変更 */
      height: calc(var(--vh, 1vh) * 100); /* モバイルでの高さ問題を修正 */
    }

    /* UI/UX改善用のスタイル追加 */
    .song-item {
      transition: transform 0.2s ease, background-color 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .song-item:hover {
      transform: translateY(-2px);
      background-color: rgba(142, 36, 170, 0.05);
    }

    .song-item::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 0;
      height: 2px;
      background-color: var(--primary-color);
      transition: width 0.3s ease;
    }

    .song-item:hover::after {
      width: 100%;
    }

    .song-item.active {
      background-color: rgba(142, 36, 170, 0.1);
      border-left: 3px solid var(--primary-color);
    }

    .btn-mode, .btn-control {
      transition: transform 0.2s ease, opacity 0.2s ease;
    }

    .btn-mode:hover, .btn-control:hover {
      transform: scale(1.1);
    }

    .btn-mode:active, .btn-control:active {
      transform: scale(0.95);
    }

    .tab-button {
      position: relative;
      overflow: hidden;
    }

    .tab-button::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      width: 0;
      height: 2px;
      background-color: var(--primary-color);
      transition: width 0.3s ease, left 0.3s ease;
    }

    .tab-button:hover::after {
      width: 100%;
      left: 0;
    }

    .tab-button.active::after {
      width: 100%;
      left: 0;
    }

    /* スマホ向け最適化 */
    @media (max-width: 640px) {
      .song-controls {
        flex-direction: column;
        gap: 0.5rem;
      }

      .player-controls {
        flex-wrap: wrap;
        justify-content: center;
      }

      .volume-control {
        width: 100%;
        margin-top: 0.5rem;
      }

      .song-item {
        padding: 0.75rem;
      }

      .song-title {
        font-size: 0.9rem;
      }

      .song-duration {
        font-size: 0.8rem;
      }

      /* タッチ操作の最適化 */
      .btn-mode, .btn-control, .tab-button, .song-item, .heart-btn {
        min-height: 44px; /* タッチターゲットの最小サイズ */
      }

      /* スマホでのスクロールを滑らかに */
      .playlist-container {
        -webkit-overflow-scrolling: touch;
      }
    }

    /* アニメーション効果 */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideUp {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .fade-in {
      animation: fadeIn 0.5s ease forwards;
    }

    .slide-up {
      animation: slideUp 0.5s ease forwards;
    }

    .pulse {
      animation: pulse 1s infinite;
    }

    /* プレイヤーコントロールの改善 */
    .player-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      margin: 1rem 0;
    }

    .progress-container {
      position: relative;
      height: 6px;
      background-color: var(--border-color);
      border-radius: 3px;
      cursor: pointer;
      overflow: hidden;
      /* トラックの高さを増やし、色を調整 */
      background-color: rgba(0, 0, 0, 0.1);
      transition: background-color 0.3s ease;
      /* タップ領域を明確にするために上下パディングを追加 */
      padding: 8px 0;
      margin: -8px 0;
    }

    .progress-bar {
      height: 100%;
      background-color: var(--primary-color);
      border-radius: 3px;
      transition: width 0.1s linear;
      /* 再生済み部分の色を濃く・鮮やかに */
      background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
      width: 0%;
      position: relative;
    }

    .progress-thumb {
      position: absolute;
      top: 50%;
      width: 12px;
      height: 12px;
      background-color: var(--primary-color);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
      transition: transform 0.2s ease;
    }

    .progress-container:hover .progress-thumb {
      transform: translate(-50%, -50%) scale(1.2);
    }

    /* ローディングインジケーター */
    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid rgba(142, 36, 170, 0.3);
      border-radius: 50%;
      border-top-color: var(--primary-color);
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* スナックバーの改善 */
    .snackbar {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: var(--card-color);
      color: var(--text-color);
      padding: 12px 24px;
      border-radius: 4px;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
      z-index: 1001; /* Increased z-index */
      font-size: 0.9rem;
      opacity: 0;
      transition: opacity 0.3s ease-out, transform 0.3s ease-out, bottom 0.3s ease-out; /* Added bottom transition */
      border-left: 4px solid var(--primary-color);
      pointer-events: none; /* Prevents interaction when hidden */
      text-align: center;
      max-width: 90%;
      /* Ensure it's above mobile bottom controls */
      margin-bottom: calc(env(safe-area-inset-bottom, 0px) + 10px); /* Adjust for safe area + margin */
    }

    .snackbar.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
      bottom: 20px; /* Base position */
      pointer-events: auto; /* Allow interaction when shown */
    }

    /* モーダルの改善 */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease;
      padding: 15px; /* Add padding for mobile view */
    }

    .modal.show {
      opacity: 1;
      display: flex;
    }

    .modal-content {
      background-color: var(--card-color);
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      max-width: 90%;
      max-height: 90%; /* Adjusted from 85vh to 90% for flexibility */
      overflow: auto; /* Changed from overflow-y to auto */
      transform: scale(0.9);
      transition: transform 0.3s ease, background-color 0.3s ease; /* Added background transition */
      width: 100%; /* Use padding on modal for spacing */
      padding: 20px; /* Standard padding */
      position: relative; /* Needed for absolute positioned close button */
      -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
    }

    .modal.show .modal-content {
      transform: scale(1);
    }

    /* スクロールバーのカスタマイズ */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--background-color);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--primary-color);
    }

    /* フォーカス状態の改善 */
    button:focus, input:focus, a:focus, [tabindex]:focus { /* Applied to more focusable elements */
      outline: 2px solid var(--primary-color);
      outline-offset: 2px;
      box-shadow: 0 0 0 3px rgba(142, 36, 170, 0.3); /* Added subtle shadow for better visibility */
    }

    /* キーボードナビゲーション用 (merged with button:focus style) */
    .focusable:focus { /* Use a class for explicit focusable items if needed */
        outline: 2px solid var(--primary-color);
        outline-offset: 2px;
        box-shadow: 0 0 0 3px rgba(142, 36, 170, 0.3);
    }


    /* アクセシビリティ改善 */
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .app-container {
      max-width: 1280px;
      margin: 0 auto;
      /* padding: 20px; -> スマホでは0に */
      width: 100%;
      flex-grow: 1; /* コンテンツエリアを伸ばす */
      display: flex;
      flex-direction: column;
    }

    .app-container > header {
        padding: 10px 15px; /* スマホ用のヘッダーパディング */
        flex-shrink: 0;
    }

    .music-player {
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      background-color: var(--card-color);
      transition: background-color 0.3s ease, box-shadow 0.3s ease;
      flex-grow: 1; /* プレイヤー部分が残りの高さを取る */
      display: flex;
      flex-direction: column;
      padding: 0; /* スマホでは不要 */
    }
/* PCでのスタイルを維持 */
@media (min-width: 1024px) {
      .music-player {
         padding: 1.5rem; /* 24px */
      }
      .app-container > header {
          padding: 0 20px; /* PCでは元のpadding */
      }
    }


    /* Gridレイアウト (PC/Tablet) */
    .music-player-grid {
        display: grid;
        grid-template-columns: 1fr; /* Mobile default */
        gap: 1.5rem; /* 24px */
        flex-grow: 1;
        overflow: hidden; /* Prevent grid itself from scrolling */
    }

    @media (min-width: 1024px) { /* lg breakpoint */
        .music-player-grid {
            grid-template-columns: repeat(3, minmax(0, 1fr));
        }
        .player-main-column {
            grid-column: span 2 / span 2;
        }
        .playlist-column {
            grid-column: span 1 / span 1;
            display: flex;
            flex-direction: column;
        }
    }

    .playlist, .history-list, .favorites-list, .user-playlists-list, .playlist-detail-list {
      max-height: 400px; /* Default max height for desktop */
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--primary-color) var(--background-color);
      -webkit-overflow-scrolling: touch; /* iOSでのスムーズスクロール */
    }

    .playlist::-webkit-scrollbar,
    .history-list::-webkit-scrollbar,
    .favorites-list::-webkit-scrollbar,
    .user-playlists-list::-webkit-scrollbar,
    .playlist-detail-list::-webkit-scrollbar {
      width: 6px;
    }

    .playlist::-webkit-scrollbar-track,
    .history-list::-webkit-scrollbar-track,
    .favorites-list::-webkit-scrollbar-track,
    .user-playlists-list::-webkit-scrollbar-track,
    .playlist-detail-list::-webkit-scrollbar-track {
      background: var(--background-color);
    }

    .playlist::-webkit-scrollbar-thumb,
    .history-list::-webkit-scrollbar-thumb,
    .favorites-list::-webkit-scrollbar-thumb,
    .user-playlists-list::-webkit-scrollbar-thumb,
    .playlist-detail-list::-webkit-scrollbar-thumb {
      background-color: var(--primary-color);
      border-radius: 6px;
    }

    .playlist-item, .history-item, .favorite-item {
      transition: all 0.2s ease;
      border-left: 3px solid transparent;
    }

    .playlist-item:hover, .history-item:hover, .favorite-item:hover {
      background-color: rgba(142, 36, 170, 0.1);
    }

    .dark .playlist-item:hover, .dark .history-item:hover, .dark .favorite-item:hover {
       background-color: rgba(187, 134, 252, 0.1);
    }

    .playlist-item.active, .history-item.active, .favorite-item.active {
      border-left: 3px solid var(--primary-color);
      background-color: rgba(142, 36, 170, 0.2);
    }

     .dark .playlist-item.active, .dark .history-item.active, .dark .favorite-item.active {
       background-color: rgba(187, 134, 252, 0.2);
     }

    .player-controls button {
      transition: all 0.2s ease;
    }

    .player-controls button:hover {
      transform: scale(1.1);
    }

    /* Progress Bar Improved Styles */
    /* ホバー時のスタイル */
    .progress-container:hover {
        height: 8px; /* Slightly thicker on hover */
        background-color: rgba(0, 0, 0, 0.15);
    }
     /* つまみ */
     .progress-bar::after {
        content: '';
        position: absolute;
        right: 0;
        top: 50%;
        transform: translate(50%, -50%) scale(0); /* 初期状態は非表示 */
        width: 16px;
        height: 16px;
        background: white;
        border: 2px solid var(--primary-color);
        border-radius: 50%;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        transition: transform 0.2s ease;
        z-index: 2;
     }

     /* ホバー時やアクティブ時に表示 (PC) */
     .progress-container:hover .progress-bar::after,
     .progress-container:active .progress-bar::after {
        transform: translate(50%, -50%) scale(1);
     }

     /* Show thumb if progress is > 0 */
     .progress-bar:not([style*="width: 0%"])::after {
        transform: translate(50%, -50%) scale(1);
     }
     /* Fix for very small percentage values triggering the style rule */
     .progress-bar[style*="width: 0."]::after {
         transform: translate(50%, -50%) scale(1);
     }


     .dark .progress-container {
        background-color: rgba(255, 255, 255, 0.1);
     }

     .dark .progress-bar {
        box-shadow: 0 0 8px rgba(187, 134, 252, 0.3); /* Subtle glow in dark mode */
     }

     .dark .progress-bar::after {
        background: var(--background-color); /* Dark background for thumb */
        border-color: var(--primary-color);
     }

   /* 音量スライダーもタップしやすく */
   .volume-control input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 8px; /* 少し太く */
      background: var(--border-color);
      border-radius: 8px;
      outline: none;
      transition: background 0.3s ease;
      padding: 5px 0; /* 上下のタップ領域 */
      margin: -5px 0; /* パディング相殺 */
    }
     /* Style for the track */
    .volume-control input[type="range"]::-webkit-slider-runnable-track {
        height: 8px;
        background: var(--border-color);
        border-radius: 8px;
    }
    .volume-control input[type="range"]::-moz-range-track {
        height: 8px;
        background: var(--border-color);
        border-radius: 8px;
    }
     /* Style for the thumb */
    .volume-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px; /* 少し大きく */
      height: 18px;
      background: var(--primary-color);
      border-radius: 50%;
      cursor: pointer;
      margin-top: -5px; /* Center thumb vertically */
       transition: background 0.3s ease;
    }
    .volume-control input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        background: var(--primary-color);
        border-radius: 50%;
        cursor: pointer;
        border: none;
         transition: background 0.3s ease;
    }


    .btn-mode {
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }

    .btn-active {
      color: white;
      background-color: var(--primary-color);
    }
     .dark .btn-active {
        color: var(--background-color); /* Ensure contrast in dark mode */
        background-color: var(--primary-color);
     }

    .btn-inactive {
      color: var(--text-color);
      background-color: var(--border-color);
    }

    .search-container {
      position: relative;
    }

    .search-input {
      padding-left: 40px;
      background-color: var(--card-color);
      border: 1px solid var(--border-color);
      color: var(--text-color);
       transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }

    .search-icon {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-color);
      transition: color 0.3s ease;
    }

    .tabs {
      display: flex;
      border-bottom: 1px solid var(--border-color);
      margin-bottom: 16px;
      flex-wrap: wrap;
       transition: border-color 0.3s ease;
       flex-shrink: 0; /* タブ自体は縮まない */
    }

    .tab {
      padding: 10px 15px; /* 少し調整 */
      cursor: pointer;
      transition: all 0.3s ease;
      border-bottom: 2px solid transparent;
      text-align: center;
      flex-grow: 1; /* タブを均等配置 */
      font-size: 0.9rem;
    }
     @media (min-width: 640px) { /* PCでは元の設定に戻す */
         .tab {
             flex-grow: 0;
             padding: 10px 20px;
             font-size: 1rem;
         }
         .tabs {
             flex-wrap: nowrap;
         }
     }

     .tab.active {
      color: var(--primary-color);
      border-bottom: 2px solid var(--primary-color);
      font-weight: 600;
    }
    .tab-content {
       /* height: 100%; */ /* Will be handled by flex-grow on parent */
       overflow-y: auto;
       -webkit-overflow-scrolling: touch;
       flex-grow: 1; /* Make tab content take remaining space */
       /* Define a class for scrollable area *inside* tab content */
    }
    .scrollable-list-area {
        /* Default height for desktop/larger screens if needed */
        max-height: 400px;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
    }

    .visualizer-container {
      height: 60px; /* スマホでは少し小さく */
      background-color: rgba(0, 0, 0, 0.05);
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      transition: background-color 0.3s ease;
    }
     @media (min-width: 1024px) {
         .visualizer-container {
            height: 100px; /* PCでは元の高さ */
         }
     }


    .dark .visualizer-container {
      background-color: rgba(255, 255, 255, 0.05);
    }

    canvas#visualizer { /* Specificity added */
      width: 100%;
      height: 100%;
      display: block; /* Remove potential extra space */
    }

    .youtube-container {
      position: relative;
      padding-bottom: 56.25%; /* 16:9 Aspect Ratio */
      height: 0;
      overflow: hidden;
      border-radius: 12px; /* Apply border radius */
      background-color: #000; /* Black background for loading */
      margin-bottom: 10px; /* Add some space below video */
    }

    .youtube-container iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .badge {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: var(--accent-color);
      color: white;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.75rem;
      z-index: 10;
    }

    .modal-close-btn {
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 1.8rem; /* Larger tap target */
      line-height: 1;
      background: none;
      border: none;
      cursor: pointer;
      color: var(--text-color);
      padding: 8px; /* Larger tap target */
      margin: -8px; /* Offset padding */
       transition: color 0.3s ease;
    }
     .modal-close-btn:hover {
         color: var(--accent-color);
     }

     /* Adjust snackbar position if bottom controls are visible */
     body.has-bottom-controls .snackbar {
        margin-bottom: calc(env(safe-area-inset-bottom, 0px) + 70px + 10px); /* Controls height + margin */
     }

    @media print {
      .scrollable-list-area {
        max-height: none;
        overflow: visible;
      }
    }


    /* Custom Playlist Styles */
    .user-playlist-item {
      padding: 10px;
      border-radius: 6px;
      margin-bottom: 5px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background-color: rgba(142, 36, 170, 0.05);
      transition: background-color 0.2s ease;
    }

    .user-playlist-item:hover {
      background-color: rgba(142, 36, 170, 0.15);
    }
     .dark .user-playlist-item {
         background-color: rgba(187, 134, 252, 0.1);
     }
     .dark .user-playlist-item:hover {
         background-color: rgba(187, 134, 252, 0.2);
     }

    .user-playlist-actions {
      display: flex;
      gap: 10px;
    }
    .playlist-count {
      padding: 2px 8px;
      background-color: var(--primary-color);
      color: white;
      border-radius: 10px;
      font-size: 0.75rem;
      margin-left: 8px;
       transition: background-color 0.3s ease;
    }
     .dark .playlist-count {
         color: var(--background-color);
     }

     /* Dropdown Styling */
     .dropdown { /* Add styling to the dropdown container */
         position: relative;
         display: inline-block;
     }
     .dropdown-menu {
        background-color: var(--card-color);
        border: 1px solid var(--border-color);
        transition: background-color 0.3s ease, border-color 0.3s ease;
        position: absolute; /* Position relative to .dropdown */
        right: 0;
        margin-top: 0.5rem; /* 8px */
        width: 12rem; /* 192px */
        border-radius: 0.375rem; /* 6px */
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        z-index: 20; /* Ensure it's above list items */
        /* Add max-height and overflow for scrollable dropdown */
        max-height: 8rem; /* 128px or adjust as needed */
        overflow-y: auto;
    }
    .dropdown-menu a { /* Style links inside dropdown */
        display: block;
        padding: 0.5rem 1rem; /* 8px 16px */
        font-size: 0.875rem; /* 14px */
        white-space: nowrap; /* Prevent wrapping */
    }
    .dropdown-menu a:hover {
       background-color: rgba(142, 36, 170, 0.1);
    }
     .dark .dropdown-menu a:hover {
        background-color: rgba(187, 134, 252, 0.15);
     }


    /* --- Mobile Specific Adjustments --- */
    @media (max-width: 1023px) { /* Below lg breakpoint */
      .app-container {
         padding: 0;
      }
       .app-container > header {
           /* Mobile header layout */
           flex-direction: column;
           align-items: flex-start;
           gap: 10px;
       }
       .app-container > header .flex.items-center.gap-4 { /* Search + buttons */
           width: 100%;
           justify-content: space-between;
       }
       .app-container > header .search-container {
           flex-grow: 1;
           margin-right: 10px;
       }
       .app-container > header .search-input {
           width: 100%;
       }
       .app-container > header .text-2xl { /* Main title */
           font-size: 1.5rem; /* text-xl */
       }
        .app-container > header .text-sm { /* Subtitle */
            font-size: 0.8rem;
        }
        .app-container > header .fa-music {
             font-size: 2rem; /* text-3xl */
        }


       .music-player {
           border-radius: 0;
           box-shadow: none;
       }

       /* Hide desktop player controls section */
       .player-controls { display: none; }
       /* Also hide the desktop volume control if it's separate */
       #desktop-volume-control { display: none; }

        /* Ensure main column takes only necessary space */
       .player-main-column {
           padding: 10px 10px 0 10px; /* Padding around player elements */
           flex-shrink: 0; /* Prevent shrinking */
           display: flex;
           flex-direction: column;
       }
        /* Ensure playlist column takes remaining space and handles scrolling */
       .playlist-column {
           padding: 0 10px 0 10px; /* Horizontal padding */
           display: flex;
           flex-direction: column;
           flex-grow: 1; /* Take remaining vertical space */
           overflow: hidden; /* Prevent container itself from scrolling */
           /* Add padding at bottom for fixed controls */
           padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 70px + 10px); /* Controls height + safe area + margin */
       }

        .tabs {
            margin-bottom: 5px;
            flex-shrink: 0; /* Prevent tabs from shrinking */
        }
        /* Make tab content area scrollable */
        .tab-content {
            flex-grow: 1; /* Take available space within playlist-column */
            overflow-y: auto; /* Enable scrolling for the content */
             -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }
        /* Remove fixed max-height from lists on mobile, let flexbox handle height */
        .scrollable-list-area {
            max-height: none;
            height: auto; /* Allow content to determine height */
        }

       .scrollable-list-area::-webkit-scrollbar {
           display: none; /* Hide scrollbar on mobile WebKit */
       }
       .scrollable-list-area {
           scrollbar-width: none; /* Hide scrollbar on Firefox */
       }

       .playlist-item, .history-item, .favorite-item {
          padding: 10px 5px; /* Adjust padding */
       }
       .playlist-item h3, .history-item h3, .favorite-item h3 { font-size: 0.9rem; }
       .playlist-item p, .history-item p, .favorite-item p { font-size: 0.75rem; }
       .playlist-item .w-10, .history-item .w-10, .favorite-item .w-10 { width: 36px; height: 36px; }

       /* Progress bar touch */
       .progress-container {
           height: 8px; /* Taller track for easier touch */
           border-radius: 8px;
           padding-top: 12px; /* Larger touch area above */
           padding-bottom: 12px; /* Larger touch area below */
           margin-top: -12px; /* Offset padding */
           margin-bottom: 5px; /* Space below progress */
       }
       .progress-bar { border-radius: 8px; }
        /* Ensure thumb is always visible on mobile */
        .progress-bar::after {
            width: 18px;
            height: 18px;
            transform: translate(50%, -50%) scale(1); /* Always visible */
        }


       /* Time display */
       .time-display {
          display: flex;
          justify-content: space-between;
          margin-top: 8px; /* Space above time */
       }
        #current-time, #total-time {
            font-size: 0.85rem;
            font-family: 'Poppins', sans-serif; /* Ensure font consistency */
            font-weight: 500;
            color: var(--text-color);
            opacity: 0.8; /* Slightly faded */
        }


    } /* End mobile styles */


    /* Fixed Bottom Controls (Mobile Only) */
    #bottom-controls {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background-color: var(--card-color);
        border-top: 1px solid var(--border-color);
        padding: 10px 15px;
        padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 10px); /* iOS Safe Area */
        display: flex; /* Changed from none to flex */
        align-items: center;
        justify-content: space-between;
        z-index: 500; /* Ensure above content, below modals */
        transition: background-color 0.3s ease, border-color 0.3s ease;
        height: calc(env(safe-area-inset-bottom, 0px) + 70px); /* Add safe area to height */
    }
    /* Adjust button sizes and touch targets */
    #bottom-controls button {
        padding: 5px;
        min-width: 44px; /* Ensure min touch target width */
        min-height: 44px; /* Ensure min touch target height */
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0; /* Prevent shrinking */
    }
    #bottom-controls #btn-play-mobile { width: 50px; height: 50px; font-size: 1.8rem; }
    #bottom-controls #btn-prev-mobile, #bottom-controls #btn-next-mobile { font-size: 1.6rem; }
    #bottom-controls #btn-shuffle-mobile, #bottom-controls #btn-loop-mobile { font-size: 1.2rem; width: 35px; height: 35px; }

    /* Control layout for mobile */
    #bottom-controls .controls-left { order: 1; display: flex; align-items: center; gap: 15px; }
    #bottom-controls .controls-center { order: 2; display: flex; align-items: center; gap: 25px; flex-grow: 1; justify-content: center; }
    #bottom-controls .controls-right { order: 3; /* Currently empty, could hold volume toggle */ }

    /* Hide bottom controls on larger screens */
    @media (min-width: 1024px) {
        #bottom-controls { display: none; }
    }

  </style>
</head>

<body class=""> <!-- Start with no 'has-bottom-controls' class -->
  <div class="app-container" id="app">
    <header class="flex flex-col md:flex-row justify-between items-center mb-6 gap-4">
      <div class="flex items-center">
        <i class="fas fa-music text-4xl mr-3" style="color: var(--primary-color)"></i>
        <h1 class="text-2xl md:text-3xl font-bold">Rei Kikuchi <span class="text-sm md:text-base font-normal">Premium Music Player</span></h1>
      </div>
      <div class="flex items-center gap-4 w-full md:w-auto"> <!-- Ensure buttons container adapts -->
        <div class="search-container flex-grow md:flex-grow-0"> <!-- Allow search to grow on mobile -->
          <i class="fas fa-search search-icon"></i>
          <input type="text" id="search-input" class="search-input px-4 py-2 rounded-full w-full md:w-64 focusable" placeholder="曲名を検索...">
        </div>
        <!-- Buttons Container -->
        <div class="flex items-center gap-2 flex-shrink-0"> <!-- Prevent buttons shrinking -->
            <button id="offline-menu-btn" class="btn-mode btn-inactive focusable hidden" aria-label="オフラインキャッシュ管理">
              <i class="fas fa-cloud-download-alt"></i>
            </button>
            <button id="theme-toggle" class="btn-mode btn-inactive focusable" aria-label="テーマ切り替え" aria-pressed="false">
              <i class="fas fa-moon"></i>
            </button>
            <button id="account-btn" class="btn-mode btn-inactive focusable" aria-label="アカウント">
              <i class="fas fa-user"></i>
            </button>
        </div>
      </div>
    </header>

    <!-- プロフィールセクション -->
    <div id="profile-section" class="bg-gradient-to-r from-purple-100 to-indigo-100 dark:from-purple-900 dark:to-indigo-900 rounded-lg p-4 mb-6 shadow-md transition-all duration-300 ease-in-out mx-2 md:mx-0"> <!-- Add horizontal margin for mobile -->
      <div class="flex flex-col md:flex-row items-center justify-between">
        <div class="flex items-center mb-4 md:mb-0">
          <div class="w-16 h-16 md:w-20 md:h-20 rounded-full overflow-hidden border-4 border-white dark:border-gray-800 shadow-lg mr-4 flex-shrink-0">
            <img src="https://i.ytimg.com/vi/o3BudA6Qm6Y/hqdefault.jpg" alt="Rei Kikuchi" class="w-full h-full object-cover">
          </div>
          <div>
            <h2 class="text-xl md:text-2xl font-bold">Rei Kikuchi</h2>
            <p class="text-sm md:text-base opacity-75">音楽クリエイター / Riffusion アーティスト</p>
          </div>
        </div>
        <div class="flex flex-wrap gap-3 justify-center md:justify-end">
          <a href="https://www.youtube.com/channel/UCYAuSEKhuk3v4ZKzm5Lqb1Q" target="_blank" rel="noopener noreferrer" class="flex items-center px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-full transition-colors duration-200 shadow-md focusable">
            <i class="fab fa-youtube mr-2 text-lg"></i>
            <span>YouTube</span>
          </a>
          <a href="https://www.instagram.com/youtube_rei_kikuchi/" target="_blank" rel="noopener noreferrer" class="flex items-center px-4 py-2 bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white rounded-full transition-colors duration-200 shadow-md focusable">
            <i class="fab fa-instagram mr-2 text-lg"></i>
            <span>Instagram</span>
          </a>
          <a href="https://www.riffusion.com/u/REI_KIKUCHI" target="_blank" rel="noopener noreferrer" class="flex items-center px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-full transition-colors duration-200 shadow-md focusable">
            <i class="fas fa-music mr-2 text-lg"></i>
            <span>Riffusion</span>
          </a>
        </div>
      </div>
    </div>

    <!-- Main Player Structure -->
    <div class="music-player flex-grow flex flex-col"> <!-- Use flex-grow and flex-col -->
        <div class="music-player-grid flex-grow"> <!-- Grid takes remaining space -->
            <!-- Player Section (Main Column) -->
            <div class="player-main-column flex flex-col"> <!-- Column layout for player parts -->
                <div class="youtube-container mb-4 flex-shrink-0"> <!-- Video player area -->
                    <div id="youtube-player"></div>
                    <span id="now-playing-badge" class="badge hidden">NOW PLAYING</span>
                </div>
                <div class="flex justify-end mb-2 gap-2 flex-shrink-0"> <!-- Buttons below video -->
                     <button id="youtube-sync-btn" class="px-3 py-1 rounded-md text-sm focusable hidden" style="background-color: var(--primary-color); color: white;">
                         <i class="fab fa-youtube mr-1"></i> 新曲を同期
                     </button>
                    <button id="share-btn" class="px-3 py-1 rounded-md text-sm disabled:opacity-50 focusable" style="background-color: var(--border-color);" disabled>
                        <i class="fas fa-share-alt mr-1"></i> 共有
                    </button>
                    <button id="open-youtube-btn" class="px-3 py-1 rounded-md text-sm disabled:opacity-50 focusable" style="background-color: var(--border-color);" disabled>
                        <i class="fab fa-youtube mr-1"></i> YouTubeで開く
                    </button>
                </div>
                <div class="visualizer-container mb-4 flex-shrink-0"> <!-- Visualizer -->
                    <canvas id="visualizer"></canvas>
                </div>
                <div class="player-info mb-4 flex-shrink-0"> <!-- Song Info -->
                    <h2 id="current-song-title" class="text-xl font-bold truncate">選択された曲はありません</h2>
                    <p id="current-song-duration" class="text-sm opacity-75">--:--</p>
                </div>
                <div class="progress-container mb-2 flex-shrink-0"> <!-- Progress Bar -->
                    <div class="progress-bar" id="progress-bar"></div>
                </div>
                <div class="time-display mb-4 flex-shrink-0"> <!-- Time Display -->
                    <span id="current-time">00:00</span>
                    <span id="total-time">00:00</span>
                </div>
                <!-- Desktop Controls (Hidden on Mobile) -->
                <div class="player-controls flex items-center justify-between mb-6 flex-shrink-0">
                    <div class="flex items-center gap-4">
                    <button id="btn-shuffle" class="text-xl btn-inactive rounded-full w-10 h-10 flex items-center justify-center focusable" aria-label="シャッフル" aria-pressed="false">
                        <i class="fas fa-random"></i>
                    </button>
                    <button id="btn-loop" class="text-xl btn-inactive rounded-full w-10 h-10 flex items-center justify-center focusable" aria-label="リピート: オフ">
                        <i class="fas fa-repeat"></i>
                    </button>
                    </div>
                    <div class="flex items-center gap-4">
                    <button id="btn-prev" class="text-2xl focusable" aria-label="前の曲">
                        <i class="fas fa-step-backward"></i>
                    </button>
                    <button id="btn-play" class="text-4xl btn-active rounded-full w-16 h-16 flex items-center justify-center focusable" aria-label="再生">
                        <i class="fas fa-play"></i>
                    </button>
                    <button id="btn-next" class="text-2xl focusable" aria-label="次の曲">
                        <i class="fas fa-step-forward"></i>
                    </button>
                    </div>
                    <div id="desktop-volume-control" class="flex items-center gap-2">
                        <i class="fas fa-volume-up text-sm" aria-hidden="true"></i>
                        <div class="volume-control">
                            <input type="range" id="volume-slider" min="0" max="100" value="100" aria-label="音量調整" class="focusable">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Playlist Section (Sidebar Column) -->
            <div class="playlist-column flex flex-col"> <!-- Column layout for tabs and lists -->
                <div class="tabs flex-shrink-0">
                    <div class="tab active focusable" data-tab="playlist" role="tab" aria-selected="true" tabindex="0">プレイリスト</div>
                    <div class="tab focusable" data-tab="history" role="tab" aria-selected="false" tabindex="0">再生履歴</div>
                    <div class="tab focusable" data-tab="favorites" role="tab" aria-selected="false" tabindex="0">お気に入り</div>
                    <div class="tab focusable" data-tab="user-playlists" role="tab" aria-selected="false" tabindex="0">マイプレイリスト</div>
                </div>

                <div id="playlist-tab" class="tab-content flex-grow" role="tabpanel">
                    <div class="playlist scrollable-list-area" id="playlist">
                        <div class="text-center py-8 text-gray-500">
                            <i class="fas fa-spinner fa-spin text-3xl mb-4"></i>
                            <p>楽曲を読み込み中...</p>
                        </div>
                    </div>
                </div>

                <div id="history-tab" class="tab-content hidden flex-grow" role="tabpanel">
                    <div class="history-list scrollable-list-area" id="history-list">
                        <div class="text-center py-8 text-gray-500">
                            <p>再生履歴はありません</p>
                        </div>
                    </div>
                </div>

                <div id="favorites-tab" class="tab-content hidden flex-grow" role="tabpanel">
                    <div class="favorites-list scrollable-list-area" id="favorites-list">
                        <div class="text-center py-8 text-gray-500">
                            <p>お気に入りに登録された曲はありません</p>
                        </div>
                    </div>
                </div>

                <div id="user-playlists-tab" class="tab-content hidden flex-grow" role="tabpanel">
                    <div class="mb-4 flex-shrink-0">
                        <button id="create-playlist-btn" class="px-3 py-1 rounded-md text-sm mb-4 focusable" style="background-color: var(--primary-color); color: white;">
                            <i class="fas fa-plus mr-1"></i> 新しいプレイリスト
                        </button>
                    </div>
                    <div class="user-playlists-list scrollable-list-area" id="user-playlists-list">
                        <div class="text-center py-8 text-gray-500">
                            <p>マイプレイリストはありません</p>
                        </div>
                    </div>
                </div>
            </div> <!-- End playlist-column -->
        </div> <!-- End music-player-grid -->
    </div> <!-- End music-player -->


    <!-- Modal Dialogs -->
    <div id="create-playlist-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="create-playlist-modal-title">
      <div class="modal-content">
        <div class="flex justify-between items-center mb-4">
          <h3 id="create-playlist-modal-title" class="text-lg font-bold">新しいプレイリストを作成</h3>
          <button class="modal-close-btn close-modal-btn focusable" data-modal-id="createPlaylist" aria-label="閉じる">×</button>
        </div>
        <div class="mb-4">
          <label for="playlist-name-input" class="block text-sm mb-2">プレイリスト名</label>
          <input type="text" id="playlist-name-input" class="w-full px-3 py-2 border rounded focusable" style="border-color: var(--border-color); background-color: var(--card-color);">
        </div>
        <div>
          <button id="save-playlist-btn" class="px-4 py-2 rounded text-white focusable" style="background-color: var(--primary-color);">保存</button>
        </div>
      </div>
    </div>

    <div id="share-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="share-modal-title">
      <div class="modal-content">
        <div class="flex justify-between items-center mb-4">
          <h3 id="share-modal-title" class="text-lg font-bold">共有</h3>
          <button class="modal-close-btn close-modal-btn focusable" data-modal-id="share" aria-label="閉じる">×</button>
        </div>
        <p id="share-object-title" class="mb-4"></p>
        <div class="flex gap-4 mb-4">
          <button class="share-option flex-1 px-3 py-2 rounded text-white focusable" style="background-color: #1DA1F2;">
            <i class="fab fa-twitter mr-2"></i> Twitter
          </button>
          <button class="share-option flex-1 px-3 py-2 rounded text-white focusable" style="background-color: #4267B2;">
            <i class="fab fa-facebook-f mr-2"></i> Facebook
          </button>
        </div>
        <div class="mb-4">
          <label for="share-link-input" class="block text-sm mb-2">共有リンク</label>
          <div class="flex">
            <input type="text" id="share-link-input" class="flex-1 px-3 py-2 border rounded-l focusable" style="border-color: var(--border-color); background-color: var(--card-color);" readonly>
            <button id="copy-link-btn" class="px-3 py-2 rounded-r text-white focusable" style="background-color: var(--primary-color);">コピー</button>
          </div>
        </div>
      </div>
    </div>

  <!-- アカウントモーダル（アップグレード版） -->
    <div id="account-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="account-modal-title">
        <div class="modal-content">
            <!-- ヘッダー -->
            <div class="flex justify-between items-center mb-4">
                <h3 id="account-modal-title" class="text-lg font-bold text-gray-800 dark:text-gray-200">アカウント設定</h3>
                <button class="modal-close-btn close-modal-btn focusable" data-modal-id="account" aria-label="閉じる">×</button>
            </div>

            <!-- ログインセクション -->
            <div id="login-section">
                <div class="mb-4">
                    <label for="login-email" class="block text-sm mb-2 text-gray-700 dark:text-gray-300">メールアドレス</label>
                    <input type="email" id="login-email" class="w-full px-3 py-2 border rounded focusable" style="border-color: var(--border-color); background-color: var(--card-color);">
                </div>
                <div class="mb-4">
                    <label for="login-password" class="block text-sm mb-2 text-gray-700 dark:text-gray-300">パスワード</label>
                    <input type="password" id="login-password" class="w-full px-3 py-2 border rounded focusable" style="border-color: var(--border-color); background-color: var(--card-color);">
                </div>
                <div class="mb-4 flex space-x-2">
                    <button id="login-btn" class="px-4 py-2 rounded text-white focusable" style="background-color: var(--primary-color);">ログイン</button>
                    <button id="show-register-btn" class="px-4 py-2 rounded focusable" style="background-color: var(--border-color);">新規登録</button>
                </div>
            </div>

            <!-- 登録セクション -->
            <div id="register-section" class="hidden">
                <div class="mb-4">
                    <label for="register-name" class="block text-sm mb-2 text-gray-700 dark:text-gray-300">ユーザー名</label>
                    <input type="text" id="register-name" class="w-full px-3 py-2 border rounded focusable" style="border-color: var(--border-color); background-color: var(--card-color);">
                </div>
                <div class="mb-4">
                    <label for="register-email" class="block text-sm mb-2 text-gray-700 dark:text-gray-300">メールアドレス</label>
                    <input type="email" id="register-email" class="w-full px-3 py-2 border rounded focusable" style="border-color: var(--border-color); background-color: var(--card-color);">
                </div>
                <div class="mb-4">
                    <label for="register-password" class="block text-sm mb-2 text-gray-700 dark:text-gray-300">パスワード</label>
                    <input type="password" id="register-password" class="w-full px-3 py-2 border rounded focusable" style="border-color: var(--border-color); background-color: var(--card-color);">
                </div>
                <div class="mb-4 flex space-x-2">
                    <button id="register-btn" class="px-4 py-2 rounded text-white focusable" style="background-color: var(--primary-color);">登録</button>
                    <button id="show-login-btn" class="px-4 py-2 rounded focusable" style="background-color: var(--border-color);">ログインに戻る</button>
                </div>
            </div>

            <!-- アカウント情報セクション -->
            <div id="account-info-section" class="hidden">
                <div class="mb-4 text-center">
                    <div class="w-16 h-16 rounded-full bg-gray-300 dark:bg-gray-600 flex items-center justify-center mx-auto mb-2">
                    <i class="fas fa-user text-3xl text-gray-700 dark:text-gray-200"></i>
                    </div>
                    <h4 id="user-name" class="font-bold text-gray-800 dark:text-gray-200"></h4>
                    <p id="user-email" class="text-sm opacity-75 text-gray-700 dark:text-gray-300"></p>
                </div>
                <div class="mb-4 space-y-2">
                    <button id="sync-data-btn" class="w-full px-4 py-2 rounded focusable" style="background-color: var(--border-color);">
                    <i class="fas fa-sync mr-2"></i> データを同期
                    </button>
                    <button id="logout-btn" class="w-full px-4 py-2 rounded text-white focusable" style="background-color: var(--accent-color);">
                    <i class="fas fa-sign-out-alt mr-2"></i> ログアウト
                    </button>
                </div>
            </div>
        </div>
    </div>



    <div id="playlist-detail-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="playlist-detail-modal-title">
       <div class="modal-content"> <!-- Removed max-h here, handled by list inside -->
         <div class="flex justify-between items-center mb-4">
           <h3 id="playlist-detail-title" class="text-lg font-bold">プレイリスト</h3>
           <button class="modal-close-btn close-modal-btn focusable" data-modal-id="playlistDetail" aria-label="閉じる">×</button>
         </div>
         <!-- Make the list scrollable, not the whole modal content -->
         <div id="playlist-detail-content" class="playlist-detail-list scrollable-list-area max-h-[60vh]"> <!-- Added scrollable class and max-height -->
           <p class="text-center py-8 text-gray-500">プレイリストを読み込み中...</p>
         </div>
         <div class="flex gap-2 mt-4">
           <button id="remove-from-playlist-btn" class="px-3 py-1 rounded text-sm hidden focusable" style="background-color: var(--accent-color); color: white;">
             <i class="fas fa-minus mr-1"></i> 選択を削除
           </button>
           <button id="share-playlist-btn" class="px-3 py-1 rounded text-sm ml-auto focusable" style="background-color: var(--primary-color); color: white;">
             <i class="fas fa-share-alt mr-1"></i> 共有
           </button>
         </div>
       </div>
     </div>

     <!-- Offline Modal (Dynamically created in JS, but placeholder structure) -->
     <div id="offline-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="offline-modal-title">
        <!-- Content added by JS in offlinePlayback.addOfflineUI -->
     </div>


    <div id="snackbar" class="snackbar"></div>

    <footer class="mt-8 text-center text-sm opacity-75 pb-4 md:pb-0"> <!-- Add padding bottom on mobile -->
      <p>© 2025 Rei Kikuchi Music Player | このプレイヤーはRei Kikuchiによって作られました</p>
    </footer>
  </div> <!-- End #app -->

  <!-- Fixed Bottom Controls (Mobile Only) -->
  <div id="bottom-controls" class="hidden"> <!-- Start hidden, shown by JS if needed -->
      <div class="controls-left">
          <button id="btn-shuffle-mobile" class="btn-inactive rounded-full focusable" aria-label="シャッフル" aria-pressed="false">
              <i class="fas fa-random"></i>
          </button>
          <button id="btn-loop-mobile" class="btn-inactive rounded-full focusable" aria-label="リピート: オフ">
              <i class="fas fa-repeat"></i>
          </button>
      </div>
      <div class="controls-center">
          <button id="btn-prev-mobile" class="focusable" aria-label="前の曲">
              <i class="fas fa-step-backward"></i>
          </button>
          <button id="btn-play-mobile" class="btn-active rounded-full focusable" aria-label="再生">
              <i class="fas fa-play"></i>
          </button>
          <button id="btn-next-mobile" class="focusable" aria-label="次の曲">
              <i class="fas fa-step-forward"></i>
          </button>
      </div>
      <div class="controls-right">
          <!-- Placeholder for potential volume toggle or other controls -->
      </div>
  </div>

  <!-- YouTube API -->
  <script src="https://www.youtube.com/iframe_api"></script>
  <script>
    // ==========================================================================
    // Constants
    // ==========================================================================
    const MAX_HISTORY = 20;
    const VOLUME_STEP = 5; // For keyboard control
    const SEEK_STEP = 5; // For keyboard control (seconds)

    // ==========================================================================
    // Data and State Management
    // ==========================================================================
    const appState = {
      player: null,
      songs: [],
      filteredSongs: [], // Currently displayed songs in the main playlist tab
      currentSongIndex: -1, // Index within the original `songs` array
      isPlaying: false,
      isShuffle: false,
      loopMode: 'none', // 'none', 'one', 'all'
      currentTab: 'playlist',
      volume: 100,
      progressInterval: null,
      history: [],
      favorites: [],
      userPlaylists: [],
      currentSelectedPlaylistId: null, // Renamed for clarity
      loggedInUser: null,
      snackbarTimeoutId: null, // For managing snackbar display
      activeModalId: null, // Track the currently open modal
      isPlayerReady: false,
      visualizer: {
          context: null,
          analyser: null,
          animationFrameId: null,
          bufferLength: 0,
          dataArray: null,
          canvas: null,
          canvasCtx: null,
      }
    };

    // ==========================================================================
    // Elements (Will be initialized in onPlayerReady)
    // ==========================================================================
    let elements = {}; // Declare elements object, initialize later

    function initializeElements() {
        elements = {
            app: document.getElementById('app'),
            body: document.body, // body要素を追加
            playlist: document.getElementById('playlist'),
            historyList: document.getElementById('history-list'),
            favoritesList: document.getElementById('favorites-list'),
            userPlaylistsList: document.getElementById('user-playlists-list'),
            currentSongTitle: document.getElementById('current-song-title'),
            currentSongDuration: document.getElementById('current-song-duration'),
            progressBar: document.getElementById('progress-bar'),
            progressContainer: document.querySelector('.progress-container'),
            currentTime: document.getElementById('current-time'),
            totalTime: document.getElementById('total-time'),
            // Desktop Controls
            btnPlay: document.getElementById('btn-play'),
            btnPrev: document.getElementById('btn-prev'),
            btnNext: document.getElementById('btn-next'),
            btnShuffle: document.getElementById('btn-shuffle'),
            btnLoop: document.getElementById('btn-loop'),
            volumeSlider: document.getElementById('volume-slider'),
            // --- General UI ---
            themeToggle: document.getElementById('theme-toggle'),
            searchInput: document.getElementById('search-input'),
            tabs: document.querySelectorAll('.tab'),
            tabContents: document.querySelectorAll('.tab-content'),
            visualizerCanvas: document.getElementById('visualizer'),
            nowPlayingBadge: document.getElementById('now-playing-badge'),
            openYouTubeBtn: document.getElementById('open-youtube-btn'),
            shareBtn: document.getElementById('share-btn'),
            createPlaylistBtn: document.getElementById('create-playlist-btn'),
            youtubeSyncBtn: document.getElementById('youtube-sync-btn'), // Sync button
            offlineMenuBtn: document.getElementById('offline-menu-btn'), // Offline button
            // --- Modals ---
            modals: { // モーダル要素をここに集約
                createPlaylist: document.getElementById('create-playlist-modal'),
                playlistDetail: document.getElementById('playlist-detail-modal'),
                share: document.getElementById('share-modal'),
                account: document.getElementById('account-modal'),
                offline: document.getElementById('offline-modal') // Add offline modal placeholder
            },
            // --- Modal Close Buttons ---
            modalCloseBtns: document.querySelectorAll('.close-modal-btn'), // 閉じるボタンを一括取得
            // --- Modal Specific Buttons ---
            modalButtons: {
                savePlaylist: document.getElementById('save-playlist-btn'),
                removeFromPlaylist: document.getElementById('remove-from-playlist-btn'),
                sharePlaylist: document.getElementById('share-playlist-btn'),
                copyLink: document.getElementById('copy-link-btn'),
                login: document.getElementById('login-btn'),
                showRegister: document.getElementById('show-register-btn'),
                register: document.getElementById('register-btn'),
                showLogin: document.getElementById('show-login-btn'),
                syncData: document.getElementById('sync-data-btn'),
                logout: document.getElementById('logout-btn'),
                account: document.getElementById('account-btn') // ヘッダーのアカウントボタン
            },
            // --- Account Sections and Fields ---
            accountSections: {
                login: document.getElementById('login-section'),
                register: document.getElementById('register-section'),
                accountInfo: document.getElementById('account-info-section')
            },
            accountFields: {
                loginEmail: document.getElementById('login-email'),
                loginPassword: document.getElementById('login-password'),
                registerName: document.getElementById('register-name'),
                registerEmail: document.getElementById('register-email'),
                registerPassword: document.getElementById('register-password'),
                userName: document.getElementById('user-name'),
                userEmail: document.getElementById('user-email')
            },
            // --- Playlist Related Elements ---
            playlistElements: {
                nameInput: document.getElementById('playlist-name-input'),
                detailTitle: document.getElementById('playlist-detail-title'),
                detailContent: document.getElementById('playlist-detail-content'),
                shareObjectTitle: document.getElementById('share-object-title'),
                shareLinkInput: document.getElementById('share-link-input')
            },
            snackbar: document.getElementById('snackbar'),
            // --- Mobile Bottom Controls ---
            bottomControls: document.getElementById('bottom-controls'),
            btnPlayMobile: document.getElementById('btn-play-mobile'),
            btnPrevMobile: document.getElementById('btn-prev-mobile'),
            btnNextMobile: document.getElementById('btn-next-mobile'),
            btnShuffleMobile: document.getElementById('btn-shuffle-mobile'),
            btnLoopMobile: document.getElementById('btn-loop-mobile'),
        };
        // Optional: Add checks here to ensure critical elements were found
        if (!elements.btnPlay) console.warn("Desktop Play button not found during initialization.");
        if (!elements.btnPlayMobile) console.warn("Mobile Play button not found during initialization.");
        if (!elements.playlist) console.error("ERROR: Playlist container not found during initialization!");
        if (!elements.modals.account) console.error("ERROR: Account Modal not found during initialization!");
        // Add more checks as needed
    }


    // ==========================================================================
    // YouTube Player Initialization
    // ==========================================================================
    function onYouTubeIframeAPIReady() {
      console.log("onYouTubeIframeAPIReady called");
      try {
        appState.player = new YT.Player('youtube-player', {
          height: '100%',
          width: '100%',
          videoId: '', // Start empty
          playerVars: {
            'autoplay': 0, 'controls': 0, 'rel': 0, 'showinfo': 0,
            'modestbranding': 1, 'fs': 0, 'playsinline': 1
          },
          events: {
            'onReady': onPlayerReady,
            'onStateChange': onPlayerStateChange,
            'onError': onPlayerError
          }
        });
      } catch (error) {
          console.error("Error initializing YouTube Player:", error);
          showSnackbar("プレイヤーの初期化に失敗しました。");
      }
    }

    function onPlayerReady(event) {
      console.log("Player Ready");

      // ***** INITIALIZE ELEMENTS HERE *****
      initializeElements();
      // ***** END INITIALIZE ELEMENTS *****

      appState.isPlayerReady = true;
      if(elements.volumeSlider) elements.volumeSlider.value = appState.volume; // Now elements are initialized
      else console.warn("Volume slider element not found after init.");

      if(event.target && typeof event.target.setVolume === 'function') {
          try { event.target.setVolume(appState.volume); } catch (e) { console.warn("Failed to set initial volume", e)}
      }

      // Load songs *after* player is ready and elements are initialized
      loadSongsFromYouTube(); // Load from API
      loadUserData(); // Load local data
      initAudioAnalyser(); // Setup visualizer canvas
      setupEventListeners(); // Setup UI interactions *after* elements are initialized
      handleUrlParams(); // Check for shared links etc.
      checkBottomControlsVisibility(); // Setup mobile/desktop view differences

      // Initialize YouTube Sync and Offline features *after* player is ready and elements are known
      setupYouTubeSync();
      offlinePlayback.init();

      console.log("Player initialization sequence complete.");
    }


    function onPlayerStateChange(event) {
      console.log("Player State Changed:", event.data);
      const playerState = event.data;
      const isPlaying = playerState === YT.PlayerState.PLAYING;
      const isPaused = playerState === YT.PlayerState.PAUSED;
      const isEnded = playerState === YT.PlayerState.ENDED;
      const isCued = playerState === YT.PlayerState.CUED;
      const isBuffering = playerState === YT.PlayerState.BUFFERING;

     // 共通のUI更新処理
appState.isPlaying = isPlaying;
elements.nowPlayingBadge?.classList.toggle('hidden', !isPlaying);
elements.shareBtn?.toggleAttribute('disabled', !isPlaying); // 再生中のみ共有可能
// 修正：現在の曲の情報があるかで判定
elements.openYouTubeBtn?.toggleAttribute('disabled', !currentSongData()?.id);


       // Update Play/Pause buttons (Desktop and Mobile)
        const playIcon = '<i class="fas fa-play"></i>';
        const pauseIcon = '<i class="fas fa-pause"></i>';
        const playLabel = '再生';
        const pauseLabel = '一時停止';

        if (elements.btnPlay) {
            elements.btnPlay.innerHTML = isPlaying ? pauseIcon : playIcon;
            elements.btnPlay.setAttribute('aria-label', isPlaying ? pauseLabel : playLabel);
        }
        if (elements.btnPlayMobile) {
            elements.btnPlayMobile.innerHTML = isPlaying ? pauseIcon : playIcon;
            elements.btnPlayMobile.setAttribute('aria-label', isPlaying ? pauseLabel : playLabel);
        }


      if (isEnded) {
        handleSongEnd();
      } else if (isPlaying) {
        startProgressUpdate();
        const song = currentSongData();
        if (song) {
            addToHistory(song);
            renderHistoryList();
        }
        if (appState.visualizer.animationFrameId === null) {
            drawVisualizer(); // Start visualizer
        }
      } else if (isPaused || isCued) {
        stopProgressUpdate();
        // Stop visualizer smoothly
        if (appState.visualizer.animationFrameId !== null) {
            cancelAnimationFrame(appState.visualizer.animationFrameId);
            appState.visualizer.animationFrameId = null;
            if (appState.visualizer.canvasCtx && appState.visualizer.canvas) {
                 setTimeout(() => {
                    if(appState.visualizer.canvas) { // Check if canvas still exists
                        appState.visualizer.canvasCtx.clearRect(0, 0, appState.visualizer.canvas.width, appState.visualizer.canvas.height);
                    }
                 }, 100);
            }
        }
        if (isCued) {
            updateProgress(); // Ensure progress bar shows 00:00 / duration when cued
        }
      } else if (isBuffering) {
          console.log("Buffering...");
          // Optionally show a spinner or disable controls during buffering
      }
    }

     function onPlayerError(event) {
         console.error("YouTube Player Error:", event.data);
         let errorMessage = "動画の再生中にエラーが発生しました。";
         switch (event.data) {
             case 2: errorMessage = "再生リクエストが無効です。"; break;
             case 5: errorMessage = "プレイヤー内部のエラーが発生しました。"; break;
             case 100: errorMessage = "動画が見つからないか、削除されました。"; break;
             case 101: case 150: errorMessage = "この動画は埋め込み再生が許可されていません。"; break;
             default: errorMessage = `不明なエラーが発生しました (コード: ${event.data})。`;
         }
         showSnackbar(errorMessage);
         // Reset player state visually
         const playIcon = '<i class="fas fa-play"></i>';
         const playLabel = '再生';
         if (elements.btnPlay) {
            elements.btnPlay.innerHTML = playIcon;
            elements.btnPlay.setAttribute('aria-label', playLabel);
         }
         if (elements.btnPlayMobile) {
             elements.btnPlayMobile.innerHTML = playIcon;
             elements.btnPlayMobile.setAttribute('aria-label', playLabel);
         }
         appState.isPlaying = false;
         elements.nowPlayingBadge?.classList.add('hidden');
         stopProgressUpdate();
         resetPlayerInfo();
     }

    // ==========================================================================
    // App Initialization Functions
    // ==========================================================================
    async function loadSongsFromYouTube() {
  try {
    // 最新15件の動画データを取得
    const videos = await youtubeAPI.getLatestVideos(15);
    if (videos.length === 0) {
      showSnackbar("新しい動画は見つかりませんでした");
      return;
    }
    // 動画IDの配列を作成（前後の空白を除去）
    const videoIds = videos.map(video => video.id.trim());
    // 動画詳細情報を取得（duration など）
    const videoDetails = await youtubeAPI.getVideoDetails(videoIds);
    
    // 各動画データに正しい duration をマージして設定する
    appState.songs = videos.map(video => {
      // getVideoDetails の中から該当する動画を探す
      const details = videoDetails.find(detail => detail.id === video.id) || {};
      return {
        id: video.id.trim(),
        title: video.title,
        duration: details.duration || '--:--',  // 正しい duration があれば上書き
        thumbnail: video.thumbnail
      };
    });
    // フィルタリング用の配列も更新
    appState.filteredSongs = [...appState.songs];
    renderPlaylist(); // プレイリストの表示を更新
  } catch (error) {
    console.error("動画データの取得に失敗しました", error);
    showSnackbar("動画データの取得に失敗しました");
  }
}


    function showLoadingIndicator(container) {
        if (!container) return;
        container.innerHTML = `
            <div class="text-center py-8 text-gray-500">
                <i class="fas fa-spinner fa-spin text-3xl mb-4"></i>
                <p>読み込み中...</p>
            </div>`;
    }

    function hideLoadingIndicator(container) {
        // The container's content will be replaced by render functions,
        // so direct removal isn't always needed if render follows immediately.
        // However, if rendering fails, this ensures the spinner is gone.
        const spinner = container?.querySelector('.fa-spinner');
        if (spinner) {
            spinner.parentElement.remove();
        }
    }
     function showEmptyMessage(container, message) {
         if (!container) return;
         container.innerHTML = `<div class="text-center py-8 text-gray-500"><p>${escapeHTML(message)}</p></div>`;
     }


    function loadUserData() {
      console.log("Loading user data from localStorage...");
      try {
          const storedHistory = localStorage.getItem('reiKikuchiPlayerHistory');
          const storedFavorites = localStorage.getItem('reiKikuchiPlayerFavorites');
          const storedPlaylists = localStorage.getItem('reiKikuchiPlayerPlaylists');
          const storedUser = localStorage.getItem('reiKikuchiPlayerUser');
          const savedTheme = localStorage.getItem('reiKikuchiPlayerTheme');

          appState.history = storedHistory ? JSON.parse(storedHistory) : [];
          appState.favorites = storedFavorites ? JSON.parse(storedFavorites) : [];
          appState.userPlaylists = storedPlaylists ? JSON.parse(storedPlaylists) : [];
          appState.loggedInUser = storedUser ? JSON.parse(storedUser) : null;

          // Apply theme preference
          const isDark = savedTheme === 'dark';
          if(elements.body) elements.body.classList.toggle('dark', isDark);
          if(elements.themeToggle) {
              elements.themeToggle.innerHTML = isDark ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
              elements.themeToggle.classList.toggle('btn-active', isDark);
              elements.themeToggle.classList.toggle('btn-inactive', !isDark);
              elements.themeToggle.setAttribute('aria-pressed', isDark);
          }

          // Render lists based on loaded data (render functions handle empty states)
          renderHistoryList();
          renderFavoritesList();
          renderUserPlaylists();
          updateAccountUI(!!appState.loggedInUser); // Update account button/state based on loaded user
          console.log("User data loaded.");
      } catch(error) {
          console.error("Error loading user data:", error);
          showSnackbar("ユーザーデータの読み込みに失敗しました。");
          // Reset to defaults if loading fails?
          appState.history = [];
          appState.favorites = [];
          appState.userPlaylists = [];
          appState.loggedInUser = null;
          // Optionally clear relevant localStorage items
          // localStorage.removeItem('reiKikuchiPlayerHistory');
      }
    }

    function initAudioAnalyser() {
      console.log("Initializing visualizer...");
      try {
        appState.visualizer.canvas = elements.visualizerCanvas;
        if (!appState.visualizer.canvas) {
            console.error("Visualizer canvas element not found.");
            return;
        }
        appState.visualizer.canvasCtx = appState.visualizer.canvas.getContext('2d');
        if (!appState.visualizer.canvasCtx) {
            console.error("Failed to get 2D context for visualizer canvas.");
            return;
        }
        appState.visualizer.bufferLength = 128;
        appState.visualizer.dataArray = new Uint8Array(appState.visualizer.bufferLength);
        resizeCanvas(); // Set initial size
      } catch (error) {
        console.error('Visualizer setup failed:', error);
        if(elements.visualizerCanvas) elements.visualizerCanvas.style.display = 'none'; // Hide if setup fails
      }
    }

    // ==========================================================================
    // Event Listener Setup
    // ==========================================================================
    function setupEventListeners() {
      console.log("Setting up event listeners...");

      // Player Controls (Desktop) - Add null checks
      elements.btnPlay?.addEventListener('click', togglePlayPause);
      elements.btnNext?.addEventListener('click', playNextSong);
      elements.btnPrev?.addEventListener('click', playPreviousSong);
      elements.btnShuffle?.addEventListener('click', toggleShuffle);
      elements.btnLoop?.addEventListener('click', toggleLoopMode);
      elements.volumeSlider?.addEventListener('input', handleVolumeChange);
      elements.progressContainer?.addEventListener('click', seekToPosition);

       // Player Controls (Mobile) - Add null checks
       elements.btnPlayMobile?.addEventListener('click', togglePlayPause);
       elements.btnNextMobile?.addEventListener('click', playNextSong);
       elements.btnPrevMobile?.addEventListener('click', playPreviousSong);
       elements.btnShuffleMobile?.addEventListener('click', toggleShuffle);
       elements.btnLoopMobile?.addEventListener('click', toggleLoopMode);


      // Header Controls
      elements.themeToggle?.addEventListener('click', toggleTheme);
      elements.searchInput?.addEventListener('input', handleSearch);
      elements.modalButtons.account?.addEventListener('click', showAccountModal); // Header account button
      elements.youtubeSyncBtn?.addEventListener('click', () => youtubeAPI.updatePlaylist()); // Sync button
      elements.offlineMenuBtn?.addEventListener('click', () => offlinePlayback.showOfflineModal()); // Offline button

       // Action Buttons
       elements.shareBtn?.addEventListener('click', showShareModal);
       elements.openYouTubeBtn?.addEventListener('click', handleOpenYouTube);

      // Tab switching
      elements.tabs?.forEach(tab => {
        tab.addEventListener('click', () => switchTab(tab.dataset.tab));
        tab.addEventListener('keydown', (e) => { // Keyboard activation for tabs
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                switchTab(tab.dataset.tab);
            }
        });
      });

      // ---- Event Delegation for Lists ----
      setupListEventListeners(elements.playlist, handlePlaylistClick);
      setupListEventListeners(elements.historyList, handleHistoryClick);
      setupListEventListeners(elements.favoritesList, handleFavoritesClick);
      setupListEventListeners(elements.userPlaylistsList, handleUserPlaylistsClick);
      setupListEventListeners(elements.playlistElements?.detailContent, handlePlaylistDetailClick);

      // My Playlists Tab Button
      elements.createPlaylistBtn?.addEventListener('click', showCreatePlaylistModal);

      // --- Modal Close Buttons ---
       elements.modalCloseBtns?.forEach(btn => {
         btn.addEventListener('click', () => {
             const modalId = btn.dataset.modalId;
             if (modalId) {
                 hideModal(modalId);
             } else {
                 console.error("Close button clicked, but data-modal-id is missing:", btn);
             }
         });
       });

      // --- Modal Specific Action Buttons ---
      elements.modalButtons.savePlaylist?.addEventListener('click', saveNewPlaylist);
      elements.modalButtons.removeFromPlaylist?.addEventListener('click', removeSongFromPlaylist);
      elements.modalButtons.sharePlaylist?.addEventListener('click', sharePlaylist);
      elements.modalButtons.copyLink?.addEventListener('click', copyShareLink);

      // --- Account Modal Action Buttons ---
      elements.modalButtons.showRegister?.addEventListener('click', () => switchAuthSection('register'));
      elements.modalButtons.showLogin?.addEventListener('click', () => switchAuthSection('login'));
      elements.modalButtons.login?.addEventListener('click', handleLogin); // Login button inside modal
      elements.modalButtons.register?.addEventListener('click', handleRegister);
      elements.modalButtons.logout?.addEventListener('click', handleLogout);
      elements.modalButtons.syncData?.addEventListener('click', syncUserData);

       // --- Close Modals on Backdrop Click ---
       if (elements.modals) {
           Object.entries(elements.modals).forEach(([modalId, modal]) => { // Use entries to get key/value
               if (modal) {
                   modal.addEventListener('click', (e) => {
                       if (e.target === modal) { // Clicked on the backdrop itself
                           hideModal(modalId);
                       }
                   });
               } else {
                   // console.warn(`Modal element for ID '${modalId}' is null or undefined.`);
               }
           });
       }

       // --- Global Keydowns ---
       document.addEventListener('keydown', handleGlobalKeyDown);

      // --- Window Resize ---
      window.addEventListener('resize', resizeCanvas); // Visualizer canvas resize
      window.addEventListener('resize', checkBottomControlsVisibility); // Mobile controls visibility

      console.log("Event listeners setup complete.");
    }

    // Helper for setting up delegated event listeners on lists
    function setupListEventListeners(listElement, handler) {
        if (listElement) {
            listElement.addEventListener('click', handler);
        } else {
            // console.warn("List element not found for event delegation."); // Less noisy log
        }
    }

    // ==========================================================================
    // Event Handlers for Delegated List Clicks
    // ==========================================================================
    function handlePlaylistClick(event) {
        const target = event.target;
        const playlistItem = target.closest('.playlist-item');
        const favoriteBtn = target.closest('.favorite-btn');
        const addToPlaylistBtn = target.closest('.add-to-playlist-btn');
        const selectPlaylistLink = target.closest('.select-playlist');

        if (!playlistItem) { // Clicked outside any item
            closeAllPlaylistDropdowns();
            return;
        }

        const songId = playlistItem.dataset.id;

        if (favoriteBtn) {
            event.stopPropagation();
            toggleFavorite(songId);
        } else if (addToPlaylistBtn) {
            event.stopPropagation();
            togglePlaylistDropdown(addToPlaylistBtn);
        } else if (selectPlaylistLink) {
            event.preventDefault();
            event.stopPropagation();
            const playlistId = selectPlaylistLink.dataset.playlistid;
            addSongToPlaylist(songId, playlistId);
            closeAllPlaylistDropdowns();
        } else { // Clicked on the item itself (play song)
            const originalIndex = findSongIndexById(songId);
            if (originalIndex !== -1) {
                playSong(originalIndex);
                closeAllPlaylistDropdowns();
            } else {
                console.warn("Song ID not found in appState.songs:", songId);
                showSnackbar("曲が見つかりませんでした。");
            }
        }
    }

    function handleHistoryClick(event) {
        const target = event.target;
        const historyItem = target.closest('.history-item');
        if (!historyItem) {
            closeAllPlaylistDropdowns();
            return;
        }
        const songId = historyItem.dataset.id;
        const favoriteBtn = target.closest('.favorite-btn');
        const addToPlaylistBtn = target.closest('.add-to-playlist-btn');
        const selectPlaylistLink = target.closest('.select-playlist');

        if (favoriteBtn) {
            event.stopPropagation();
            toggleFavorite(songId);
        } else if (addToPlaylistBtn) {
            event.stopPropagation();
            togglePlaylistDropdown(addToPlaylistBtn);
        } else if (selectPlaylistLink) {
            event.preventDefault();
            event.stopPropagation();
            addSongToPlaylist(songId, selectPlaylistLink.dataset.playlistid);
            closeAllPlaylistDropdowns();
        } else { // Play song
            const originalIndex = findSongIndexById(songId);
            if (originalIndex !== -1) playSong(originalIndex);
            else showSnackbar("曲が見つかりませんでした。");
            closeAllPlaylistDropdowns();
        }
    }

    function handleFavoritesClick(event) {
        const target = event.target;
        const favoriteItem = target.closest('.favorite-item');
         if (!favoriteItem) {
            closeAllPlaylistDropdowns();
            return;
        }
        const songId = favoriteItem.dataset.id;
        const favoriteBtn = target.closest('.favorite-btn');
        const addToPlaylistBtn = target.closest('.add-to-playlist-btn');
        const selectPlaylistLink = target.closest('.select-playlist');

        if (favoriteBtn) {
            event.stopPropagation();
            toggleFavorite(songId); // Will remove it
        } else if (addToPlaylistBtn) {
            event.stopPropagation();
            togglePlaylistDropdown(addToPlaylistBtn);
        } else if (selectPlaylistLink) {
            event.preventDefault();
            event.stopPropagation();
            addSongToPlaylist(songId, selectPlaylistLink.dataset.playlistid);
            closeAllPlaylistDropdowns();
        } else { // Play song
            const originalIndex = findSongIndexById(songId);
            if (originalIndex !== -1) playSong(originalIndex);
            else showSnackbar("曲が見つかりませんでした。");
            closeAllPlaylistDropdowns();
        }
    }

    function handleUserPlaylistsClick(event) {
     const target = event.target;
     const playlistItem = target.closest('.user-playlist-item');
     if (!playlistItem) {
         // console.log("UserPlaylists: Clicked outside item"); // 必要ならコメント解除
         return; // Click outside items
     }

     const playlistId = playlistItem.dataset.id;
     console.log(`[DEBUG] UserPlaylists: Clicked item with ID: ${playlistId}`); // ★どの項目がクリックされたか

     const playBtn = target.closest('.playlist-play-btn'); // 再生ボタンは現在未使用
     const editBtn = target.closest('.playlist-edit-btn'); // 表示/編集ボタン
     const deleteBtn = target.closest('.playlist-delete-btn'); // 削除ボタン

     // ★どのボタンが特定されたかログ出力
     console.log(`[DEBUG] UserPlaylists: Buttons found - playBtn: ${!!playBtn}, editBtn: ${!!editBtn}, deleteBtn: ${!!deleteBtn}`);

     if (playBtn) { // 現在は通らないはず
         event.stopPropagation();
         console.log("[DEBUG] UserPlaylists: Play button path. Calling playPlaylist...");
         playPlaylist(playlistId);
     } else if (editBtn) { // ★目のアイコンクリック時にここを通るはず
         event.stopPropagation();
         console.log("[DEBUG] UserPlaylists: Edit/View button path. Calling viewPlaylist...");
         viewPlaylist(playlistId);
     } else if (deleteBtn) { // ★ゴミ箱アイコンクリック時にここを通るはず
         event.stopPropagation();
         console.log("[DEBUG] UserPlaylists: Delete button path. Calling deletePlaylist...");
         deletePlaylist(playlistId);
     } else { // ★項目自体（ボタン以外）のクリック時にここを通るはず
         console.log("[DEBUG] UserPlaylists: Item itself clicked. Calling viewPlaylist...");
         viewPlaylist(playlistId); // 項目自体のクリックでも viewPlaylist を呼ぶ
     }
}

      function handlePlaylistDetailClick(event) {
          const target = event.target;
          const playlistItem = target.closest('.playlist-item');
          if (!playlistItem) return;

          const songId = playlistItem.dataset.id;
          const favoriteBtn = target.closest('.favorite-btn');
          const checkbox = target.closest('.song-select');

          if (favoriteBtn) {
              event.stopPropagation();
              toggleFavorite(songId);
          } else if (checkbox) {
              event.stopPropagation(); // Allow checkbox default behavior, don't play song
          } else { // Clicked on the item to play
              const originalIndex = findSongIndexById(songId);
              if (originalIndex !== -1) {
                  playSong(originalIndex);
                  hideModal('playlistDetail');
              } else {
                  showSnackbar("曲が見つかりませんでした。");
              }
          }
      }


    // Helper to toggle playlist dropdown visibility
    function togglePlaylistDropdown(buttonElement) {
        if(!buttonElement) return;
        const dropdownContainer = buttonElement.closest('.dropdown'); // Find parent dropdown container
        if (!dropdownContainer) return;
        const dropdownMenu = dropdownContainer.querySelector('.dropdown-menu');
        if (!dropdownMenu) return;

        const isHidden = dropdownMenu.classList.contains('hidden');
        closeAllPlaylistDropdowns(); // Close others first
        if (isHidden) {
            dropdownMenu.classList.remove('hidden');
             // Focus the first item in the dropdown for accessibility
             const firstLink = dropdownMenu.querySelector('a');
             firstLink?.focus();
        }
        // If it was open, closeAllPlaylistDropdowns already handled it
    }

    // Helper to close all open playlist dropdowns
    function closeAllPlaylistDropdowns(exceptButton = null) {
        document.querySelectorAll('.dropdown-menu').forEach(d => {
             // Don't close the one belonging to the button just clicked (if applicable)
             const parentDropdown = d.closest('.dropdown');
             const triggerButton = parentDropdown?.querySelector('.add-to-playlist-btn');
             if (triggerButton !== exceptButton) {
                 d.classList.add('hidden');
             }
        });
    }

    // Global click listener to close dropdowns
    document.addEventListener('click', (e) => {
        // Close dropdown if click is outside any element with class 'dropdown'
        if (!e.target.closest('.dropdown')) {
            closeAllPlaylistDropdowns();
        }
    }, true); // Use capture phase


    // ==========================================================================
    // Render UI Functions
    // ==========================================================================
    function renderPlaylist() {
      const items = appState.filteredSongs;
      const container = elements.playlist;
      if (!container) return;

      if (!items || items.length === 0) {
          let message = "曲が見つかりません";
          if(elements.searchInput?.value) message = "検索結果はありません";
          else message = "楽曲リストは空です";
          showEmptyMessage(container, message);
          return;
      }
      // Render using the generic function
        renderList(
            container,
            items,
            'playlist-item',
            (song) => `data-id="${song.id}"`, // Identify by song ID
            true // Show actions (fav, add to playlist)
        );
        updateActiveListItem(); // Highlight after rendering
    }


    function renderHistoryList() {
        if (!elements.historyList) return;
        const itemsToRender = [...appState.history].reverse(); // Newest first
        renderList(
            elements.historyList,
            itemsToRender,
            'history-item',
            (song) => `data-id="${song.id}"`,
            true // Show actions (fav, add to playlist)
        );
        updateActiveListItem(); // Highlight if current song is in history
    }

    function renderFavoritesList() {
        if (!elements.favoritesList) return;
        renderList(
            elements.favoritesList,
            appState.favorites,
            'favorite-item',
            (song) => `data-id="${song.id}"`,
            true // Show actions (un-fav, add to playlist)
        );
        updateActiveListItem(); // Highlight if current song is a favorite
    }

    // Generic list rendering function (Refined)
    function renderList(container, items, itemClass, dataAttributeFn, showActions) {
        if (!container) return;

        const fragment = document.createDocumentFragment();
        const currentSongId = appState.currentSongIndex !== -1 && appState.songs[appState.currentSongIndex]
                              ? appState.songs[appState.currentSongIndex].id
                              : null;

        if (!items || items.length === 0) {
            let message = "アイテムが見つかりません";
            if (container === elements.historyList) message = "再生履歴はありません";
            else if (container === elements.favoritesList) message = "お気に入りに登録された曲はありません";
            else if (container === elements.playlist && elements.searchInput?.value) message = "検索結果はありません";
            else if (container === elements.playlist) message = "楽曲リストは空です"; // Default for main list if empty
            showEmptyMessage(container, message);
            return;
        }

        items.forEach((song, index) => {
            if (!song || !song.id) {
                console.warn("Invalid song data in list:", song);
                return; // Skip invalid entries
            }
            const isActive = song.id === currentSongId;
            const isFavorite = appState.favorites.some(fav => fav && fav.id === song.id);
            const canAddToPlaylist = appState.loggedInUser && appState.userPlaylists.length > 0;

            const div = document.createElement('div');
            div.className = `${itemClass} p-3 flex items-center justify-between cursor-pointer ${isActive ? 'active' : ''} focusable`; // Added focusable
            div.tabIndex = 0; // Make item focusable

            const attr = dataAttributeFn(song, index);
            if (typeof attr === 'string' && attr.includes('=')) {
                const [key, value] = attr.split('=');
                div.dataset[key.replace('data-', '')] = value.replace(/"/g, ''); // Set dataset property
            } else {
                console.warn("Invalid data attribute format from dataAttributeFn");
            }

             // Keyboard activation for list items
             div.addEventListener('keydown', (e) => {
                 if (e.key === 'Enter' || e.key === ' ') {
                     e.preventDefault();
                     const songId = div.dataset.id;
                     const originalIndex = findSongIndexById(songId);
                     if (originalIndex !== -1) playSong(originalIndex);
                 }
             });

            let playlistActionsHTML = '';
            if (showActions) {
                playlistActionsHTML = `
                    <button class="favorite-btn text-lg mr-2 focusable" data-id="${song.id}" aria-label="${isFavorite ? 'お気に入り解除' : 'お気に入り登録'}">
                        <i class="fas fa-heart ${isFavorite ? 'text-red-500' : 'text-gray-400'}"></i>
                    </button>
                    ${appState.loggedInUser ? `
                    <div class="dropdown relative inline-block">
                        <button class="add-to-playlist-btn text-lg mr-2 focusable ${canAddToPlaylist ? '' : 'opacity-50 cursor-not-allowed'}" data-id="${song.id}" ${canAddToPlaylist ? '' : 'disabled aria-disabled="true"'} aria-label="プレイリストに追加">
                            <i class="fas fa-plus"></i>
                        </button>
                        ${canAddToPlaylist ? `
                        <div class="dropdown-menu absolute right-0 mt-2 w-48 rounded-md shadow-lg hidden z-20" style="background-color: var(--card-color); border: 1px solid var(--border-color);">
                            <div class="py-1 max-h-32 overflow-y-auto">
                                ${appState.userPlaylists.map(playlist => `
                                    <a href="#" class="block px-4 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-700 select-playlist focusable" data-id="${song.id}" data-playlistid="${playlist.id}">
                                        ${escapeHTML(playlist.name)} <span class="playlist-count">${playlist.songs?.length ?? 0}</span>
                                    </a>
                                `).join('')}
                            </div>
                        </div>
                        ` : ''}
                    </div>
                    ` : ''}
                `;
            }

            div.innerHTML = `
                <div class="flex items-center overflow-hidden mr-2 flex-grow min-w-0">
                    <div class="w-10 h-10 rounded overflow-hidden mr-3 flex-shrink-0">
                        <img src="${song.thumbnail || ''}" alt="${escapeHTML(song.title)}" class="w-full h-full object-cover" loading="lazy">
                    </div>
                    <div class="flex-grow overflow-hidden min-w-0">
                        <h3 class="text-sm font-medium truncate">${escapeHTML(song.title)}</h3>
                    </div>
                </div>
                ${showActions ? `<div class="flex items-center flex-shrink-0 ml-2">${playlistActionsHTML}</div>` : ''}
            `;
            fragment.appendChild(div);
        });

        container.innerHTML = ''; // Clear previous content
        container.appendChild(fragment);
    }

    function renderUserPlaylists() {
      const container = elements.userPlaylistsList;
      if (!container) return;

      const fragment = document.createDocumentFragment();

      if (appState.userPlaylists.length === 0) {
        showEmptyMessage(container, "マイプレイリストはありません");
        return;
      }

      appState.userPlaylists.forEach(playlist => {
        const div = document.createElement('div');
        div.className = 'user-playlist-item p-3 flex items-center justify-between cursor-pointer focusable'; // Added focusable
        div.dataset.id = playlist.id;
        div.tabIndex = 0; // Make item focusable

         div.addEventListener('keydown', (e) => { // Keyboard activation
             if (e.key === 'Enter' || e.key === ' ') {
                 e.preventDefault();
                 viewPlaylist(playlist.id); // Default action is view
             }
         });

        div.innerHTML = `
          <span class="font-medium truncate mr-2 flex-grow">${escapeHTML(playlist.name)} <span class="playlist-count">${playlist.songs?.length ?? 0}</span></span>
          <div class="user-playlist-actions flex-shrink-0 flex items-center gap-2">
             <!-- Play button (Optional) -->
             <!-- <button class="playlist-play-btn text-lg focusable" data-id="${playlist.id}" aria-label="${escapeHTML(playlist.name)} を再生"><i class="fas fa-play"></i></button> -->
             <!-- Edit/View Button -->
             <button class="playlist-edit-btn text-lg focusable" data-id="${playlist.id}" aria-label="${escapeHTML(playlist.name)} を表示/編集"><i class="fas fa-eye"></i></button>
             <!-- Delete Button -->
             <button class="playlist-delete-btn text-sm text-red-500 hover:text-red-700 dark:hover:text-red-400 focusable" data-id="${playlist.id}" aria-label="${escapeHTML(playlist.name)} を削除">
                 <i class="fas fa-trash"></i>
             </button>
          </div>
        `;
        fragment.appendChild(div);
      });

      container.innerHTML = '';
      container.appendChild(fragment);
    }


    function renderPlaylistDetail(playlist) {
        console.log(`[DEBUG] renderPlaylistDetail started for playlist ID: ${playlist?.id}`); // 関数開始ログ

        // --- ガード節: 楽曲リストのロード確認 ---
        if (!appState.songs || appState.songs.length === 0) {
            showSnackbar("楽曲リストの読み込みが完了していません。");
            console.warn("[DEBUG] renderPlaylistDetail called before appState.songs was populated.");
            const container = elements.playlistElements.detailContent;
            if (container) showEmptyMessage(container, "楽曲リストを読み込み中です...");
            return;
        }

        const container = elements.playlistElements.detailContent;
        const titleEl = elements.playlistElements.detailTitle;
        const removeBtn = elements.modalButtons.removeFromPlaylist;

        if (!container || !titleEl || !removeBtn) {
            console.error("[DEBUG] Playlist detail modal elements not found.");
            // エラーメッセージをモーダル内に表示する試み
            if(titleEl) titleEl.textContent = "表示エラー";
            if(container) container.innerHTML = `<p class="text-red-500 text-center py-4">詳細表示に必要な要素が見つかりません。</p>`;
            return;
        }

        if (!playlist || !playlist.id) {
            console.error("[DEBUG] Invalid playlist object passed to renderPlaylistDetail:", playlist);
            titleEl.textContent = "プレイリストエラー";
            container.innerHTML = `<p class="text-red-500 text-center py-4">プレイリストの情報の取得に失敗しました。</p>`;
            removeBtn.classList.add('hidden');
            return;
        }

        titleEl.textContent = escapeHTML(playlist.name);

        // --- ★★★ 修正点: 正しい方法で再生中IDを取得 ★★★ ---
        const currentlyPlayingSongId = currentSongId(); // ヘルパー関数を正しく呼び出す
        console.log("[DEBUG] renderPlaylistDetail: Currently playing song ID:", currentlyPlayingSongId);

        const songsInPlaylist = (playlist.songs || [])
                                .map(songId => {
                                    // console.log(`[DEBUG] Finding song for ID: ${songId}`); // 必要なら詳細ログ追加
                                    const foundSong = appState.songs.find(s => s && s.id === songId);
                                    // if (!foundSong) console.warn(`[DEBUG] Song with ID ${songId} not found in appState.songs`);
                                    return foundSong;
                                })
                                .filter(song => song); // null/undefinedを除外

        console.log(`[DEBUG] renderPlaylistDetail: Found ${songsInPlaylist.length} songs for playlist ${playlist.id}`);

        const fragment = document.createDocumentFragment();

        if (songsInPlaylist.length === 0) {
            showEmptyMessage(container, "このプレイリストには曲が追加されていません");
            removeBtn.classList.add('hidden');
            return;
        }

        songsInPlaylist.forEach(song => {
            const isFavorite = appState.favorites.some(fav => fav && fav.id === song.id);
            // --- ★★★ 修正点: 正しい再生中IDで比較 ★★★ ---
            const isActive = song.id === currentlyPlayingSongId;
            const div = document.createElement('div');
            // focusable をアイテム自体に適用、checkbox にも別途適用
            div.className = `playlist-item p-3 flex items-center justify-between cursor-pointer ${isActive ? 'active' : ''} focusable`;
            div.dataset.id = song.id;
            div.tabIndex = 0; // アイテムをフォーカス可能に

            div.addEventListener('keydown', (e) => { // キーボードでの操作
                 if (e.key === 'Enter' || e.key === ' ') {
                    // チェックボックス自体がターゲットでない場合のみ再生
                    if (!e.target.classList.contains('song-select')) {
                        e.preventDefault();
                        const songId = div.dataset.id;
                        const originalIndex = findSongIndexById(songId);
                        if (originalIndex !== -1) {
                             playSong(originalIndex);
                             hideModal('playlistDetail'); // 再生後にモーダルを閉じる
                        } else {
                             showSnackbar("曲が見つかりませんでした。");
                        }
                    }
                 }
             });

            div.innerHTML = `
                <div class="flex items-center overflow-hidden mr-2 flex-grow min-w-0">
                    <input type="checkbox" class="song-select mr-3 flex-shrink-0 focusable" data-id="${song.id}" aria-label="${escapeHTML(song.title)}を選択">
                    <div class="w-10 h-10 rounded overflow-hidden mr-3 flex-shrink-0">
                        <img src="${song.thumbnail || ''}" alt="${escapeHTML(song.title)}" class="w-full h-full object-cover" loading="lazy">
                    </div>
                    <div class="flex-grow overflow-hidden min-w-0">
                        <h3 class="text-sm font-medium truncate">${escapeHTML(song.title)}</h3>
                    </div>
                </div>
                <div class="flex items-center flex-shrink-0 ml-2">
                    <button class="favorite-btn text-lg mr-2 focusable" data-id="${song.id}" aria-label="${isFavorite ? 'お気に入り解除' : 'お気に入り登録'}">
                        <i class="fas fa-heart ${isFavorite ? 'text-red-500' : 'text-gray-400'}"></i>
                    </button>
                </div>
            `;
            fragment.appendChild(div);
        });

        container.innerHTML = ''; // 既存の内容をクリア
        container.appendChild(fragment); // 新しい内容を追加
        removeBtn.classList.remove('hidden'); // 削除ボタンを表示

        // updateActiveListItem(); // ハイライト更新は不要かも？ モーダル表示時に一度行われるため
        console.log("[DEBUG] renderPlaylistDetail finished rendering.");
    }


    // ==========================================================================
    // Player Control Functions
    // ==========================================================================
    function playSong(originalIndex) {
      // Add a check for elements existence, though should be fine if called after onPlayerReady
      if (!elements.currentSongTitle || !elements.currentSongDuration) {
          console.error("Cannot play song: Title or Duration element not found.");
          return;
      }
      if (!appState.isPlayerReady) {
        showSnackbar("プレイヤーの準備ができていません。");
        return;
      }
      if (originalIndex >= 0 && originalIndex < appState.songs.length) {
        const targetSong = appState.songs[originalIndex];
        if (!targetSong || !targetSong.id) {
          console.error("Invalid song data at index:", originalIndex, targetSong);
          showSnackbar("曲データの読み込みに失敗しました。");
          return;
        }

        appState.currentSongIndex = originalIndex; // Update index only if song is valid
        const cleanVideoId = targetSong.id.trim();

        elements.currentSongTitle.textContent = targetSong.title;
        elements.currentSongDuration.textContent = targetSong.duration || '--:--';

        try {
          if (appState.player && typeof appState.player.loadVideoById === 'function') {
            console.log(`Loading video: ${cleanVideoId} (${targetSong.title})`);
            appState.player.loadVideoById(cleanVideoId);
            // Autoplay handled by onStateChange or explicit play call
            // Keep the setTimeout for playVideo as it might help timing issues
             setTimeout(() => {
                 // Double check player exists before calling playVideo
                 if(appState.player && typeof appState.player.playVideo === 'function') {
                     try {
                        appState.player.playVideo();
                     } catch(playError) {
                         console.error("Error calling playVideo:", playError);
                         showSnackbar("動画の再生開始に失敗しました。");
                     }
                 } else {
                    console.warn("Player not available when trying to playVideo in setTimeout");
                 }
             }, 150); // Small delay after load command
          } else {
            throw new Error("Player or loadVideoById not available.");
          }
        } catch (error) {
          console.error("Error loading video:", error);
          showSnackbar("動画の読み込みに失敗しました。");
          resetPlayerInfo();
          return;
        }

        updateActiveListItem();
        // Ensure share/open buttons exist before disabling
        if(elements.shareBtn) elements.shareBtn.disabled = true; // Disabled until playing starts
        if(elements.openYouTubeBtn) elements.openYouTubeBtn.disabled = true; // Disabled until playing starts
      } else {
        console.warn("Invalid song index requested:", originalIndex);
      }
    }

    function togglePlayPause() {
        if (!appState.isPlayerReady || !appState.player) {
            showSnackbar("プレイヤーが利用できません。");
            return;
        }
        const currentId = currentSongId();
        if (!currentId) {
            if(appState.songs.length > 0) playSong(0); // Play first song if none selected
            else showSnackbar("再生する曲がありません。");
            return;
        }

        try {
            const playerState = appState.player.getPlayerState();
            if (playerState === YT.PlayerState.PLAYING) {
                appState.player.pauseVideo();
            } else {
                appState.player.playVideo();
            }
        } catch (error) {
            console.error("Error toggling play/pause:", error);
            showSnackbar("再生/一時停止中にエラーが発生しました。");
        }
    }

    function playNextSong() {
        if (appState.songs.length === 0) return;
        let nextIndex;
        const currentIndex = appState.currentSongIndex;

        if (currentIndex === -1) {
            nextIndex = 0; // Play first if nothing was playing
        } else if (appState.isShuffle) {
            if (appState.songs.length <= 1) {
                nextIndex = 0;
            } else {
                 do {
                     nextIndex = Math.floor(Math.random() * appState.songs.length);
                 } while (nextIndex === currentIndex);
            }
        } else {
            nextIndex = (currentIndex + 1) % appState.songs.length;
        }
        playSong(nextIndex);
    }

    function playPreviousSong() {
        if (appState.songs.length === 0) return;
        let prevIndex;
        const currentIndex = appState.currentSongIndex;

        if (currentIndex === -1) {
            prevIndex = 0; // Play first if nothing was playing
            playSong(prevIndex);
            return;
        }

        try {
            // Restart if played for more than 3 seconds
            if (appState.player && typeof appState.player.getCurrentTime === 'function' && appState.player.getCurrentTime() > 3) {
                appState.player.seekTo(0);
                return;
            }
        } catch (error) {
            console.warn("Could not get current time for previous song logic:", error);
        }

        if (appState.isShuffle) {
             if (appState.songs.length <= 1) {
                 prevIndex = 0;
             } else {
                  do {
                      prevIndex = Math.floor(Math.random() * appState.songs.length);
                  } while (prevIndex === currentIndex);
             }
        } else {
             prevIndex = currentIndex - 1;
             if (prevIndex < 0) {
                 prevIndex = appState.songs.length - 1; // Loop to end
             }
        }
        playSong(prevIndex);
    }

    function handleSongEnd() {
        console.log("Song ended. Loop mode:", appState.loopMode);
        switch (appState.loopMode) {
            case 'one':
                if(appState.player && typeof appState.player.seekTo === 'function') {
                    try { appState.player.seekTo(0); appState.player.playVideo(); } catch(e){ playNextSong(); }
                } else { playNextSong(); }
                break;
            case 'all':
                playNextSong();
                break;
            case 'none':
            default:
                // Play next unless it's the absolute last song in non-shuffle mode
                if (!appState.isShuffle && appState.currentSongIndex === appState.songs.length - 1) {
                     // Stop or pause? Let's pause and reset time.
                     if(appState.player && typeof appState.player.pauseVideo === 'function') {
                        try {
                            appState.player.pauseVideo();
                            appState.player.seekTo(0);
                        } catch(e){ console.warn("Error pausing/seeking at end:", e)}
                     }
                     // UI updates handled by PAUSED state change in onPlayerStateChange
                } else {
                    playNextSong();
                }
                break;
        }
    }

    function toggleShuffle() {
      appState.isShuffle = !appState.isShuffle;
      const isActive = appState.isShuffle;
      // Update Desktop Button
      elements.btnShuffle?.classList.toggle('btn-active', isActive);
      elements.btnShuffle?.classList.toggle('btn-inactive', !isActive);
      elements.btnShuffle?.setAttribute('aria-pressed', isActive);
       // Update Mobile Button
       elements.btnShuffleMobile?.classList.toggle('btn-active', isActive);
       elements.btnShuffleMobile?.classList.toggle('btn-inactive', !isActive);
       elements.btnShuffleMobile?.setAttribute('aria-pressed', isActive);

      showSnackbar(`シャッフル: ${isActive ? 'オン' : 'オフ'}`);
    }

    function toggleLoopMode() {
      let loopIconHTML = '';
      let loopLabel = '';
      let isActive = true;

      switch (appState.loopMode) {
        case 'none':
          appState.loopMode = 'all';
          loopIconHTML = '<i class="fas fa-repeat"></i>';
          loopLabel = 'リピート: 全曲';
          break;
        case 'all':
          appState.loopMode = 'one';
          loopIconHTML = '<i class="fas fa-1" style="font-size: 0.8em; position: relative; top: -0.1em; margin-left: -0.2em;"></i><i class="fas fa-repeat"></i>';
          loopLabel = 'リピート: 1曲';
          break;
        case 'one':
        default: // Fallback to 'none'
          appState.loopMode = 'none';
          loopIconHTML = '<i class="fas fa-repeat"></i>';
          loopLabel = 'リピート: オフ';
          isActive = false;
          break;
      }

        // Update Desktop Button
        if (elements.btnLoop) {
            elements.btnLoop.innerHTML = loopIconHTML;
            elements.btnLoop.classList.toggle('btn-active', isActive);
            elements.btnLoop.classList.toggle('btn-inactive', !isActive);
            elements.btnLoop.setAttribute('aria-label', loopLabel);
        }
        // Update Mobile Button
        if (elements.btnLoopMobile) {
            elements.btnLoopMobile.innerHTML = loopIconHTML;
            elements.btnLoopMobile.classList.toggle('btn-active', isActive);
            elements.btnLoopMobile.classList.toggle('btn-inactive', !isActive);
            elements.btnLoopMobile.setAttribute('aria-label', loopLabel);
        }

      showSnackbar(loopLabel);
    }

    function handleVolumeChange() {
        if(!elements.volumeSlider) return;
        const volume = parseInt(elements.volumeSlider.value);
        setVolume(volume);
    }

     function setVolume(volume) {
         volume = Math.max(0, Math.min(100, volume)); // Clamp
         appState.volume = volume;
         if(elements.volumeSlider) elements.volumeSlider.value = volume;
         if (appState.isPlayerReady && appState.player && typeof appState.player.setVolume === 'function') {
              try { appState.player.setVolume(volume); } catch (e) { console.error("Error setting volume:", e); }
         }
     }

    function adjustVolume(delta) {
        setVolume(appState.volume + delta);
    }

    function seekToPosition(event) {
        if (!appState.isPlayerReady || !currentSongId() || !elements.progressContainer || !appState.player) return;

        // Use pageX for broader compatibility, adjust for container offset
        const rect = elements.progressContainer.getBoundingClientRect();
        const clickX = event.pageX - rect.left - window.scrollX; // Calculate click relative to container start

        // Ensure click is within bounds (0 to rect.width)
        const clampedX = Math.max(0, Math.min(clickX, rect.width));

        if (rect.width <= 0) return; // Avoid division by zero

        const percent = clampedX / rect.width;

        try {
            const duration = appState.player.getDuration();
            if (duration > 0) {
                const seekTime = duration * percent;
                appState.player.seekTo(seekTime, true);
                updateProgress(); // Update UI immediately
            }
        } catch (error) {
            console.error("Error seeking:", error);
            showSnackbar("シーク中にエラーが発生しました。");
        }
    }

     function seekRelative(deltaSeconds) {
         if (!appState.isPlayerReady || !currentSongId() || !appState.player) return;
         try {
             const currentTime = appState.player.getCurrentTime();
             const duration = appState.player.getDuration();
             if (duration > 0) {
                 let seekTime = currentTime + deltaSeconds;
                 seekTime = Math.max(0, Math.min(seekTime, duration)); // Clamp
                 appState.player.seekTo(seekTime, true);
                 updateProgress();
             }
         } catch (error) {
             console.error("Error seeking relative:", error);
         }
     }

    function startProgressUpdate() {
      stopProgressUpdate(); // Clear existing interval
      if (!appState.progressInterval) { // Ensure only one interval runs
           appState.progressInterval = setInterval(updateProgress, 500);
      }
      updateProgress(); // Initial update
    }

    function stopProgressUpdate() {
      if (appState.progressInterval) {
        clearInterval(appState.progressInterval);
        appState.progressInterval = null;
      }
    }

    function updateProgress() {
        const progressBar = elements.progressBar;
        const currentTimeEl = elements.currentTime;
        const totalTimeEl = elements.totalTime;

        if (!progressBar || !currentTimeEl || !totalTimeEl) return; // Check elements exist

        const song = currentSongData(); // Get current song data if available

        if (!appState.isPlayerReady || !appState.player || typeof appState.player.getCurrentTime !== 'function' || !song) {
            // Reset progress if player not ready or no song selected
            if (progressBar.style.width !== '0%') progressBar.style.width = '0%';
            currentTimeEl.textContent = '00:00';
            // Use song duration from appState if available, otherwise '00:00'
            totalTimeEl.textContent = song?.duration && song.duration !== '--:--' ? song.duration : '00:00';
             if(elements.currentSongDuration) {
                 elements.currentSongDuration.textContent = song?.duration || '--:--';
             }
            return;
        }

        try {
            const currentTime = appState.player.getCurrentTime();
            const duration = appState.player.getDuration();

            if (typeof currentTime === 'number' && typeof duration === 'number' && duration > 0) {
                const percent = Math.min(100, Math.max(0, (currentTime / duration) * 100));
                if (!isNaN(percent)) {
                    progressBar.style.width = `${percent}%`;
                } else {
                    if (progressBar.style.width !== '0%') progressBar.style.width = '0%';
                }
                currentTimeEl.textContent = formatTime(currentTime);
                const formattedDuration = formatTime(duration);
                 // Update total time only if it differs or if the known song duration was '--:--'
                if (totalTimeEl.textContent !== formattedDuration || (song && song.duration === '--:--')) {
                     totalTimeEl.textContent = formattedDuration;
                     // Also update the duration displayed under the title
                     if(elements.currentSongDuration) elements.currentSongDuration.textContent = formattedDuration;
                     // Update the duration in the appState.songs array if it was initially unknown
                     if (song && song.duration === '--:--') {
                         song.duration = formattedDuration;
                         // Optional: Re-render the list containing this song to show the updated duration?
                         // This could be expensive, maybe update only the specific item if needed later.
                     }
                }
            } else {
                // Handle cases where times might be 0 or invalid initially
                 if (progressBar.style.width !== '0%') progressBar.style.width = '0%';
                 currentTimeEl.textContent = '00:00';
                 // Use known song duration if available
                 const knownDuration = song?.duration && song.duration !== '--:--' ? song.duration : '00:00';
                 if(totalTimeEl.textContent !== knownDuration) totalTimeEl.textContent = knownDuration;
                 if(elements.currentSongDuration && elements.currentSongDuration.textContent !== (song?.duration || '--:--')) {
                      elements.currentSongDuration.textContent = song?.duration || '--:--';
                 }
            }
        } catch (error) {
            console.error("Error updating progress:", error);
             if (progressBar.style.width !== '0%') progressBar.style.width = '0%';
             currentTimeEl.textContent = '00:00';
             totalTimeEl.textContent = '00:00';
             if(elements.currentSongDuration) elements.currentSongDuration.textContent = '--:--';
        }
    }

     function resetPlayerInfo() {
         if(elements.currentSongTitle) elements.currentSongTitle.textContent = "選択された曲はありません";
         if(elements.currentSongDuration) elements.currentSongDuration.textContent = "--:--";
         if(elements.progressBar) elements.progressBar.style.width = '0%';
         if(elements.currentTime) elements.currentTime.textContent = "00:00";
         if(elements.totalTime) elements.totalTime.textContent = "00:00";
         if(elements.shareBtn) elements.shareBtn.disabled = true;
         if(elements.openYouTubeBtn) elements.openYouTubeBtn.disabled = true;
         if(elements.nowPlayingBadge) elements.nowPlayingBadge.classList.add('hidden');
         updateActiveListItem(); // Clear highlights
     }

    // ==========================================================================
    // Playlist Functions
    // ==========================================================================
    function showCreatePlaylistModal() {
      if (!appState.loggedInUser) {
        showAccountModal(); // Prompt login first
        showSnackbar('プレイリスト作成にはログインが必要です');
        return;
      }
      if(elements.playlistElements.nameInput) elements.playlistElements.nameInput.value = '';
      // Show modal and focus on input
      showModal('createPlaylist', elements.playlistElements.nameInput);
    }

    function saveNewPlaylist() {
      if(!elements.playlistElements.nameInput) return;
      const name = elements.playlistElements.nameInput.value.trim();
      if (!name) {
        showSnackbar('プレイリスト名を入力してください');
        elements.playlistElements.nameInput.focus();
        return;
      }
      const newPlaylist = {
        id: `pl_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`,
        name: name,
        songs: [],
        created: new Date().toISOString()
      };
      appState.userPlaylists.push(newPlaylist);
      saveUserPlaylists();
      renderUserPlaylists(); // Update the "My Playlists" tab
      // Re-render other lists to update "Add to Playlist" dropdowns/buttons
      renderPlaylist();
      renderHistoryList();
      renderFavoritesList();
      hideModal('createPlaylist');
      showSnackbar(`プレイリスト「${escapeHTML(name)}」を作成しました`);
    }

    function deletePlaylist(playlistId) {
        const playlistIndex = appState.userPlaylists.findIndex(p => p && p.id === playlistId);
        if (playlistIndex === -1) return;

        const playlist = appState.userPlaylists[playlistIndex];
        if (confirm(`プレイリスト「${escapeHTML(playlist.name)}」を削除してもよろしいですか？`)) {
            appState.userPlaylists.splice(playlistIndex, 1);
            saveUserPlaylists();
            renderUserPlaylists();
            // Re-render other lists to update dropdowns
            renderPlaylist();
            renderHistoryList();
            renderFavoritesList();

            // If the deleted playlist detail was open, close it
            if (appState.currentSelectedPlaylistId === playlistId) {
                hideModal('playlistDetail');
                appState.currentSelectedPlaylistId = null;
            }
            showSnackbar(`プレイリスト「${escapeHTML(playlist.name)}」を削除しました`);
        }
    }

    function addSongToPlaylist(songId, playlistId) {
      const playlist = appState.userPlaylists.find(p => p && p.id === playlistId);
      const song = findSongById(songId); // Use helper

      if (!playlist || !song) {
           console.error("Playlist or Song not found for adding:", playlistId, songId);
           showSnackbar("プレイリストまたは曲が見つかりません。");
           return;
      }
      if (!playlist.songs) playlist.songs = []; // Ensure songs array exists

      if (!playlist.songs.includes(songId)) {
        playlist.songs.push(songId);
        saveUserPlaylists();
        renderUserPlaylists(); // Update counts in the main "My Playlists" list
        // If the detail view for this playlist is currently open, refresh it
        if (appState.currentSelectedPlaylistId === playlistId && elements.modals.playlistDetail?.classList.contains('show')) {
             renderPlaylistDetail(playlist);
        }
         // Update dropdowns/buttons in other lists by re-rendering them
         renderPlaylist();
         renderHistoryList();
         renderFavoritesList();
         showSnackbar(`「${escapeHTML(song.title)}」を「${escapeHTML(playlist.name)}」に追加しました`);
      } else {
        showSnackbar(`「${escapeHTML(song.title)}」は既に「${escapeHTML(playlist.name)}」に存在します`);
      }
       closeAllPlaylistDropdowns(); // Close dropdown after action
    }

    function viewPlaylist(playlistId) {
  console.log(`[DEBUG] viewPlaylist called for ID: ${playlistId}`); // ★関数開始を確認
  if (!appState.songs || appState.songs.length === 0) {
      showSnackbar("楽曲リストの読み込みが完了していません。");
      console.warn("[DEBUG] viewPlaylist called before appState.songs was populated.");
      return; // ★早期リターンした場合
  }

  const playlist = appState.userPlaylists.find(p => p && p.id === playlistId);
  if (!playlist) {
      showSnackbar("プレイリストが見つかりません。");
      console.error(`[DEBUG] viewPlaylist: Playlist not found for ID: ${playlistId}`);
      return; // ★プレイリストが見つからない場合
  }
  console.log("[DEBUG] viewPlaylist: Found playlist:", playlist);
  appState.currentSelectedPlaylistId = playlistId; // IDを保持
  console.log("[DEBUG] viewPlaylist: Calling renderPlaylistDetail...");
  renderPlaylistDetail(playlist); // 詳細レンダリング呼び出し
  console.log("[DEBUG] viewPlaylist: Calling showModal('playlistDetail')...");
  showModal('playlistDetail'); // モーダル表示呼び出し
  console.log("[DEBUG] viewPlaylist finished."); // ★関数終了を確認
}

    function removeSongFromPlaylist() {
      const playlistId = appState.currentSelectedPlaylistId;
      const playlist = appState.userPlaylists.find(p => p && p.id === playlistId);
      if (!playlist || !playlist.songs || !elements.playlistElements.detailContent) return;

      const selectedCheckboxes = elements.playlistElements.detailContent.querySelectorAll('.song-select:checked');
      const selectedSongIds = Array.from(selectedCheckboxes).map(el => el.dataset.id);

      if (selectedSongIds.length === 0) {
        showSnackbar('削除する曲を選択してください');
        return;
      }

      const initialLength = playlist.songs.length;
      playlist.songs = playlist.songs.filter(songId => !selectedSongIds.includes(songId));
      const removedCount = initialLength - playlist.songs.length;

      if (removedCount > 0) {
           saveUserPlaylists();
           renderUserPlaylists(); // Update counts in the main list
           renderPlaylistDetail(playlist); // Re-render the detail view
           showSnackbar(`${removedCount}曲をプレイリストから削除しました`);
      }
    }

    function sharePlaylist() {
        const playlistId = appState.currentSelectedPlaylistId;
        const playlist = appState.userPlaylists.find(p => p && p.id === playlistId);
        if (!playlist || !elements.playlistElements.shareLinkInput || !elements.playlistElements.shareObjectTitle) {
            showSnackbar("共有するプレイリストが見つかりません。");
            return;
        }

        const shareLink = `${window.location.origin}${window.location.pathname}?sharedPlaylistId=${playlistId}`;
        const shareTitle = `プレイリスト: ${escapeHTML(playlist.name)}`;

        elements.playlistElements.shareLinkInput.value = shareLink;
        elements.playlistElements.shareObjectTitle.textContent = shareTitle;
        hideModal('playlistDetail'); // Close detail modal first
        showModal('share'); // Show the generic share modal
    }

    // ==========================================================================
    // Share Functions
    // ==========================================================================
    function showShareModal() {
        const song = currentSongData(); // Use helper

        if (!song) {
            showSnackbar('共有する曲を再生してください');
            return;
        }

        const shareLink = `https://www.youtube.com/watch?v=${song.id}`;
        const shareTitle = `曲: ${escapeHTML(song.title)}`;

        if(!elements.playlistElements.shareLinkInput || !elements.playlistElements.shareObjectTitle || !elements.modals.share) {
             console.error("Share modal elements missing.");
             return;
        }

        elements.playlistElements.shareLinkInput.value = shareLink;
        elements.playlistElements.shareObjectTitle.textContent = shareTitle;

        // Setup social media share buttons
        const encodedLink = encodeURIComponent(shareLink);
        const encodedTitle = encodeURIComponent(`${shareTitle} - Rei Kikuchi Premium Player`); // Add context

        const twitterBtn = elements.modals.share.querySelector('button[style*="1DA1F2"]');
        if (twitterBtn) twitterBtn.onclick = () => window.open(`https://twitter.com/intent/tweet?text=${encodedTitle}&url=${encodedLink}`, '_blank');

        const facebookBtn = elements.modals.share.querySelector('button[style*="4267B2"]');
        if (facebookBtn) facebookBtn.onclick = () => window.open(`https://www.facebook.com/sharer/sharer.php?u=${encodedLink}`, '_blank');

        showModal('share', elements.modalButtons.copyLink); // Focus copy button initially
    }

    function copyShareLink() {
      const shareLinkInput = elements.playlistElements.shareLinkInput;
      if (!shareLinkInput || !shareLinkInput.value) {
          showSnackbar('コピーするリンクがありません。');
          return;
      }

      navigator.clipboard.writeText(shareLinkInput.value).then(() => {
          showSnackbar('リンクをクリップボードにコピーしました');
      }).catch(err => {
          console.warn('Clipboard API copy failed, trying fallback: ', err);
          try {
              shareLinkInput.select();
              shareLinkInput.setSelectionRange(0, 99999); // For mobile
              const successful = document.execCommand('copy');
              if (successful) showSnackbar('リンクをクリップボードにコピーしました');
              else showSnackbar('リンクのコピーに失敗しました');
          } catch (errFallback) {
              console.error('Fallback copy failed: ', errFallback);
              showSnackbar('リンクのコピーに失敗しました');
          }
          window.getSelection()?.removeAllRanges(); // Deselect
      });
    }

    // ==========================================================================
    // "Open on YouTube" Function
    // ==========================================================================
    function handleOpenYouTube() {
      const song = currentSongData(); // Use helper
      if (!song) {
          showSnackbar('再生中の曲がありません。');
          return;
      }
      const youtubeUrl = `https://www.youtube.com/watch?v=${song.id}`;
      window.open(youtubeUrl, '_blank');
    }

    // ==========================================================================
    // Account Functions
    // ==========================================================================
    function showAccountModal() {
      console.log("showAccountModal called. Current user:", appState.loggedInUser);
      const isLoggedIn = !!appState.loggedInUser;

      // 1. Update account button appearance immediately
      updateAccountUI(isLoggedIn);

      // 2. Determine which section to show and switch *before* showing modal
      if (isLoggedIn) {
        console.log("User is logged in. Switching to account info section.");
        switchAuthSection('accountInfo');
      } else {
        console.log("User is not logged in. Switching to login section.");
        switchAuthSection('login');
      }

      // 3. Show the modal container
      console.log("Showing account modal container.");
      showModal('account'); // Show the actual modal element
    }

    function switchAuthSection(section) {
      console.log("Attempting to switch auth section to:", section);
      if(!elements.accountSections) {
          console.error("elements.accountSections is not defined!");
          return;
      }
      // Hide all sections first
      Object.values(elements.accountSections).forEach(el => {
          if(el) el.classList.add('hidden');
      });

      // Show the target section
      const sectionToShow = elements.accountSections[section];
      if (sectionToShow) {
        sectionToShow.classList.remove('hidden');
        console.log(`Section '${section}' should now be visible.`);

        // Focus on the first focusable element in the newly shown section
        const firstFocusable = sectionToShow.querySelector('button, [href], input:not([type="hidden"]), select, textarea, [tabindex]:not([tabindex="-1"])');
        if (firstFocusable) {
           // Delay focus slightly to ensure element is fully visible after class change
           setTimeout(() => firstFocusable.focus(), 50);
        }
      } else {
        console.error("Invalid section requested in switchAuthSection:", section);
      }
    }

     function showLoadingState(button, isLoading) {
         if (!button) return;
         button.disabled = isLoading;
         if (isLoading) {
             button.innerHTML = '<i class="fas fa-spinner fa-spin"></i>'; // Show spinner
         } else {
             // Restore original button text (needs a way to store/retrieve it)
             // For simplicity, let's assume the text is static for now
             if (button.id === 'login-btn') button.textContent = 'ログイン';
             else if (button.id === 'register-btn') button.textContent = '登録';
             else if (button.id === 'sync-data-btn') button.innerHTML = '<i class="fas fa-sync mr-2"></i> データを同期';
             // Add more cases as needed
         }
     }

    function handleLogin() {
      const emailInput = elements.accountFields.loginEmail;
      const passwordInput = elements.accountFields.loginPassword;
      if(!emailInput || !passwordInput) return false;

      const email = emailInput.value.trim();
      const password = passwordInput.value;

      if (!email || !password) {
          showSnackbar("メールアドレスとパスワードを入力してください。");
          return false;
      }

      console.log("Attempting mock login for:", email);
      showLoadingState(elements.modalButtons.login, true);

      // Simulate server response
      setTimeout(() => {
        const mockUser = { name: "デモユーザー", email: email };
        appState.loggedInUser = mockUser;
        saveToLocalStorage('reiKikuchiPlayerUser', mockUser);
        updateAccountUI(true); // Update UI reflecting logged-in state
        showSnackbar('ログインしました！');
        hideModal('account'); // Close modal on success
        showLoadingState(elements.modalButtons.login, false);
      }, 1000);

      return false; // Prevent potential form submission
    }

    function handleRegister() {
       const nameInput = elements.accountFields.registerName;
       const emailInput = elements.accountFields.registerEmail;
       const passwordInput = elements.accountFields.registerPassword;
       if(!nameInput || !emailInput || !passwordInput) return false;

       const name = nameInput.value.trim();
       const email = emailInput.value.trim();
       const password = passwordInput.value;

       if (!name || !email || !password) { // Add password validation later
           showSnackbar("すべての項目を入力してください。");
           return false;
       }

       console.log("Attempting mock registration for:", name, email);
       showLoadingState(elements.modalButtons.register, true);

       setTimeout(() => {
         const mockUser = { name: name, email: email };
         appState.loggedInUser = mockUser;
         saveToLocalStorage('reiKikuchiPlayerUser', mockUser);
         updateAccountUI(true); // Update UI
         showSnackbar('登録が完了しました。ようこそ！');
         hideModal('account'); // Close modal on success
         showLoadingState(elements.modalButtons.register, false);
       }, 1500);
       return false; // Prevent potential form submission
    }

    function handleLogout() {
        if (confirm("ログアウトしてもよろしいですか？")) {
            appState.loggedInUser = null;
            localStorage.removeItem('reiKikuchiPlayerUser');
            // Optionally clear other local data on logout?
            // appState.history = []; saveToLocalStorage('reiKikuchiPlayerHistory', []);
            // appState.favorites = []; saveToLocalStorage('reiKikuchiPlayerFavorites', []);
            // appState.userPlaylists = []; saveToLocalStorage('reiKikuchiPlayerPlaylists', []);
            updateAccountUI(false); // Update UI to logged-out state
            showSnackbar('ログアウトしました');
            hideModal('account'); // Ensure modal is closed if open
            // Re-render lists that depend on login state (like showing '+' button)
            renderPlaylist();
            renderHistoryList();
            renderFavoritesList();
            renderUserPlaylists();
        }
    }

    // Update Account UI (Refined - focuses only on UI elements affected by login state)
    function updateAccountUI(isLoggedIn) {
      console.log("Updating Account UI elements, loggedIn:", isLoggedIn);

      // Update Header Account Button appearance
      if (elements.modalButtons.account) {
          if (isLoggedIn) {
              elements.modalButtons.account.innerHTML = '<i class="fas fa-user-check"></i>';
              elements.modalButtons.account.classList.remove('btn-inactive');
              elements.modalButtons.account.classList.add('btn-active');
              elements.modalButtons.account.setAttribute('aria-label', 'アカウント (ログイン済み)');
          } else {
              elements.modalButtons.account.innerHTML = '<i class="fas fa-user"></i>';
              elements.modalButtons.account.classList.add('btn-inactive');
              elements.modalButtons.account.classList.remove('btn-active');
              elements.modalButtons.account.setAttribute('aria-label', 'アカウント (未ログイン)');
          }
      }

      // Update User Info fields inside the modal
      if (elements.accountFields.userName && elements.accountFields.userEmail) {
          if (isLoggedIn && appState.loggedInUser) {
              elements.accountFields.userName.textContent = appState.loggedInUser.name;
              elements.accountFields.userEmail.textContent = appState.loggedInUser.email;
          } else {
              elements.accountFields.userName.textContent = ''; // Clear fields if logged out
              elements.accountFields.userEmail.textContent = '';
          }
      }

      // Re-render lists *only if necessary* (e.g., if actions change based on login)
      // If only button states change, a full re-render might be overkill.
      // However, if the "Add to Playlist" button itself is shown/hidden based on login, re-render is needed.
      // Let's keep re-rendering for simplicity for now.
      renderPlaylist();
      renderHistoryList();
      renderFavoritesList();
      renderUserPlaylists();
    }

    function syncUserData() {
        // Placeholder for actual data sync logic
        if (!appState.loggedInUser) {
            showSnackbar("同期するにはログインしてください。");
            showAccountModal(); // Show login prompt
            return;
        }
        console.log("Attempting data sync for user:", appState.loggedInUser.email);
        showLoadingState(elements.modalButtons.syncData, true);
        showSnackbar("データをサーバーと同期中... (デモ)");

        setTimeout(() => {
            showSnackbar('データ同期が完了しました (デモ)');
            showLoadingState(elements.modalButtons.syncData, false);
            // Optionally re-render lists if data could have changed
            // loadUserData(); // Or selectively merge/render
        }, 2000);
    }

    // ==========================================================================
    // Utility Functions
    // ==========================================================================
    // Get current song ID safely
    // Find song by ID safely (Helper Function)
    function findSongById(songId) {
        if (!songId) return null;
        // appState.songs (全曲リスト) から検索する
        return appState.songs.find(song => song && song.id === songId);
    }

    // Helper to update only the favorite button icons for a specific song ID across all lists
    function updateFavoriteButtonsUI(songId) {
        const isFavorite = appState.favorites.some(fav => fav && fav.id === songId);
        // クラス名 'favorite-btn' と data-id 属性でボタンを特定
        const favoriteButtons = document.querySelectorAll(`.favorite-btn[data-id="${songId}"]`);
        favoriteButtons.forEach(button => {
            const icon = button.querySelector('i'); // ボタン内の FontAwesome アイコンを取得
            if (icon) {
                // isFavorite 状態に応じてクラスを切り替え
                icon.classList.toggle('text-red-500', isFavorite); // お気に入りは赤色
                icon.classList.toggle('text-gray-400', !isFavorite); // それ以外はグレー
                // アクセシビリティのために aria-label も更新
                button.setAttribute('aria-label', isFavorite ? 'お気に入り解除' : 'お気に入り登録');
            }
        });
    }

    function currentSongId() {
        return appState.currentSongIndex !== -1 ? appState.songs[appState.currentSongIndex]?.id : null;
    }
    // Get current song data safely
    function currentSongData() {
        return appState.currentSongIndex !== -1 ? appState.songs[appState.currentSongIndex] : null;
    }
    // Find song index by ID safely
    function findSongIndexById(songId) {
        if (!songId) return -1;
        return appState.songs.findIndex(song => song && song.id === songId);
    }


    function formatTime(seconds) {
      if (isNaN(seconds) || seconds < 0) return '00:00';
      seconds = Math.floor(seconds);
      const minutes = Math.floor(seconds / 60);
      const remainingSeconds = seconds % 60;
      return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
    }

    function toggleTheme() {
        if(!elements.body || !elements.themeToggle) return;
        elements.body.classList.toggle('dark');
        const isDark = elements.body.classList.contains('dark');
        elements.themeToggle.innerHTML = isDark ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
        elements.themeToggle.classList.toggle('btn-active', isDark);
        elements.themeToggle.classList.toggle('btn-inactive', !isDark);
        elements.themeToggle.setAttribute('aria-pressed', isDark);
        localStorage.setItem('reiKikuchiPlayerTheme', isDark ? 'dark' : 'light');
        // Redraw visualizer immediately if paused to reflect theme change
        if (!appState.isPlaying && appState.visualizer.canvasCtx && appState.visualizer.canvas) {
             appState.visualizer.canvasCtx.clearRect(0, 0, appState.visualizer.canvas.width, appState.visualizer.canvas.height);
             // Optionally draw a static state for the new theme
        }
    }

    function handleSearch() {
      if(!elements.searchInput) return;
      const searchTerm = elements.searchInput.value.toLowerCase().trim();
      appState.filteredSongs = appState.songs.filter(song =>
          song && song.title.toLowerCase().includes(searchTerm)
      );
      renderPlaylist(); // Re-render the main playlist
      if (appState.currentTab !== 'playlist') {
          switchTab('playlist'); // Switch to playlist tab on search
      }
    }

    function switchTab(tabName) {
        if (appState.currentTab === tabName || !elements.tabs || !elements.tabContents) return;

        appState.currentTab = tabName;
        elements.tabs.forEach(tab => {
            const isSelected = tab.dataset.tab === tabName;
            tab.classList.toggle('active', isSelected);
            tab.setAttribute('aria-selected', isSelected);
             tab.setAttribute('tabindex', isSelected ? '0' : '-1'); // Manage tabindex for focus
        });
        elements.tabContents.forEach(content => {
             if(content) content.classList.toggle('hidden', content.id !== `${tabName}-tab`);
        });
        updateActiveListItem(); // Highlight active song if relevant to the new tab
        console.log("Switched to tab:", tabName);
    }

    function addToHistory(song) {
      if (!song || !song.id) return;
      // Remove existing entry to move to end (most recent)
      appState.history = appState.history.filter(item => item && item.id !== song.id);
      // Add copy to prevent potential mutations if song object is modified elsewhere
      appState.history.push({ ...song });
      // Limit history size
      if (appState.history.length > MAX_HISTORY) {
        appState.history = appState.history.slice(-MAX_HISTORY); // Keep the last MAX_HISTORY items
      }
      saveToLocalStorage('reiKikuchiPlayerHistory', appState.history);
      // History list is rendered when playing starts (onPlayerStateChange) or when tab is switched to
    }

    function toggleFavorite(songId) {
        const songIndexInFavorites = appState.favorites.findIndex(fav => fav && fav.id === songId);
        const song = findSongById(songId); // Use helper

        if (!song) {
            console.warn("Cannot toggle favorite for unknown song ID:", songId);
            return;
        }

        if (songIndexInFavorites > -1) {
            appState.favorites.splice(songIndexInFavorites, 1); // Remove
            showSnackbar(`「${escapeHTML(song.title)}」をお気に入りから削除しました`);
        } else {
            appState.favorites.push({ ...song }); // Add a copy
            showSnackbar(`「${escapeHTML(song.title)}」をお気に入りに追加しました`);
        }
        saveToLocalStorage('reiKikuchiPlayerFavorites', appState.favorites);

        // Update UI (buttons in all lists and potentially the detail modal)
        updateFavoriteButtonsUI(songId); // Update all fav buttons for this song
        renderFavoritesList(); // Re-render the favorites tab content
         // Also re-render other lists as they contain favorite buttons
        renderPlaylist();
        renderHistoryList();
        // Re-render detail modal if open and relevant
        if (appState.currentSelectedPlaylistId && elements.modals.playlistDetail?.classList.contains('show')) {
             const playlist = appState.userPlaylists.find(p => p.id === appState.currentSelectedPlaylistId);
             if(playlist && playlist.songs.includes(songId)) {
                  renderPlaylistDetail(playlist);
             }
        }
    }

    // Helper to update only the favorite button icons for a specific song ID across all lists
    function updateFavoriteButtonsUI(songId) {
        const isFavorite = appState.favorites.some(fav => fav && fav.id === songId);
        const favoriteButtons = document.querySelectorAll(`.favorite-btn[data-id="${songId}"]`);
        favoriteButtons.forEach(button => {
            const icon = button.querySelector('i');
            if (icon) {
                icon.classList.toggle('text-red-500', isFavorite);
                icon.classList.toggle('text-gray-400', !isFavorite);
                button.setAttribute('aria-label', isFavorite ? 'お気に入り解除' : 'お気に入り登録');
            }
        });
    }

    function saveUserPlaylists() {
      saveToLocalStorage('reiKikuchiPlayerPlaylists', appState.userPlaylists);
    }

     function saveToLocalStorage(key, data) {
         try {
             localStorage.setItem(key, JSON.stringify(data));
         } catch (error) {
             console.error("Error saving to localStorage:", key, error);
             showSnackbar("設定の保存中にエラーが発生しました。");
         }
     }

    // --- Modal Management ---
    let lastFocusedElement = null;

    function showModal(modalId, elementToFocusInitially = null) {
      const modal = elements.modals[modalId];
      if (!modal || modal.classList.contains('show')) {
         if (modal && modal.classList.contains('show') && elementToFocusInitially) {
             // If already shown but focus target provided, try to focus
             setTimeout(() => elementToFocusInitially.focus(), 50);
         }
        return; // Don't re-show if already showing
      }

      console.log("Showing modal:", modalId);
      lastFocusedElement = document.activeElement;

      modal.style.display = 'flex';
      void modal.offsetWidth; // Force reflow for transition
      modal.classList.add('show');
      appState.activeModalId = modalId;
      if(elements.body) elements.body.style.overflow = 'hidden'; // Prevent background scroll

      // Focus trap setup
      const focusableElements = Array.from(
          modal.querySelectorAll('button, [href], input:not([type="hidden"]), select, textarea, [tabindex]:not([tabindex="-1"])')
      ).filter(el => el.offsetParent !== null && !el.disabled); // Find visible, enabled elements

      const firstFocusable = focusableElements[0];
      const lastFocusable = focusableElements[focusableElements.length - 1];

      // Remove previous listener before adding new one
      if (modal._keyDownListener) {
          modal.removeEventListener('keydown', modal._keyDownListener);
      }
      modal._keyDownListener = (e) => handleModalKeyDown(e, firstFocusable, lastFocusable, modalId);
      modal.addEventListener('keydown', modal._keyDownListener);

      // Set initial focus (improved logic)
      setTimeout(() => {
          let targetElement = elementToFocusInitially; // Prioritize passed element

          if (!targetElement) { // If no specific element, use conventions
              if (modalId === 'createPlaylist') targetElement = elements.playlistElements.nameInput;
              else if (modalId === 'account' && !appState.loggedInUser) targetElement = elements.accountFields.loginEmail;
              else if (modalId === 'account' && appState.loggedInUser) targetElement = elements.modalButtons.syncData; // Or logout btn?
              else if (modalId === 'share') targetElement = elements.modalButtons.copyLink;
              else if (modalId === 'offline') targetElement = modal.querySelector('#cache-current-btn'); // Example for offline modal
              else if (modalId === 'playlistDetail') targetElement = modal.querySelector('.modal-close-btn'); // Focus close btn for detail
              // Fallback to first focusable element found
              else targetElement = firstFocusable;
          }

          (targetElement || modal)?.focus(); // Focus target or modal itself as last resort
          // console.log("Attempted initial focus on:", targetElement || modal);
      }, 150); // Delay slightly longer than transition
    }

    function hideModal(modalId) {
        console.log(`Attempting to hide modal: ${modalId}`);
        const modal = elements.modals[modalId];
        if (!modal || !modal.classList.contains('show')) {
            return;
        }

        modal.classList.remove('show'); // Start fade out
        // Only clear activeModalId if this IS the active modal
        if (appState.activeModalId === modalId) {
            appState.activeModalId = null;
        }

        // Actions after transition completes
        setTimeout(() => {
            modal.style.display = 'none'; // Hide element

            // Remove listener only if it exists for this modal
            if (modal._keyDownListener) {
                modal.removeEventListener('keydown', modal._keyDownListener);
                delete modal._keyDownListener; // Clean up
            }

            // Restore focus and body scroll *only if* no other modals are currently active
             const anyOtherModalOpen = Object.values(elements.modals).some(
                 m => m && m.id !== modal.id && m.classList.contains('show')
             );

            if (!anyOtherModalOpen) {
                 if(elements.body) elements.body.style.overflow = ''; // Restore scroll
                 if (lastFocusedElement && typeof lastFocusedElement.focus === 'function') {
                     lastFocusedElement.focus();
                 }
                 lastFocusedElement = null; // Reset for next time
            }

            // Reset specific modal states if needed
            if (modalId === 'playlistDetail') appState.currentSelectedPlaylistId = null;
            if (modalId === 'share' && elements.playlistElements.shareLinkInput) elements.playlistElements.shareLinkInput.value = '';
            if (modalId === 'createPlaylist' && elements.playlistElements.nameInput) elements.playlistElements.nameInput.value = '';
            if (modalId === 'offline' && elements.modals.offline) {
                // If offline modal was dynamically created, remove it on close? Or just hide?
                // elements.modals.offline.remove();
                // delete elements.modals.offline;
            }

        }, 300); // Match CSS transition duration
    }

     function handleModalKeyDown(e, firstFocusable, lastFocusable, modalId) {
         if (e.key === 'Escape') {
             hideModal(modalId);
             return;
         }
         if (e.key === 'Tab' && firstFocusable) { // Trap focus only if focusable elements exist
             if (e.shiftKey) { // Shift + Tab
                 if (document.activeElement === firstFocusable) {
                     lastFocusable?.focus(); // Wrap to last
                     e.preventDefault();
                 }
             } else { // Tab
                 if (document.activeElement === lastFocusable) {
                     firstFocusable?.focus(); // Wrap to first
                     e.preventDefault();
                 }
             }
              // Prevent tabbing out if only one element
             if (firstFocusable === lastFocusable && document.activeElement === firstFocusable) {
                  e.preventDefault();
             }
         }
     }

    // --- Snackbar ---
    function showSnackbar(message) {
        const snackbar = elements.snackbar;
        if (!snackbar) return;
        snackbar.textContent = message;

        if (appState.snackbarTimeoutId) {
            clearTimeout(appState.snackbarTimeoutId);
            snackbar.classList.remove('show');
             // Ensure the 'bottom' style is reset if it was previously set (might not be needed with current CSS)
            // snackbar.style.bottom = '-100px';
        }

        // Force reflow to restart animation
        void snackbar.offsetWidth;

        // Add class to trigger transition
        snackbar.classList.add('show');

        // Set timeout to hide it
        appState.snackbarTimeoutId = setTimeout(() => {
            snackbar.classList.remove('show');
            // After transition, reset bottom position (optional, depends on CSS)
            // setTimeout(() => { snackbar.style.bottom = '-100px'; }, 300);
            appState.snackbarTimeoutId = null;
        }, 3000);
    }

     // --- Global Keydown Handler ---
    function handleGlobalKeyDown(event) {
        const activeElement = document.activeElement;
        const isInputFocused = activeElement && ['INPUT', 'TEXTAREA', 'SELECT'].includes(activeElement.tagName);

        // Ignore if a modal is active OR if typing in an input (except for Esc maybe?)
        if (appState.activeModalId || (isInputFocused && event.key !== 'Escape')) {
            return;
        }

        // Basic player controls (add more as needed)
        switch (event.key) {
            case ' ': // Space bar for Play/Pause
                 if (!isInputFocused) { // Prevent space in input fields triggering pause
                      event.preventDefault();
                      togglePlayPause();
                 }
                 break;
            case 'ArrowRight':
                event.preventDefault();
                if (event.ctrlKey || event.metaKey) seekRelative(SEEK_STEP);
                else playNextSong();
                break;
            case 'ArrowLeft':
                event.preventDefault();
                if (event.ctrlKey || event.metaKey) seekRelative(-SEEK_STEP);
                else playPreviousSong();
                break;
            case 'ArrowUp':
                 if (!elements.volumeSlider || activeElement !== elements.volumeSlider) { // Prevent clash with range slider keys
                     event.preventDefault();
                     adjustVolume(VOLUME_STEP);
                 }
                 break;
            case 'ArrowDown':
                 if (!elements.volumeSlider || activeElement !== elements.volumeSlider) { // Prevent clash with range slider keys
                     event.preventDefault();
                     adjustVolume(-VOLUME_STEP);
                 }
                 break;
            case 'f': // Focus search input
                 if (!isInputFocused) {
                     event.preventDefault();
                     elements.searchInput?.focus();
                 }
                 break;
             case 't': // Toggle theme (example)
                  event.preventDefault();
                  toggleTheme();
                  break;

            // You could add more: 's' for shuffle, 'l' for loop, 'm' for mute etc.
        }
    }

    // --- Visualizer Drawing (Simulation) ---
    function drawVisualizer() {
        // This function simulates audio visualization based on isPlaying state.
        if (!appState.visualizer.canvasCtx || !appState.visualizer.dataArray || !appState.visualizer.canvas) {
             appState.visualizer.animationFrameId = null;
             return;
        }
        appState.visualizer.animationFrameId = requestAnimationFrame(drawVisualizer);

        const bufferLength = appState.visualizer.bufferLength;
        const dataArray = appState.visualizer.dataArray;
        const isPlaying = appState.isPlaying;

        // Simulate data
        for (let i = 0; i < bufferLength; i++) {
            if (isPlaying) {
                 const timeFactor = Date.now() * 0.005 + i * 0.1;
                 const randomFactor = Math.random() * 50;
                 const sineValue = (Math.sin(timeFactor) + 1) / 2;
                 dataArray[i] = Math.max(0, Math.min(255, (sineValue * 150) + randomFactor + 20));
            } else {
                 dataArray[i] = Math.max(0, dataArray[i] * 0.95 - 1); // Decay effect
            }
        }

        const canvas = appState.visualizer.canvas;
        const canvasCtx = appState.visualizer.canvasCtx;
        const width = canvas.width;
        const height = canvas.height;

        canvasCtx.clearRect(0, 0, width, height);

        const isDarkMode = elements.body?.classList.contains('dark');
         // Use CSS variables directly
         const primary = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim();
         const secondary = getComputedStyle(document.documentElement).getPropertyValue('--secondary-color').trim();
         const bg = getComputedStyle(document.documentElement).getPropertyValue('--visualizer-bg', isDarkMode ? 'rgba(30, 30, 30, 0.1)' : 'rgba(245, 245, 245, 0.1)'); // Use a CSS variable or fallback


        canvasCtx.fillStyle = bg;
        canvasCtx.fillRect(0, 0, width, height);

        const gradient = canvasCtx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0, primary || '#8e24aa'); // Fallback color
        gradient.addColorStop(1, secondary || '#5e35b1');
        canvasCtx.fillStyle = gradient;

        const barWidth = Math.max(1, (width / bufferLength) * 1.5); // Ensure barWidth is at least 1
        const spacing = Math.max(1, barWidth * 0.2); // Spacing relative to bar width
        const totalBarAndSpaceWidth = barWidth + spacing;
        const numBarsThatFit = Math.floor(width / totalBarAndSpaceWidth);
        const actualBufferLength = Math.min(bufferLength, numBarsThatFit); // Use fewer bars if they don't fit
        const offsetX = (width - (actualBufferLength * totalBarAndSpaceWidth - spacing)) / 2; // Center bars

        let x = offsetX;
        for (let i = 0; i < actualBufferLength; i++) {
            const barHeight = Math.max(1, (dataArray[i] / 255) * height * 0.8); // Min height of 1px
            const borderRadius = barWidth / 4; // Rounded corners

             // Draw rounded rectangle
             canvasCtx.beginPath();
             canvasCtx.moveTo(x + borderRadius, height);
             canvasCtx.lineTo(x + borderRadius, height - barHeight + borderRadius);
             // Top edge (potentially flat if barHeight is small)
             if (barHeight > borderRadius * 2) {
                canvasCtx.arcTo(x, height - barHeight, x + borderRadius, height - barHeight, borderRadius); // Top-left corner
                canvasCtx.lineTo(x + barWidth - borderRadius, height - barHeight);
                canvasCtx.arcTo(x + barWidth, height - barHeight, x + barWidth, height - barHeight + borderRadius, borderRadius); // Top-right corner
             } else { // Draw a simple rounded top if bar is short
                 canvasCtx.lineTo(x + barWidth - borderRadius, height - barHeight + borderRadius);
             }
             canvasCtx.lineTo(x + barWidth, height); // Right edge down
             // No bottom corners needed as it connects at height
             canvasCtx.closePath();
             canvasCtx.fill();

            x += totalBarAndSpaceWidth;
        }
    }

    // --- Canvas Resize ---
    function resizeCanvas() {
        if (!appState.visualizer.canvas) return;
        const parent = appState.visualizer.canvas.parentElement;
        if (!parent) return;
        const rect = parent.getBoundingClientRect();
        if (rect.width > 0 && rect.height > 0 && (appState.visualizer.canvas.width !== rect.width || appState.visualizer.canvas.height !== rect.height)) {
            appState.visualizer.canvas.width = rect.width;
            appState.visualizer.canvas.height = rect.height;
            // console.log("Resized visualizer canvas to:", rect.width, rect.height);
             // Re-draw immediately if paused
             if (!appState.isPlaying) {
                 drawVisualizer(); // Draw the decayed state on new size
             }
        }
    }

     // --- Highlight Active Song ---
     function updateActiveListItem() {
         const currentId = currentSongId(); // Use helper
         const listContainers = [
             elements.playlist, elements.historyList, elements.favoritesList,
             elements.playlistElements?.detailContent // Check if detailContent exists
         ];

         listContainers.forEach(container => {
             if (container) {
                 // Remove active class from previously active item(s) within this container
                 const previouslyActive = container.querySelector('.active');
                 previouslyActive?.classList.remove('active');

                 // Add active class to the current song if it exists in this container
                 if (currentId) {
                     const activeItem = container.querySelector(`.playlist-item[data-id="${currentId}"], .history-item[data-id="${currentId}"], .favorite-item[data-id="${currentId}"]`);
                     if (activeItem) {
                         activeItem.classList.add('active');
                         // Scroll into view only if the container is visible (in active tab or modal)
                         const isVisible = !activeItem.closest('.tab-content.hidden, .modal:not(.show)');
                         if(isVisible) {
                             // Check if item is already fully visible to prevent unnecessary scrolling
                             const itemRect = activeItem.getBoundingClientRect();
                             const containerRect = container.getBoundingClientRect();
                             const isFullyVisible = itemRect.top >= containerRect.top && itemRect.bottom <= containerRect.bottom;

                             if (!isFullyVisible) {
                                activeItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                             }
                         }
                     }
                 }
             }
         });
     }

      // --- Handle URL Parameters ---
      function handleUrlParams() {
          try {
              const urlParams = new URLSearchParams(window.location.search);
              const sharedPlaylistId = urlParams.get('sharedPlaylistId');
              const songIdToPlay = urlParams.get('playSongId');

              if (sharedPlaylistId) {
                  // Attempt to view playlist even if user data isn't fully loaded yet
                  // Requires playlists to be accessible without login or loaded early
                  const playlist = appState.userPlaylists.find(p => p && p.id === sharedPlaylistId);
                  if (playlist) {
                      showSnackbar(`共有されたプレイリスト「${escapeHTML(playlist.name)}」を表示します`);
                      viewPlaylist(sharedPlaylistId);
                      switchTab('user-playlists'); // Switch to the relevant tab
                  } else {
                      showSnackbar("共有されたプレイリストが見つかりませんでした。");
                  }
                  // Clean URL param after processing? Optional.
                  // history.replaceState(null, '', window.location.pathname);
              } else if (songIdToPlay) {
                  // Attempt to play song. Requires songs to be loaded.
                  const originalIndex = findSongIndexById(songIdToPlay);
                  if (originalIndex !== -1) {
                      playSong(originalIndex);
                      showSnackbar(`共有された曲を再生します`);
                  } else {
                       // If songs aren't loaded yet, maybe try again after load?
                       // For now, just show not found.
                       showSnackbar("共有された曲が見つかりませんでした。");
                  }
                  // Clean URL param after processing? Optional.
                  // history.replaceState(null, '', window.location.pathname);
              }
          } catch(e) {
              console.error("Error handling URL parameters:", e);
          }
      }

      // --- HTML Escaping Utility ---
      function escapeHTML(str) {
          if (typeof str !== 'string') return '';
          const map = {
              '&': '&amp;',
              '<': '&lt;',
              '>': '&gt;',
              '"': '&quot;',
              "'": '&#39;' // Use HTML entity for single quote for better compatibility
          };
          return str.replace(/[&<>"']/g, (m) => map[m]);
      }

       // --- Mobile Bottom Controls Visibility ---
       function checkBottomControlsVisibility() {
         const isMobile = window.innerWidth < 1024; // lg breakpoint in Tailwind
         if (elements.bottomControls) {
             elements.bottomControls.classList.toggle('hidden', !isMobile);
         }
         if(elements.body) {
            elements.body.classList.toggle('has-bottom-controls', isMobile);
         }
         // Adjust layout/padding based on visibility if needed elsewhere
       }

    // ==========================================================================
    // YouTube API Object
    // ==========================================================================
    const youtubeAPI = {
      // APIキー（実際の使用時には自分のAPIキーに置き換える必要があります）
      apiKey: 'AIzaSyCbzvjP9vFa5I8N1qLI5H9LUpYim0nkQS4',
      
      // チャンネルID
      channelId: 'UCYAuSEKhuk3v4ZKzm5Lqb1Q',
      
      // 最新の動画を取得する関数
      async getLatestVideos() {
  try {
    // チャンネル情報取得
    const channelResponse = await fetch(
      `https://www.googleapis.com/youtube/v3/channels?part=contentDetails&id=${this.channelId}&key=${this.apiKey}`
    );
    if (!channelResponse.ok) {
      throw new Error('チャンネル情報の取得に失敗しました');
    }
    const channelData = await channelResponse.json();
    if (!channelData.items || channelData.items.length === 0) {
      throw new Error('チャンネルが見つかりません');
    }
    const uploadsPlaylistId = channelData.items[0].contentDetails.relatedPlaylists.uploads;

    // ページネーションで全動画を取得（最大5ページ）
    let videos = [];
    let nextPageToken = '';
    let pageCount = 0;
    const maxPages = 5;
    do {
      let url = `https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&maxResults=50&playlistId=${uploadsPlaylistId}&key=${this.apiKey}`;
      if (nextPageToken) {
        url += `&pageToken=${nextPageToken}`;
      }
      const playlistResponse = await fetch(url);
      if (!playlistResponse.ok) {
        throw new Error('プレイリスト情報の取得に失敗しました');
      }
      const playlistData = await playlistResponse.json();
      if (playlistData.items) {
        videos.push(...playlistData.items);
      }
      nextPageToken = playlistData.nextPageToken;
      pageCount++;
      if (pageCount >= maxPages) {
        console.log(`最大ページ数 ${maxPages} に達しました。`);
        break;
      }
    } while (nextPageToken);

    // 必要な情報だけを抽出（duration は空にしておく）
    return videos.map(item => {
      const snippet = item.snippet;
      return {
        id: snippet.resourceId.videoId,
        title: snippet.title,
        description: snippet.description,
        thumbnail: snippet.thumbnails.high.url,
        publishedAt: snippet.publishedAt,
        duration: null  // duration は後で上書きする
      };
    });
  } catch (error) {
    console.error('YouTube APIエラー:', error);
    showSnackbar('YouTube動画の取得に失敗しました');
    return [];
  }
}
,
      
      // 動画の詳細情報を取得する関数（長さなど）
      async getVideoDetails(videoIds) {
        if (!videoIds || videoIds.length === 0) return [];
        
        try {
          const response = await fetch(
            `https://www.googleapis.com/youtube/v3/videos?part=contentDetails,statistics&id=${videoIds.join(',')}&key=${this.apiKey}`
          );
          
          if (!response.ok) {
            throw new Error('動画詳細の取得に失敗しました');
          }
          
          const data = await response.json();
          
          if (!data.items || data.items.length === 0) {
            return [];
          }
          
          return data.items.map(item => {
            // ISO 8601形式の期間を分:秒形式に変換
            const duration = this.convertDuration(item.contentDetails.duration);
            
            return {
              id: item.id,
              duration: duration,
              viewCount: item.statistics.viewCount
            };
          });
        } catch (error) {
          console.error('YouTube APIエラー (動画詳細):', error);
          return [];
        }
      },
      
      // ISO 8601形式の期間を分:秒形式に変換する関数
      convertDuration(isoDuration) {
        const match = isoDuration.match(/PT(\d+H)?(\d+M)?(\d+S)?/);
        
        const hours = (match[1] && match[1].replace('H', '')) || 0;
        const minutes = (match[2] && match[2].replace('M', '')) || 0;
        const seconds = (match[3] && match[3].replace('S', '')) || 0;
        
        let result = '';
        
        if (hours > 0) {
          result += `${hours}:`;
          result += `${minutes.toString().padStart(2, '0')}:`;
        } else {
          result += `${minutes}:`;
        }
        
        result += seconds.toString().padStart(2, '0');
        
        return result;
      },
      
      // 新しい曲をプレイリストに追加する関数
      async updatePlaylist() {
        try {
          showSnackbar('YouTubeから最新の曲を取得中...');
          
          // 最新の動画を取得
          const latestVideos = await this.getLatestVideos(15); // 最新15件を取得
          
          if (latestVideos.length === 0) {
            showSnackbar('新しい曲は見つかりませんでした');
            return;
          }
          
          // 動画IDのリストを作成
          const videoIds = latestVideos.map(video => video.id);
          
          // 動画の詳細情報を取得
          const videoDetails = await this.getVideoDetails(videoIds);
          
          // 詳細情報を結合
          const videosWithDetails = latestVideos.map(video => {
            const details = videoDetails.find(detail => detail.id === video.id) || {};
            return {
              ...video,
              duration: details.duration || video.duration
            };
          });
          
          // 既存の曲リストと比較して新しい曲だけを追加
          const newSongs = videosWithDetails.filter(video => 
            !appState.songs.some(song => song.id === video.id)
          );
          
          if (newSongs.length === 0) {
            showSnackbar('新しい曲は見つかりませんでした');
            return;
          }
          
          // 新しい曲をプレイリストに追加
          newSongs.forEach(video => {
            appState.songs.unshift({
              id: video.id,
              title: video.title,
              duration: video.duration,
              thumbnail: video.thumbnail
            });
          });
          
          // フィルタリングされた曲リストも更新
          appState.filteredSongs = [...appState.songs];
          
          // UIを更新
          renderPlaylist();
          
          showSnackbar(`${newSongs.length}曲の新しい曲を追加しました`);
        } catch (error) {
          console.error('プレイリスト更新エラー:', error);
          showSnackbar('プレイリストの更新に失敗しました');
        }
      },
      
      // 定期的に新曲をチェックする関数
      startAutoSync(intervalMinutes = 60) {
        // 初回実行
        this.updatePlaylist();
        
        // 定期的に実行（デフォルトは1時間ごと）
        const intervalId = setInterval(() => {
          this.updatePlaylist();
        }, intervalMinutes * 60 * 1000);
        
        // intervalIdを返して、必要に応じて停止できるようにする
        return intervalId;
      }
    };

    // 同期ボタンを追加する関数
    function setupYouTubeSync() {
      // 同期ボタンを追加
      const syncButton = document.createElement('button');
      syncButton.id = 'youtube-sync-btn';
      syncButton.className = 'px-3 py-1 rounded-md text-sm';
      syncButton.style.backgroundColor = 'var(--primary-color)';
      syncButton.style.color = 'white';
      syncButton.innerHTML = '<i class="fab fa-youtube mr-1"></i> 新曲を同期';
      
      // ボタンを適切な場所に追加
      const buttonContainer = document.querySelector('.flex.justify-end.mb-2.gap-2');
      if (buttonContainer) {
        buttonContainer.prepend(syncButton);
        
        // クリックイベントを追加
        syncButton.addEventListener('click', () => {
          youtubeAPI.updatePlaylist();
        });
      }
      
      // 自動同期を開始（1時間ごと）
      youtubeAPI.startAutoSync(60);
    }


    // ==========================================================================
    // Offline Playback Functionality (Service Worker based)
    // ==========================================================================
    const offlinePlayback = {
      isSWRegistered: false, // Track registration status

      async registerServiceWorker() {
        if ('serviceWorker' in navigator) {
          try {
            // Register with scope '/' to control the whole origin
            // Ensure service-worker.js is in the root directory or adjust path
            const registration = await navigator.serviceWorker.register('/service-worker.js', { scope: '/' });
            console.log('Service Worker registered successfully:', registration.scope);
            this.isSWRegistered = true;
            // Listen for controller changes
            navigator.serviceWorker.addEventListener('controllerchange', () => {
                 console.log('Service Worker: Controller changed.');
                 // Optionally reload or notify user?
            });
             // Listen for messages from SW (e.g., cache updates)
             navigator.serviceWorker.addEventListener('message', event => {
                  console.log('Message from SW:', event.data);
                  if (event.data && event.data.type === 'CACHE_COMPLETE') {
                      showSnackbar(`キャッシュ完了: ${event.data.count}個のリソース`);
                  }
                  if (event.data && event.data.type === 'CACHE_ERROR') {
                       showSnackbar(`キャッシュエラー: ${event.data.message}`);
                   }
             });
            return registration;
          } catch (error) {
            console.error('Service Worker registration failed:', error);
            this.isSWRegistered = false;
            return null;
          }
        } else {
          console.warn('Service Worker is not supported in this browser.');
          this.isSWRegistered = false;
          return null;
        }
      },

      setupOfflineDetection() {
        const updateStatus = () => {
            const isOffline = !navigator.onLine;
            if(elements.body) elements.body.classList.toggle('offline-mode', isOffline);

            let statusElement = document.getElementById('offline-status');
            if (!statusElement && elements.body) { // Create if doesn't exist
                statusElement = document.createElement('div');
                statusElement.id = 'offline-status';
                // Improved styling: Less intrusive, better dark mode support
                statusElement.className = 'fixed top-0 left-1/2 transform -translate-x-1/2 mt-2 px-4 py-1 rounded-full text-white text-xs shadow transition-opacity duration-300 opacity-0 pointer-events-none';
                statusElement.style.backgroundColor = 'var(--accent-color)';
                statusElement.style.zIndex = '9999';
                elements.body.prepend(statusElement);
            }

            if (statusElement) {
                 statusElement.style.opacity = isOffline ? '1' : '0';
                 statusElement.textContent = isOffline ? 'オフラインモード' : '';
                 statusElement.style.pointerEvents = isOffline ? 'auto' : 'none';
            }

             // Show snackbar only on change, and avoid on initial load if online
             if(typeof this.wasOffline === 'undefined') {
                this.wasOffline = isOffline; // Set initial state
                if(isOffline) { // Show snackbar only if initially offline
                    showSnackbar('オフラインです。キャッシュされたコンテンツのみ利用可能です。');
                }
             } else if (this.wasOffline !== isOffline) {
                 if (isOffline) {
                    showSnackbar('オフラインです。キャッシュされたコンテンツのみ利用可能です。');
                 } else {
                    showSnackbar('オンラインに戻りました。');
                 }
                 this.wasOffline = isOffline;
             }
        };
        updateStatus(); // Initial check
        window.addEventListener('online', updateStatus);
        window.addEventListener('offline', updateStatus);
      },

      sendMessageToSW(message) {
          // Send message to the active service worker
          return new Promise((resolve, reject) => {
              if (!navigator.serviceWorker.controller) {
                   // Try waiting a bit for the controller to become active, especially after registration
                   setTimeout(() => {
                       if(navigator.serviceWorker.controller) {
                           this.sendMessageToSW(message).then(resolve).catch(reject); // Retry
                       } else {
                          reject('Service Worker controller not available.');
                       }
                   }, 500);
                   return;
              }

              const messageChannel = new MessageChannel();
              messageChannel.port1.onmessage = function(event) {
                  if (event.data && event.data.error) { // Check for error property
                      console.error("Error message from SW:", event.data.error);
                      reject(event.data.error);
                  } else {
                      resolve(event.data); // Resolve with the response from SW
                  }
              };
              messageChannel.port1.onmessageerror = function(event) {
                  console.error("Message error on port1:", event);
                  reject('Message channel error');
              };

              // Send message with the MessageChannel port
              navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);
          });
      },


      async cacheUrls(urls) {
          if (!this.isSWRegistered) {
              showSnackbar("オフライン機能の準備ができていません。");
              return;
          }
           if (!navigator.onLine) {
               showSnackbar("オフラインのためキャッシュできません。");
               return;
           }
          if (!urls || urls.length === 0) return;

          showSnackbar(`${urls.length} 個のリソースをキャッシュ中...`);
          try {
              // Send message and wait for response (e.g., confirmation or error)
              const response = await this.sendMessageToSW({ type: 'CACHE_URLS', urls: urls });
              console.log('Response from SW for CACHE_URLS:', response);
              // SW should send back a message indicating success/failure/count
              // Message handling is now done in the global listener in registerServiceWorker
          } catch (error) {
              console.error('Failed to send cache message to SW or received error:', error);
              showSnackbar("リソースのキャッシュ要求に失敗しました。");
          }
      },

      cacheCurrentSong() {
        const currentSong = currentSongData(); // Use helper
        if (!currentSong) {
            showSnackbar("キャッシュする曲が選択されていません。");
            return;
        }
        if (!currentSong.id || !currentSong.thumbnail) {
             showSnackbar("曲の情報が不完全なためキャッシュできません。");
             return;
        }
        showSnackbar(`「${escapeHTML(currentSong.title)}」のサムネイルをキャッシュ中...`);
        this.cacheUrls([currentSong.thumbnail]); // Cache only the thumbnail
      },

      cacheFavoriteSongs() {
        if (appState.favorites.length === 0) {
             showSnackbar("お気に入りに曲がありません。");
             return;
        }
        const urlsToCache = appState.favorites
            .map(fav => fav?.thumbnail) // Get thumbnail URL
            .filter(url => url); // Filter out invalid URLs
        if (urlsToCache.length > 0) {
            this.cacheUrls(urlsToCache);
        } else {
             showSnackbar("キャッシュできるお気に入り情報がありません。");
        }
      },

      async clearCache() {
           if (!this.isSWRegistered) {
               showSnackbar("オフライン機能の準備ができていません。");
               return;
           }
           if(confirm("すべてのオフラインキャッシュを削除しますか？")) {
               showSnackbar("キャッシュをクリア中...");
               try {
                  const response = await this.sendMessageToSW({ type: 'CLEAR_CACHE' });
                  console.log("Response from SW for CLEAR_CACHE:", response);
                  showSnackbar('キャッシュをクリアしました。');
               } catch(error) {
                   console.error("Failed to clear cache via SW:", error);
                   showSnackbar("キャッシュのクリアに失敗しました。");
               }
           }
      },

       // Method to show the dynamically created offline modal
      showOfflineModal() {
          const modal = elements.modals.offline;
          if (modal) {
              showModal('offline'); // Use the standard showModal function
          } else {
              console.error("Offline modal element not found.");
              showSnackbar("オフライン管理を開けませんでした。");
          }
      },


      addOfflineUI() {
        // Check if the button already exists in the cached elements
        if (elements.offlineMenuBtn) {
          elements.offlineMenuBtn.classList.remove('hidden'); // Show the button
           // Add event listener if not already added (e.g., if init runs multiple times)
           if (!elements.offlineMenuBtn._hasClickListener) {
                elements.offlineMenuBtn.addEventListener('click', () => this.showOfflineModal());
                elements.offlineMenuBtn._hasClickListener = true;
           }
          console.log("Offline UI button revealed.");
        } else {
          console.warn("Could not find offline menu button in header to reveal.");
          // Optionally, create the button dynamically if needed, but finding is preferred
        }

        // Ensure the offline modal container exists (it's in the HTML now)
        if (!elements.modals.offline) {
             console.warn("Offline modal container not found in HTML.");
             // If dynamically creating, do it here and add to elements.modals.offline
        }
         // Setup content and listeners for the modal (can be done once)
         const modalContentContainer = elements.modals.offline?.querySelector('.modal-content');
         if (modalContentContainer && !modalContentContainer._isSetup) {
             modalContentContainer.innerHTML = `
                 <div class="flex justify-between items-center mb-4">
                   <h2 id="offline-modal-title" class="text-xl font-bold">オフラインキャッシュ</h2>
                   <button class="modal-close-btn close-modal-btn text-2xl leading-none focusable" data-modal-id="offline" aria-label="閉じる">&times;</button>
                 </div>
                 <p class="mb-4 text-sm">サムネイル画像をキャッシュしてオフライン表示を高速化します。（動画自体のオフライン再生はできません）</p>
                 <div class="flex flex-col gap-3">
                   <button id="cache-current-btn" class="px-4 py-2 rounded focusable w-full text-left" style="background-color: var(--primary-color); color: white;">
                     <i class="fas fa-music mr-2"></i>現在の曲のサムネイルをキャッシュ
                   </button>
                   <button id="cache-favorites-btn" class="px-4 py-2 rounded focusable w-full text-left" style="background-color: var(--primary-color); color: white;">
                     <i class="fas fa-heart mr-2"></i>お気に入りのサムネイルをキャッシュ
                   </button>
                   <button id="clear-cache-btn" class="px-4 py-2 rounded focusable w-full text-left mt-4" style="background-color: var(--accent-color); color: white;">
                     <i class="fas fa-trash mr-2"></i>全キャッシュをクリア
                   </button>
                 </div>
               `;
             // Add event listeners for the new modal's buttons
             modalContentContainer.querySelector('.close-modal-btn')?.addEventListener('click', () => hideModal('offline'));
             modalContentContainer.querySelector('#cache-current-btn')?.addEventListener('click', () => this.cacheCurrentSong());
             modalContentContainer.querySelector('#cache-favorites-btn')?.addEventListener('click', () => this.cacheFavoriteSongs());
             modalContentContainer.querySelector('#clear-cache-btn')?.addEventListener('click', () => this.clearCache());
             modalContentContainer._isSetup = true; // Mark as setup
         }

      },

      async init() {
        console.log('Initializing Offline Playback module...');
        await this.registerServiceWorker(); // Wait for registration attempt
        this.setupOfflineDetection();
        // Add UI elements only if SW is potentially active or supported
        if ('serviceWorker' in navigator) {
            this.addOfflineUI(); // This will now reveal the button and setup the modal content
        }
        console.log('Offline Playback module initialization complete.');
      }
    };


    // ==========================================================================
    // DOMContentLoaded Listener
    // ==========================================================================
    document.addEventListener('DOMContentLoaded', function() {
      console.log("DOM fully loaded and parsed.");

      // --- Viewport Height Setup ---
      function setCorrectViewportHeight() {
        let vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh}px`);
      }
      setCorrectViewportHeight(); // Initial call
      window.addEventListener('resize', setCorrectViewportHeight); // Update on resize

      // Don't initialize elements or setup listeners here, wait for onPlayerReady
      // checkBottomControlsVisibility(); // Initial check for mobile controls can happen here

      console.log("DOMContentLoaded setup finished. Waiting for YT API...");
    });

    // --- Final log ---
    console.log("Player script parsed. Waiting for YouTube API ready event...");

  </script>
  
</body>

</html>

<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" >
  <title>Rei Kikuchi Premium Music Player</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary-color: #8e24aa;
      --secondary-color: #5e35b1;
      --accent-color: #d81b60;
      --text-color: #333;
      --background-color: #f5f5f5;
      --card-color: #fff;
      --border-color: #e0e0e0;
      --vh: 1vh; /* モバイルのビューポート高さ補正用 */
    }

    .dark {
      --primary-color: #bb86fc;
      --secondary-color: #7c4dff;
      --accent-color: #cf6679;
      --text-color: #e0e0e0;
      --background-color: #121212;
      --card-color: #1e1e1e;
      --border-color: #333;
    }

    /* オフラインモード用のスタイル */
    .offline-mode .online-only {
      opacity: 0.5;
      pointer-events: none;
    }

    #offline-status {
      z-index: 9999;
    }

    .offline-badge {
      position: absolute;
      top: 0;
      right: 0;
      background-color: var(--accent-color);
      color: white;
      font-size: 0.6rem;
      padding: 2px 4px;
      border-radius: 4px;
      transform: translate(50%, -50%);
    }

    body {
      font-family: 'Poppins', sans-serif;
      transition: background-color 0.3s ease, color 0.3s ease;
      background-color: var(--background-color);
      color: var(--text-color);
      display: flex; /* Flexboxでレイアウト */
      flex-direction: column;
      /* min-height: 100vh; -> height: 100% に変更 */
      height: calc(var(--vh, 1vh) * 100); /* モバイルでの高さ問題を修正 */
    }

    /* UI/UX改善用のスタイル追加 */
    .song-item {
      transition: transform 0.2s ease, background-color 0.2s ease;
      position: relative;
      overflow: hidden;
    }

    .song-item:hover {
      transform: translateY(-2px);
      background-color: rgba(142, 36, 170, 0.05);
    }

    .song-item::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 0;
      height: 2px;
      background-color: var(--primary-color);
      transition: width 0.3s ease;
    }

    .song-item:hover::after {
      width: 100%;
    }

    .song-item.active {
      background-color: rgba(142, 36, 170, 0.1);
      border-left: 3px solid var(--primary-color);
    }

    .btn-mode, .btn-control {
      transition: transform 0.2s ease, opacity 0.2s ease;
    }

    .btn-mode:hover, .btn-control:hover {
      transform: scale(1.1);
    }

    .btn-mode:active, .btn-control:active {
      transform: scale(0.95);
    }

    .tab-button {
      position: relative;
      overflow: hidden;
    }

    .tab-button::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      width: 0;
      height: 2px;
      background-color: var(--primary-color);
      transition: width 0.3s ease, left 0.3s ease;
    }

    .tab-button:hover::after {
      width: 100%;
      left: 0;
    }

    .tab-button.active::after {
      width: 100%;
      left: 0;
    }

    /* スマホ向け最適化 */
    @media (max-width: 640px) {
      .song-controls {
        flex-direction: column;
        gap: 0.5rem;
      }

      .player-controls {
        flex-wrap: wrap;
        justify-content: center;
      }

      .volume-control {
        width: 100%;
        margin-top: 0.5rem;
      }

      .song-item {
        padding: 0.75rem;
      }

      .song-title {
        font-size: 0.9rem;
      }

      .song-duration {
        font-size: 0.8rem;
      }

      /* タッチ操作の最適化 */
      .btn-mode, .btn-control, .tab-button, .song-item, .heart-btn {
        min-height: 44px; /* タッチターゲットの最小サイズ */
      }

      /* スマホでのスクロールを滑らかに */
      .playlist-container {
        -webkit-overflow-scrolling: touch;
      }
    }

    /* アニメーション効果 */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    @keyframes slideUp {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }

    .fade-in {
      animation: fadeIn 0.5s ease forwards;
    }

    .slide-up {
      animation: slideUp 0.5s ease forwards;
    }

    .pulse {
      animation: pulse 1s infinite;
    }

    /* プレイヤーコントロールの改善 */
    .player-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      margin: 1rem 0;
    }

    .progress-container {
      position: relative;
      height: 6px;
      background-color: var(--border-color);
      border-radius: 3px;
      cursor: pointer;
      overflow: hidden;
      /* トラックの高さを増やし、色を調整 */
      background-color: rgba(0, 0, 0, 0.1);
      transition: background-color 0.3s ease;
      /* タップ領域を明確にするために上下パディングを追加 */
      padding: 8px 0;
      margin: -8px 0;
    }

    .progress-bar {
      height: 100%;
      background-color: var(--primary-color);
      border-radius: 3px;
      transition: width 0.1s linear;
      /* 再生済み部分の色を濃く・鮮やかに */
      background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
      width: 0%;
      position: relative;
    }

    .progress-thumb {
      position: absolute;
      top: 50%;
      width: 12px;
      height: 12px;
      background-color: var(--primary-color);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
      transition: transform 0.2s ease;
    }

    .progress-container:hover .progress-thumb {
      transform: translate(-50%, -50%) scale(1.2);
    }

    /* ローディングインジケーター */
    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 2px solid rgba(142, 36, 170, 0.3);
      border-radius: 50%;
      border-top-color: var(--primary-color);
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* スナックバーの改善 */
    .snackbar {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: var(--card-color);
      color: var(--text-color);
      padding: 12px 24px;
      border-radius: 4px;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
      z-index: 1001; /* Increased z-index */
      font-size: 0.9rem;
      opacity: 0;
      transition: opacity 0.3s ease-out, transform 0.3s ease-out, bottom 0.3s ease-out; /* Added bottom transition */
      border-left: 4px solid var(--primary-color);
      pointer-events: none; /* Prevents interaction when hidden */
      text-align: center;
      max-width: 90%;
      /* Ensure it's above mobile bottom controls */
      margin-bottom: calc(env(safe-area-inset-bottom, 0px) + 10px); /* Adjust for safe area + margin */
    }

    .snackbar.show {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
      bottom: 20px; /* Base position */
      pointer-events: auto; /* Allow interaction when shown */
    }

    /* モーダルの改善 */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s ease;
      padding: 15px; /* Add padding for mobile view */
    }

    .modal.show {
      opacity: 1;
      display: flex;
    }

    .modal-content {
      background-color: var(--card-color);
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      max-width: 90%;
      max-height: 90%; /* Adjusted from 85vh to 90% for flexibility */
      overflow: auto; /* Changed from overflow-y to auto */
      transform: scale(0.9);
      transition: transform 0.3s ease, background-color 0.3s ease; /* Added background transition */
      width: 100%; /* Use padding on modal for spacing */
      padding: 20px; /* Standard padding */
      position: relative; /* Needed for absolute positioned close button */
      -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
    }

    .modal.show .modal-content {
      transform: scale(1);
    }

    /* スクロールバーのカスタマイズ */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--background-color);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border-color);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--primary-color);
    }

    /* フォーカス状態の改善 */
    button:focus, input:focus, a:focus, [tabindex]:focus { /* Applied to more focusable elements */
      outline: 2px solid var(--primary-color);
      outline-offset: 2px;
      box-shadow: 0 0 0 3px rgba(142, 36, 170, 0.3); /* Added subtle shadow for better visibility */
    }

    /* キーボードナビゲーション用 (merged with button:focus style) */
    .focusable:focus { /* Use a class for explicit focusable items if needed */
        outline: 2px solid var(--primary-color);
        outline-offset: 2px;
        box-shadow: 0 0 0 3px rgba(142, 36, 170, 0.3);
    }


    /* アクセシビリティ改善 */
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .app-container {
      max-width: 1280px;
      margin: 0 auto;
      /* padding: 20px; -> スマホでは0に */
      width: 100%;
      flex-grow: 1; /* コンテンツエリアを伸ばす */
      display: flex;
      flex-direction: column;
    }

    .app-container > header {
        padding: 10px 15px; /* スマホ用のヘッダーパディング */
        flex-shrink: 0;
    }

    .music-player {
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
      background-color: var(--card-color);
      transition: background-color 0.3s ease, box-shadow 0.3s ease;
      flex-grow: 1; /* プレイヤー部分が残りの高さを取る */
      display: flex;
      flex-direction: column;
      padding: 0; /* スマホでは不要 */
    }
/* PCでのスタイルを維持 */
@media (min-width: 1024px) {
      .music-player {
         padding: 1.5rem; /* 24px */
      }
      .app-container > header {
          padding: 0 20px; /* PCでは元のpadding */
      }
    }


    /* Gridレイアウト (PC/Tablet) */
    .music-player-grid {
        display: grid;
        grid-template-columns: 1fr; /* Mobile default */
        gap: 1.5rem; /* 24px */
        flex-grow: 1;
        overflow: hidden; /* Prevent grid itself from scrolling */
    }

    @media (min-width: 1024px) { /* lg breakpoint */
        .music-player-grid {
            grid-template-columns: repeat(3, minmax(0, 1fr));
        }
        .player-main-column {
            grid-column: span 2 / span 2;
        }
        .playlist-column {
            grid-column: span 1 / span 1;
            display: flex;
            flex-direction: column;
        }
    }

    .playlist, .history-list, .favorites-list, .user-playlists-list, .playlist-detail-list {
      max-height: 400px; /* Default max height for desktop */
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: var(--primary-color) var(--background-color);
      -webkit-overflow-scrolling: touch; /* iOSでのスムーズスクロール */
    }

    .playlist::-webkit-scrollbar,
    .history-list::-webkit-scrollbar,
    .favorites-list::-webkit-scrollbar,
    .user-playlists-list::-webkit-scrollbar,
    .playlist-detail-list::-webkit-scrollbar {
      width: 6px;
    }

    .playlist::-webkit-scrollbar-track,
    .history-list::-webkit-scrollbar-track,
    .favorites-list::-webkit-scrollbar-track,
    .user-playlists-list::-webkit-scrollbar-track,
    .playlist-detail-list::-webkit-scrollbar-track {
      background: var(--background-color);
    }

    .playlist::-webkit-scrollbar-thumb,
    .history-list::-webkit-scrollbar-thumb,
    .favorites-list::-webkit-scrollbar-thumb,
    .user-playlists-list::-webkit-scrollbar-thumb,
    .playlist-detail-list::-webkit-scrollbar-thumb {
      background-color: var(--primary-color);
      border-radius: 6px;
    }

    .playlist-item, .history-item, .favorite-item {
      transition: all 0.2s ease;
      border-left: 3px solid transparent;
    }

    .playlist-item:hover, .history-item:hover, .favorite-item:hover {
      background-color: rgba(142, 36, 170, 0.1);
    }

    .dark .playlist-item:hover, .dark .history-item:hover, .dark .favorite-item:hover {
       background-color: rgba(187, 134, 252, 0.1);
    }

    .playlist-item.active, .history-item.active, .favorite-item.active {
      border-left: 3px solid var(--primary-color);
      background-color: rgba(142, 36, 170, 0.2);
    }

     .dark .playlist-item.active, .dark .history-item.active, .dark .favorite-item.active {
       background-color: rgba(187, 134, 252, 0.2);
     }

    .player-controls button {
      transition: all 0.2s ease;
    }

    .player-controls button:hover {
      transform: scale(1.1);
    }

    /* Progress Bar Improved Styles */
    /* ホバー時のスタイル */
    .progress-container:hover {
        height: 8px; /* Slightly thicker on hover */
        background-color: rgba(0, 0, 0, 0.15);
    }
     /* つまみ */
     .progress-bar::after {
        content: '';
        position: absolute;
        right: 0;
        top: 50%;
        transform: translate(50%, -50%) scale(0); /* 初期状態は非表示 */
        width: 16px;
        height: 16px;
        background: white;
        border: 2px solid var(--primary-color);
        border-radius: 50%;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        transition: transform 0.2s ease;
        z-index: 2;
     }

     /* ホバー時やアクティブ時に表示 (PC) */
     .progress-container:hover .progress-bar::after,
     .progress-container:active .progress-bar::after {
        transform: translate(50%, -50%) scale(1);
     }

     /* Show thumb if progress is > 0 */
     .progress-bar:not([style*="width: 0%"])::after {
        transform: translate(50%, -50%) scale(1);
     }
     /* Fix for very small percentage values triggering the style rule */
     .progress-bar[style*="width: 0."]::after {
         transform: translate(50%, -50%) scale(1);
     }


     .dark .progress-container {
        background-color: rgba(255, 255, 255, 0.1);
     }

     .dark .progress-bar {
        box-shadow: 0 0 8px rgba(187, 134, 252, 0.3); /* Subtle glow in dark mode */
     }

     .dark .progress-bar::after {
        background: var(--background-color); /* Dark background for thumb */
        border-color: var(--primary-color);
     }

   /* 音量スライダーもタップしやすく */
   .volume-control input[type="range"] {
      -webkit-appearance: none;
      width: 100%;
      height: 8px; /* 少し太く */
      background: var(--border-color);
      border-radius: 8px;
      outline: none;
      transition: background 0.3s ease;
      padding: 5px 0; /* 上下のタップ領域 */
      margin: -5px 0; /* パディング相殺 */
    }
     /* Style for the track */
    .volume-control input[type="range"]::-webkit-slider-runnable-track {
        height: 8px;
        background: var(--border-color);
        border-radius: 8px;
    }
    .volume-control input[type="range"]::-moz-range-track {
        height: 8px;
        background: var(--border-color);
        border-radius: 8px;
    }
     /* Style for the thumb */
    .volume-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px; /* 少し大きく */
      height: 18px;
      background: var(--primary-color);
      border-radius: 50%;
      cursor: pointer;
      margin-top: -5px; /* Center thumb vertically */
       transition: background 0.3s ease;
    }
    .volume-control input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        background: var(--primary-color);
        border-radius: 50%;
        cursor: pointer;
        border: none;
         transition: background 0.3s ease;
    }


    .btn-mode {
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }

    .btn-active {
      color: white;
      background-color: var(--primary-color);
    }
     .dark .btn-active {
        color: var(--background-color); /* Ensure contrast in dark mode */
        background-color: var(--primary-color);
     }

    .btn-inactive {
      color: var(--text-color);
      background-color: var(--border-color);
    }

    .search-container {
      position: relative;
    }

    .search-input {
      padding-left: 40px;
      background-color: var(--card-color);
      border: 1px solid var(--border-color);
      color: var(--text-color);
       transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease;
    }

    .search-icon {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-color);
      transition: color 0.3s ease;
    }

    .tabs {
      display: flex;
      border-bottom: 1px solid var(--border-color);
      margin-bottom: 16px;
      flex-wrap: wrap;
       transition: border-color 0.3s ease;
       flex-shrink: 0; /* タブ自体は縮まない */
    }

    .tab {
      padding: 10px 15px; /* 少し調整 */
      cursor: pointer;
      transition: all 0.3s ease;
      border-bottom: 2px solid transparent;
      text-align: center;
      flex-grow: 1; /* タブを均等配置 */
      font-size: 0.9rem;
    }
     @media (min-width: 640px) { /* PCでは元の設定に戻す */
         .tab {
             flex-grow: 0;
             padding: 10px 20px;
             font-size: 1rem;
         }
         .tabs {
             flex-wrap: nowrap;
         }
     }

     .tab.active {
      color: var(--primary-color);
      border-bottom: 2px solid var(--primary-color);
      font-weight: 600;
    }
    .tab-content {
       /* height: 100%; */ /* Will be handled by flex-grow on parent */
       overflow-y: auto;
       -webkit-overflow-scrolling: touch;
       flex-grow: 1; /* Make tab content take remaining space */
       /* Define a class for scrollable area *inside* tab content */
    }
    .scrollable-list-area {
        /* Default height for desktop/larger screens if needed */
        max-height: 400px;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
    }

    .visualizer-container {
      height: 60px; /* スマホでは少し小さく */
      background-color: rgba(0, 0, 0, 0.05);
      border-radius: 8px;
      overflow: hidden;
      position: relative;
      transition: background-color 0.3s ease;
    }
     @media (min-width: 1024px) {
         .visualizer-container {
            height: 100px; /* PCでは元の高さ */
         }
     }


    .dark .visualizer-container {
      background-color: rgba(255, 255, 255, 0.05);
    }

    canvas#visualizer { /* Specificity added */
      width: 100%;
      height: 100%;
      display: block; /* Remove potential extra space */
    }

    .youtube-container {
      position: relative;
      padding-bottom: 56.25%; /* 16:9 Aspect Ratio */
      height: 0;
      overflow: hidden;
      border-radius: 12px; /* Apply border radius */
      background-color: #000; /* Black background for loading */
      margin-bottom: 10px; /* Add some space below video */
    }

    .youtube-container iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .badge {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: var(--accent-color);
      color: white;
      padding: 2px 8px;
      border-radius: 12px;
      font-size: 0.75rem;
      z-index: 10;
    }

    .modal-close-btn {
      position: absolute;
      top: 10px;
      right: 15px;
      font-size: 1.8rem; /* Larger tap target */
      line-height: 1;
      background: none;
      border: none;
      cursor: pointer;
      color: var(--text-color);
      padding: 8px; /* Larger tap target */
      margin: -8px; /* Offset padding */
       transition: color 0.3s ease;
    }
     .modal-close-btn:hover {
         color: var(--accent-color);
     }

     /* Adjust snackbar position if bottom controls are visible */
     body.has-bottom-controls .snackbar {
        margin-bottom: calc(env(safe-area-inset-bottom, 0px) + 70px + 10px); /* Controls height + margin */
     }

    @media print {
      .scrollable-list-area {
        max-height: none;
        overflow: visible;
      }
    }


    /* Custom Playlist Styles */
    .user-playlist-item {
      padding: 10px;
      border-radius: 6px;
      margin-bottom: 5px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background-color: rgba(142, 36, 170, 0.05);
      transition: background-color 0.2s ease;
    }

    .user-playlist-item:hover {
      background-color: rgba(142, 36, 170, 0.15);
    }
     .dark .user-playlist-item {
         background-color: rgba(187, 134, 252, 0.1);
     }
     .dark .user-playlist-item:hover {
         background-color: rgba(187, 134, 252, 0.2);
     }

    .user-playlist-actions {
      display: flex;
      gap: 10px;
    }
    .playlist-count {
      padding: 2px 8px;
      background-color: var(--primary-color);
      color: white;
      border-radius: 10px;
      font-size: 0.75rem;
      margin-left: 8px;
       transition: background-color 0.3s ease;
    }
     .dark .playlist-count {
         color: var(--background-color);
     }

     /* Dropdown Styling */
     .dropdown { /* Add styling to the dropdown container */
         position: relative;
         display: inline-block;
     }
     .dropdown-menu {
        background-color: var(--card-color);
        border: 1px solid var(--border-color);
        transition: background-color 0.3s ease, border-color 0.3s ease;
        position: absolute; /* Position relative to .dropdown */
        right: 0;
        margin-top: 0.5rem; /* 8px */
        width: 12rem; /* 192px */
        border-radius: 0.375rem; /* 6px */
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        z-index: 20; /* Ensure it's above list items */
        /* Add max-height and overflow for scrollable dropdown */
        max-height: 8rem; /* 128px or adjust as needed */
        overflow-y: auto;
    }
    .dropdown-menu a { /* Style links inside dropdown */
        display: block;
        padding: 0.5rem 1rem; /* 8px 16px */
        font-size: 0.875rem; /* 14px */
        white-space: nowrap; /* Prevent wrapping */
    }
    .dropdown-menu a:hover {
       background-color: rgba(142, 36, 170, 0.1);
    }
     .dark .dropdown-menu a:hover {
        background-color: rgba(187, 134, 252, 0.15);
     }


    /* --- Mobile Specific Adjustments --- */
    @media (max-width: 1023px) { /* Below lg breakpoint */
      .app-container {
         padding: 0;
      }
       .app-container > header {
           /* Mobile header layout */
           flex-direction: column;
           align-items: flex-start;
           gap: 10px;
       }
       .app-container > header .flex.items-center.gap-4 { /* Search + buttons */
           width: 100%;
           justify-content: space-between;
       }
       .app-container > header .search-container {
           flex-grow: 1;
           margin-right: 10px;
       }
       .app-container > header .search-input {
           width: 100%;
       }
       .app-container > header .text-2xl { /* Main title */
           font-size: 1.5rem; /* text-xl */
       }
        .app-container > header .text-sm { /* Subtitle */
            font-size: 0.8rem;
        }
        .app-container > header .fa-music {
             font-size: 2rem; /* text-3xl */
        }


       .music-player {
           border-radius: 0;
           box-shadow: none;
       }

       /* Hide desktop player controls section */
       .player-controls { display: none; }
       /* Also hide the desktop volume control if it's separate */
       #desktop-volume-control { display: none; }

        /* Ensure main column takes only necessary space */
       .player-main-column {
           padding: 10px 10px 0 10px; /* Padding around player elements */
           flex-shrink: 0; /* Prevent shrinking */
           display: flex;
           flex-direction: column;
       }
        /* Ensure playlist column takes remaining space and handles scrolling */
       .playlist-column {
           padding: 0 10px 0 10px; /* Horizontal padding */
           display: flex;
           flex-direction: column;
           flex-grow: 1; /* Take remaining vertical space */
           overflow: hidden; /* Prevent container itself from scrolling */
           /* Add padding at bottom for fixed controls */
           padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 70px + 10px); /* Controls height + safe area + margin */
       }

        .tabs {
            margin-bottom: 5px;
            flex-shrink: 0; /* Prevent tabs from shrinking */
        }
        /* Make tab content area scrollable */
        .tab-content {
            flex-grow: 1; /* Take available space within playlist-column */
            overflow-y: auto; /* Enable scrolling for the content */
             -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
        }
        /* Remove fixed max-height from lists on mobile, let flexbox handle height */
        .scrollable-list-area {
            max-height: none;
            height: auto; /* Allow content to determine height */
        }

       .scrollable-list-area::-webkit-scrollbar {
           display: none; /* Hide scrollbar on mobile WebKit */
       }
       .scrollable-list-area {
           scrollbar-width: none; /* Hide scrollbar on Firefox */
       }

       .playlist-item, .history-item, .favorite-item {
          padding: 10px 5px; /* Adjust padding */
       }
       .playlist-item h3, .history-item h3, .favorite-item h3 { font-size: 0.9rem; }
       .playlist-item p, .history-item p, .favorite-item p { font-size: 0.75rem; }
       .playlist-item .w-10, .history-item .w-10, .favorite-item .w-10 { width: 36px; height: 36px; }

       /* Progress bar touch */
       .progress-container {
           height: 8px; /* Taller track for easier touch */
           border-radius: 8px;
           padding-top: 12px; /* Larger touch area above */
           padding-bottom: 12px; /* Larger touch area below */
           margin-top: -12px; /* Offset padding */
           margin-bottom: 5px; /* Space below progress */
       }
       .progress-bar { border-radius: 8px; }
        /* Ensure thumb is always visible on mobile */
        .progress-bar::after {
            width: 18px;
            height: 18px;
            transform: translate(50%, -50%) scale(1); /* Always visible */
        }


       /* Time display */
       .time-display {
          display: flex;
          justify-content: space-between; /* This should place times at ends */
          margin-top: 8px; /* Space above time */
       }
        #current-time, #total-time {
            font-size: 0.85rem;
            font-family: 'Poppins', sans-serif; /* Ensure font consistency */
            font-weight: 500;
            color: var(--text-color);
            opacity: 0.8; /* Slightly faded */
        }


    } /* End mobile styles */


    /* Fixed Bottom Controls (Mobile Only) */
    #bottom-controls {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background-color: var(--card-color);
        border-top: 1px solid var(--border-color);
        padding: 10px 15px;
        padding-bottom: calc(env(safe-area-inset-bottom, 0px) + 10px); /* iOS Safe Area */
        display: flex; /* Changed from none to flex */
        align-items: center;
        justify-content: space-between;
        z-index: 500; /* Ensure above content, below modals */
        transition: background-color 0.3s ease, border-color 0.3s ease;
        height: calc(env(safe-area-inset-bottom, 0px) + 70px); /* Add safe area to height */
    }
    /* Adjust button sizes and touch targets */
    #bottom-controls button {
        padding: 5px;
        min-width: 44px; /* Ensure min touch target width */
        min-height: 44px; /* Ensure min touch target height */
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0; /* Prevent shrinking */
    }
    #bottom-controls #btn-play-mobile { width: 50px; height: 50px; font-size: 1.8rem; }
    #bottom-controls #btn-prev-mobile, #bottom-controls #btn-next-mobile { font-size: 1.6rem; }
    #bottom-controls #btn-shuffle-mobile, #bottom-controls #btn-loop-mobile { font-size: 1.2rem; width: 35px; height: 35px; }

    /* Control layout for mobile */
    #bottom-controls .controls-left { order: 1; display: flex; align-items: center; gap: 15px; }
    #bottom-controls .controls-center { order: 2; display: flex; align-items: center; gap: 25px; flex-grow: 1; justify-content: center; }
    #bottom-controls .controls-right { order: 3; /* Currently empty, could hold volume toggle */ }

    /* Hide bottom controls on larger screens */
    @media (min-width: 1024px) {
        #bottom-controls { display: none; }
    }

     /* --- Now Playing Bar Styles --- */
     #now-playing-bar {
      /* Add transition for smooth appearance */
      transition: transform 0.3s ease-out, background-color 0.3s ease, border-color 0.3s ease;
    }

    #now-playing-bar.active {
      /* Slide in from bottom when active */
      transform: translateY(0);
    }

    /* Adjust main content padding when bar is active to prevent overlap */
    body.has-now-playing-bar #app > footer {
        /* Adjust this value (e.g., 70px) based on the actual height of your now-playing-bar */
        padding-bottom: 70px;
    }
     /* Adjust mobile bottom controls position if now playing bar is also visible */
     /* Note: This scenario might need careful UX consideration */
     body.has-now-playing-bar.has-bottom-controls #bottom-controls {
         /* Adjust this value based on now-playing-bar height */
         bottom: 68px;
     }
     /* Adjust snackbar position when now playing bar is active */
      body.has-now-playing-bar .snackbar {
         /* Calculate position considering bar height and safe area */
         /* Adjust the '68px' if your bar height is different */
         bottom: calc(env(safe-area-inset-bottom, 0px) + 68px + 10px); /* Bar height + margin */
      }
      /* If mobile controls are *also* active, stack snackbar higher */
       body.has-now-playing-bar.has-bottom-controls .snackbar {
            /* Adjust '68px' (bar height) and '70px' (controls height) if needed */
           bottom: calc(env(safe-area-inset-bottom, 0px) + 68px + 70px + 10px); /* Bar height + Controls height + margin */
       }


    /* Custom styling for range input thumb (Tailwind JIT might handle this better now) */
    #volume-slider-bar::-webkit-slider-thumb {
        background: var(--primary-color);
    }
    #volume-slider-bar::-moz-range-thumb {
        background: var(--primary-color);
    }

    /* Make clickable area larger for info */
    #now-playing-bar-info {
        min-width: 0; /* Prevent flex item from overflowing */
    }

  </style>
</head>

<body class=""> <!-- Start with no 'has-bottom-controls' class -->
  <div class="app-container" id="app">
    <header class="flex flex-col md:flex-row justify-between items-center mb-6 gap-4">
      <div class="flex items-center">
        <i class="fas fa-music text-4xl mr-3" style="color: var(--primary-color)"></i>
        <h1 class="text-2xl md:text-3xl font-bold">Rei Kikuchi <span class="text-sm md:text-base font-normal">Premium Music Player</span></h1>
      </div>
      <div class="flex items-center gap-4 w-full md:w-auto"> <!-- Ensure buttons container adapts -->
        <div class="search-container flex-grow md:flex-grow-0"> <!-- Allow search to grow on mobile -->
          <i class="fas fa-search search-icon"></i>
          <input type="text" id="search-input" class="search-input px-4 py-2 rounded-full w-full md:w-64 focusable" placeholder="曲名を検索...">
        </div>
        <!-- Buttons Container -->
        <div class="flex items-center gap-2 flex-shrink-0"> <!-- Prevent buttons shrinking -->
            <button id="offline-menu-btn" class="btn-mode btn-inactive focusable hidden" aria-label="オフラインキャッシュ管理">
              <i class="fas fa-cloud-download-alt"></i>
            </button>
            <button id="theme-toggle" class="btn-mode btn-inactive focusable" aria-label="テーマ切り替え" aria-pressed="false">
              <i class="fas fa-moon"></i>
            </button>
            <button id="account-btn" class="btn-mode btn-inactive focusable" aria-label="アカウント">
              <i class="fas fa-user"></i>
            </button>
        </div>
      </div>
    </header>

    <!-- プロフィールセクション -->
    <div id="profile-section" class="bg-gradient-to-r from-purple-100 to-indigo-100 dark:from-purple-900 dark:to-indigo-900 rounded-lg p-4 mb-6 shadow-md transition-all duration-300 ease-in-out mx-2 md:mx-0"> <!-- Add horizontal margin for mobile -->
      <div class="flex flex-col md:flex-row items-center justify-between">
        <div class="flex items-center mb-4 md:mb-0">
          <div class="w-16 h-16 md:w-20 md:h-20 rounded-full overflow-hidden border-4 border-white dark:border-gray-800 shadow-lg mr-4 flex-shrink-0">
            <img src="https://i.ytimg.com/vi/o3BudA6Qm6Y/hqdefault.jpg" alt="Rei Kikuchi" class="w-full h-full object-cover">
          </div>
          <div>
            <h2 class="text-xl md:text-2xl font-bold">Rei Kikuchi</h2>
            <p class="text-sm md:text-base opacity-75">音楽クリエイター / Riffusion アーティスト</p>
          </div>
        </div>
        <div class="flex flex-wrap gap-3 justify-center md:justify-end">
          <a href="https://www.youtube.com/channel/UCYAuSEKhuk3v4ZKzm5Lqb1Q" target="_blank" rel="noopener noreferrer" class="flex items-center px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-full transition-colors duration-200 shadow-md focusable">
            <i class="fab fa-youtube mr-2 text-lg"></i>
            <span>YouTube</span>
          </a>
          <a href="https://www.instagram.com/youtube_rei_kikuchi/" target="_blank" rel="noopener noreferrer" class="flex items-center px-4 py-2 bg-gradient-to-r from-purple-500 to-pink-500 hover:from-purple-600 hover:to-pink-600 text-white rounded-full transition-colors duration-200 shadow-md focusable">
            <i class="fab fa-instagram mr-2 text-lg"></i>
            <span>Instagram</span>
          </a>
          <a href="https://www.riffusion.com/u/REI_KIKUCHI" target="_blank" rel="noopener noreferrer" class="flex items-center px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-full transition-colors duration-200 shadow-md focusable">
            <i class="fas fa-music mr-2 text-lg"></i>
            <span>Riffusion</span>
          </a>
        </div>
      </div>
    </div>

    <!-- Main Player Structure -->
    <div class="music-player flex-grow flex flex-col"> <!-- Use flex-grow and flex-col -->
        <div class="music-player-grid flex-grow"> <!-- Grid takes remaining space -->
            <!-- Player Section (Main Column) -->
            <div class="player-main-column flex flex-col"> <!-- Column layout for player parts -->
                <div class="youtube-container mb-4 flex-shrink-0"> <!-- Video player area -->
                    <div id="youtube-player"></div>
                    <span id="now-playing-badge" class="badge hidden">NOW PLAYING</span>
                </div>
                <div class="flex justify-end mb-2 gap-2 flex-shrink-0"> <!-- Buttons below video -->
                     <!-- youtube-sync-btn will be added by JS -->
                    <button id="share-btn" class="px-3 py-1 rounded-md text-sm disabled:opacity-50 focusable" style="background-color: var(--border-color);" disabled>
                        <i class="fas fa-share-alt mr-1"></i> 共有
                    </button>
                    <button id="open-youtube-btn" class="px-3 py-1 rounded-md text-sm disabled:opacity-50 focusable" style="background-color: var(--border-color);" disabled>
                        <i class="fab fa-youtube mr-1"></i> YouTubeで開く
                    </button>
                </div>
                <div class="visualizer-container mb-4 flex-shrink-0"> <!-- Visualizer -->
                    <canvas id="visualizer"></canvas>
                </div>
                <div class="player-info mb-4 flex-shrink-0"> <!-- Song Info -->
                    <h2 id="current-song-title" class="text-xl font-bold truncate">選択された曲はありません</h2>
                    <p id="current-song-duration" class="text-sm opacity-75">--:--</p>
                </div>
                <div class="progress-container mb-2 flex-shrink-0"> <!-- Progress Bar -->
                    <div class="progress-bar" id="progress-bar"></div>
                </div>
                <!-- Time Display (Correctly styled for space-between) -->
                <div class="time-display mb-4 flex-shrink-0">
                    <span id="current-time">00:00</span>
                    <span id="total-time">00:00</span>
                </div>
                <!-- Desktop Controls (Hidden on Mobile) -->
                <div class="player-controls flex items-center justify-between mb-6 flex-shrink-0">
                    <div class="flex items-center gap-4">
                    <button id="btn-shuffle" class="text-xl btn-inactive rounded-full w-10 h-10 flex items-center justify-center focusable" aria-label="シャッフル" aria-pressed="false">
                        <i class="fas fa-random"></i>
                    </button>
                    <button id="btn-loop" class="text-xl btn-inactive rounded-full w-10 h-10 flex items-center justify-center focusable" aria-label="リピート: オフ">
                        <i class="fas fa-repeat"></i>
                    </button>
                    </div>
                    <div class="flex items-center gap-4">
                    <button id="btn-prev" class="text-2xl focusable" aria-label="前の曲">
                        <i class="fas fa-step-backward"></i>
                    </button>
                    <button id="btn-play" class="text-4xl btn-active rounded-full w-16 h-16 flex items-center justify-center focusable" aria-label="再生">
                        <i class="fas fa-play"></i>
                    </button>
                    <button id="btn-next" class="text-2xl focusable" aria-label="次の曲">
                        <i class="fas fa-step-forward"></i>
                    </button>
                    </div>
                    <div id="desktop-volume-control" class="flex items-center gap-2">
                        <i class="fas fa-volume-up text-sm" aria-hidden="true"></i>
                        <div class="volume-control">
                            <input type="range" id="volume-slider" min="0" max="100" value="100" aria-label="音量調整" class="focusable">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Playlist Section (Sidebar Column) -->
            <div class="playlist-column flex flex-col"> <!-- Column layout for tabs and lists -->
                <div class="tabs flex-shrink-0">
                    <div class="tab active focusable" data-tab="playlist" role="tab" aria-selected="true" tabindex="0">プレイリスト</div>
                    <div class="tab focusable" data-tab="history" role="tab" aria-selected="false" tabindex="0">再生履歴</div>
                    <div class="tab focusable" data-tab="favorites" role="tab" aria-selected="false" tabindex="0">お気に入り</div>
                    <div class="tab focusable" data-tab="user-playlists" role="tab" aria-selected="false" tabindex="0">マイプレイリスト</div>
                </div>

                <div id="playlist-tab" class="tab-content flex-grow" role="tabpanel">
                    <div class="playlist scrollable-list-area" id="playlist">
                        <div class="text-center py-8 text-gray-500">
                            <i class="fas fa-spinner fa-spin text-3xl mb-4"></i>
                            <p>楽曲を読み込み中...</p>
                        </div>
                    </div>
                </div>

                <div id="history-tab" class="tab-content hidden flex-grow" role="tabpanel">
                    <div class="history-list scrollable-list-area" id="history-list">
                        <div class="text-center py-8 text-gray-500">
                            <p>再生履歴はありません</p>
                        </div>
                    </div>
                </div>

                <div id="favorites-tab" class="tab-content hidden flex-grow" role="tabpanel">
                    <div class="favorites-list scrollable-list-area" id="favorites-list">
                        <div class="text-center py-8 text-gray-500">
                            <p>お気に入りに登録された曲はありません</p>
                        </div>
                    </div>
                </div>

                <div id="user-playlists-tab" class="tab-content hidden flex-grow" role="tabpanel">
                    <div class="mb-4 flex-shrink-0">
                        <button id="create-playlist-btn" class="px-3 py-1 rounded-md text-sm mb-4 focusable" style="background-color: var(--primary-color); color: white;">
                            <i class="fas fa-plus mr-1"></i> 新しいプレイリスト
                        </button>
                    </div>
                    <div class="user-playlists-list scrollable-list-area" id="user-playlists-list">
                        <div class="text-center py-8 text-gray-500">
                            <p>マイプレイリストはありません</p>
                        </div>
                    </div>
                </div>
            </div> <!-- End playlist-column -->
        </div> <!-- End music-player-grid -->
    </div> <!-- End music-player -->


    <!-- Modal Dialogs -->
    <div id="create-playlist-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="create-playlist-modal-title">
      <div class="modal-content">
        <div class="flex justify-between items-center mb-4">
          <h3 id="create-playlist-modal-title" class="text-lg font-bold">新しいプレイリストを作成</h3>
          <button class="modal-close-btn close-modal-btn focusable" data-modal-id="createPlaylist" aria-label="閉じる">×</button>
        </div>
        <div class="mb-4">
          <label for="playlist-name-input" class="block text-sm mb-2">プレイリスト名</label>
          <input type="text" id="playlist-name-input" class="w-full px-3 py-2 border rounded focusable" style="border-color: var(--border-color); background-color: var(--card-color);">
        </div>
        <div>
          <button id="save-playlist-btn" class="px-4 py-2 rounded text-white focusable" style="background-color: var(--primary-color);">保存</button>
        </div>
      </div>
    </div>

    <div id="share-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="share-modal-title">
      <div class="modal-content">
        <div class="flex justify-between items-center mb-4">
          <h3 id="share-modal-title" class="text-lg font-bold">共有</h3>
          <button class="modal-close-btn close-modal-btn focusable" data-modal-id="share" aria-label="閉じる">×</button>
        </div>
        <p id="share-object-title" class="mb-4"></p>
        <div class="flex gap-4 mb-4">
          <button class="share-option flex-1 px-3 py-2 rounded text-white focusable" style="background-color: #1DA1F2;">
            <i class="fab fa-twitter mr-2"></i> Twitter
          </button>
          <button class="share-option flex-1 px-3 py-2 rounded text-white focusable" style="background-color: #4267B2;">
            <i class="fab fa-facebook-f mr-2"></i> Facebook
          </button>
        </div>
        <div class="mb-4">
          <label for="share-link-input" class="block text-sm mb-2">共有リンク</label>
          <div class="flex">
            <input type="text" id="share-link-input" class="flex-1 px-3 py-2 border rounded-l focusable" style="border-color: var(--border-color); background-color: var(--card-color);" readonly>
            <button id="copy-link-btn" class="px-3 py-2 rounded-r text-white focusable" style="background-color: var(--primary-color);">コピー</button>
          </div>
        </div>
      </div>
    </div>

  <!-- アカウントモーダル（アップグレード版） -->
    <div id="account-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="account-modal-title">
        <div class="modal-content">
            <!-- ヘッダー -->
            <div class="flex justify-between items-center mb-4">
                <h3 id="account-modal-title" class="text-lg font-bold text-gray-800 dark:text-gray-200">アカウント設定</h3>
                <button class="modal-close-btn close-modal-btn focusable" data-modal-id="account" aria-label="閉じる">×</button>
            </div>

            <!-- ログインセクション -->
            <div id="login-section">
                <div class="mb-4">
                    <label for="login-email" class="block text-sm mb-2 text-gray-700 dark:text-gray-300">メールアドレス</label>
                    <input type="email" id="login-email" class="w-full px-3 py-2 border rounded focusable" style="border-color: var(--border-color); background-color: var(--card-color);">
                </div>
                <div class="mb-4">
                    <label for="login-password" class="block text-sm mb-2 text-gray-700 dark:text-gray-300">パスワード</label>
                    <input type="password" id="login-password" class="w-full px-3 py-2 border rounded focusable" style="border-color: var(--border-color); background-color: var(--card-color);">
                </div>
                <div class="mb-4 flex space-x-2">
                    <button id="login-btn" class="px-4 py-2 rounded text-white focusable" style="background-color: var(--primary-color);">ログイン</button>
                    <button id="show-register-btn" class="px-4 py-2 rounded focusable" style="background-color: var(--border-color);">新規登録</button>
                </div>
            </div>

            <!-- 登録セクション -->
            <div id="register-section" class="hidden">
                <div class="mb-4">
                    <label for="register-name" class="block text-sm mb-2 text-gray-700 dark:text-gray-300">ユーザー名</label>
                    <input type="text" id="register-name" class="w-full px-3 py-2 border rounded focusable" style="border-color: var(--border-color); background-color: var(--card-color);">
                </div>
                <div class="mb-4">
                    <label for="register-email" class="block text-sm mb-2 text-gray-700 dark:text-gray-300">メールアドレス</label>
                    <input type="email" id="register-email" class="w-full px-3 py-2 border rounded focusable" style="border-color: var(--border-color); background-color: var(--card-color);">
                </div>
                <div class="mb-4">
                    <label for="register-password" class="block text-sm mb-2 text-gray-700 dark:text-gray-300">パスワード</label>
                    <input type="password" id="register-password" class="w-full px-3 py-2 border rounded focusable" style="border-color: var(--border-color); background-color: var(--card-color);">
                </div>
                <div class="mb-4 flex space-x-2">
                    <button id="register-btn" class="px-4 py-2 rounded text-white focusable" style="background-color: var(--primary-color);">登録</button>
                    <button id="show-login-btn" class="px-4 py-2 rounded focusable" style="background-color: var(--border-color);">ログインに戻る</button>
                </div>
            </div>

            <!-- アカウント情報セクション -->
            <div id="account-info-section" class="hidden">
                <div class="mb-4 text-center">
                    <div class="w-16 h-16 rounded-full bg-gray-300 dark:bg-gray-600 flex items-center justify-center mx-auto mb-2">
                    <i class="fas fa-user text-3xl text-gray-700 dark:text-gray-200"></i>
                    </div>
                    <h4 id="user-name" class="font-bold text-gray-800 dark:text-gray-200"></h4>
                    <p id="user-email" class="text-sm opacity-75 text-gray-700 dark:text-gray-300"></p>
                </div>
                <div class="mb-4 space-y-2">
                    <button id="sync-data-btn" class="w-full px-4 py-2 rounded focusable" style="background-color: var(--border-color);">
                    <i class="fas fa-sync mr-2"></i> データを同期
                    </button>
                    <button id="logout-btn" class="w-full px-4 py-2 rounded text-white focusable" style="background-color: var(--accent-color);">
                    <i class="fas fa-sign-out-alt mr-2"></i> ログアウト
                    </button>
                </div>
            </div>
        </div>
    </div>



    <div id="playlist-detail-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="playlist-detail-modal-title">
       <div class="modal-content"> <!-- Removed max-h here, handled by list inside -->
         <div class="flex justify-between items-center mb-4">
           <h3 id="playlist-detail-title" class="text-lg font-bold">プレイリスト</h3>
           <button class="modal-close-btn close-modal-btn focusable" data-modal-id="playlistDetail" aria-label="閉じる">×</button>
         </div>
         <!-- Make the list scrollable, not the whole modal content -->
         <div id="playlist-detail-content" class="playlist-detail-list scrollable-list-area max-h-[60vh]"> <!-- Added scrollable class and max-height -->
           <p class="text-center py-8 text-gray-500">プレイリストを読み込み中...</p>
         </div>
         <div class="flex gap-2 mt-4">
           <button id="remove-from-playlist-btn" class="px-3 py-1 rounded text-sm hidden focusable" style="background-color: var(--accent-color); color: white;">
             <i class="fas fa-minus mr-1"></i> 選択を削除
           </button>
           <button id="share-playlist-btn" class="px-3 py-1 rounded text-sm ml-auto focusable" style="background-color: var(--primary-color); color: white;">
             <i class="fas fa-share-alt mr-1"></i> 共有
           </button>
         </div>
       </div>
     </div>

     <!-- Offline Modal (Dynamically created in JS, but placeholder structure) -->
     <div id="offline-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="offline-modal-title">
        <!-- Content added by JS in offlinePlayback.addOfflineUI -->
        <div class="modal-content">
            <!-- JS will populate this -->
        </div>
     </div>


    <div id="snackbar" class="snackbar"></div>

    <footer class="mt-8 text-center text-sm opacity-75 pb-4 md:pb-0"> <!-- Add padding bottom on mobile -->
      <p>© 2025 Rei Kikuchi Music Player | このプレイヤーはRei Kikuchiによって作られました</p>
    </footer>
  </div> <!-- End #app -->
 <!-- =========== Now Playing Bar (Mini Player) =========== -->
 <div id="now-playing-bar" class="fixed bottom-0 left-0 right-0 bg-white dark:bg-gray-800 shadow-lg border-t border-gray-200 dark:border-gray-700 z-[450] transition-transform duration-300 ease-out translate-y-full">
    <div class="max-w-screen-xl mx-auto px-4 py-2 flex items-center gap-4">
      <!-- Song Info -->
      <div class="flex items-center gap-3 flex-grow overflow-hidden cursor-pointer" id="now-playing-bar-info">
        <img id="now-playing-bar-thumb" src="" alt="Album Art" class="w-10 h-10 rounded object-cover bg-gray-300 dark:bg-gray-600 flex-shrink-0">
        <div class="overflow-hidden">
          <div id="now-playing-bar-title" class="text-sm font-medium truncate text-gray-900 dark:text-gray-100">曲が選択されていません</div>
          <div id="now-playing-bar-artist" class="text-xs text-gray-500 dark:text-gray-400 truncate">Rei Kikuchi</div>
        </div>
      </div>

      <!-- Desktop/Tablet Controls -->
      <div class="hidden md:flex items-center gap-4 flex-shrink-0">
         <button id="btn-prev-bar" class="text-gray-700 dark:text-gray-300 hover:text-primary-color dark:hover:text-primary-color focusable transition-colors" aria-label="前の曲">
           <i class="fas fa-step-backward text-lg"></i>
         </button>
         <button id="btn-play-bar" class="text-gray-700 dark:text-gray-300 hover:text-primary-color dark:hover:text-primary-color w-10 h-10 flex items-center justify-center rounded-full bg-gray-100 dark:bg-gray-700 focusable transition-colors" aria-label="再生">
           <i class="fas fa-play text-xl"></i>
         </button>
         <button id="btn-next-bar" class="text-gray-700 dark:text-gray-300 hover:text-primary-color dark:hover:text-primary-color focusable transition-colors" aria-label="次の曲">
           <i class="fas fa-step-forward text-lg"></i>
         </button>
      </div>

        <!-- Progress (Optional but nice) -->
       <div class="hidden lg:block w-40 flex-shrink-0 relative pt-1">
            <div id="now-playing-bar-progress-container" class="h-1 bg-gray-300 dark:bg-gray-600 rounded-full overflow-hidden cursor-pointer">
                <div id="now-playing-bar-progress" class="h-full bg-primary-color rounded-full" style="width: 0%;"></div>
            </div>
       </div>

       <!-- Volume (Optional, Desktop only maybe) -->
       <div class="hidden lg:flex items-center gap-2 flex-shrink-0">
            <i id="now-playing-bar-volume-icon" class="fas fa-volume-up text-sm text-gray-500 dark:text-gray-400" aria-hidden="true"></i>
            <input type="range" id="volume-slider-bar" min="0" max="100" value="100" aria-label="音量調整" class="w-20 h-1 bg-gray-300 dark:bg-gray-600 rounded-full appearance-none cursor-pointer focusable [&::-webkit-slider-thumb]:appearance-none [&::-webkit-slider-thumb]:h-3 [&::-webkit-slider-thumb]:w-3 [&::-webkit-slider-thumb]:rounded-full [&::-webkit-slider-thumb]:bg-primary-color">
        </div>

       <!-- Expand/Queue Button (Future) -->
       <!-- <button class="text-gray-600 dark:text-gray-400"><i class="fas fa-chevron-up"></i></button> -->
    </div>
  </div>
  <!-- =========== End Now Playing Bar =========== -->
  <!-- Fixed Bottom Controls (Mobile Only) -->
  <div id="bottom-controls" class="hidden"> <!-- Start hidden, shown by JS if needed -->
      <div class="controls-left">
          <button id="btn-shuffle-mobile" class="btn-inactive rounded-full focusable" aria-label="シャッフル" aria-pressed="false">
              <i class="fas fa-random"></i>
          </button>
          <button id="btn-loop-mobile" class="btn-inactive rounded-full focusable" aria-label="リピート: オフ">
              <i class="fas fa-repeat"></i>
          </button>
      </div>
      <div class="controls-center">
          <button id="btn-prev-mobile" class="focusable" aria-label="前の曲">
              <i class="fas fa-step-backward"></i>
          </button>
          <button id="btn-play-mobile" class="btn-active rounded-full focusable" aria-label="再生">
              <i class="fas fa-play"></i>
          </button>
          <button id="btn-next-mobile" class="focusable" aria-label="次の曲">
              <i class="fas fa-step-forward"></i>
          </button>
      </div>
      <div class="controls-right">
          <!-- Placeholder for potential volume toggle or other controls -->
      </div>
  </div>

  <!-- YouTube API -->
  <script src="https://www.youtube.com/iframe_api"></script>
   <script>
    // ==========================================================================
    // Constants
    // ==========================================================================
    const MAX_HISTORY = 20;
    const VOLUME_STEP = 5; // For keyboard control
    const SEEK_STEP = 5; // For keyboard control (seconds)

    // ==========================================================================
    // Data and State Management
    // ==========================================================================
    const appState = {
      player: null,
      songs: [],
      filteredSongs: [], // Currently displayed songs in the main playlist tab
      currentSongIndex: -1, // Index within the original `songs` array
      isPlaying: false,
      isShuffle: false,
      loopMode: 'none', // 'none', 'one', 'all'
      currentTab: 'playlist',
      volume: 100,
      progressInterval: null,
      history: [],
      favorites: [],
      userPlaylists: [],
      currentSelectedPlaylistId: null, // Renamed for clarity
      loggedInUser: null,
      snackbarTimeoutId: null, // For managing snackbar display
      activeModalId: null, // Track the currently open modal
      isPlayerReady: false,
      isBarVisible: false, // Track if the Now Playing Bar should be visible
      visualizer: {
          context: null, // Not used for actual AudioContext here
          analyser: null,  // Not used for actual AnalyserNode here
          animationFrameId: null,
          bufferLength: 0,
          dataArray: null,
          canvas: null,
          canvasCtx: null,
      }
    };

    // ==========================================================================
    // Elements (Will be initialized in onPlayerReady)
    // ==========================================================================
    let elements = {}; // Declare elements object, initialize later

    function initializeElements() {
        elements = {
            app: document.getElementById('app'),
            body: document.body, // body要素を追加
            playlist: document.getElementById('playlist'),
            historyList: document.getElementById('history-list'),
            favoritesList: document.getElementById('favorites-list'),
            userPlaylistsList: document.getElementById('user-playlists-list'),
            currentSongTitle: document.getElementById('current-song-title'),
            currentSongDuration: document.getElementById('current-song-duration'),
            progressBar: document.getElementById('progress-bar'),
            progressContainer: document.querySelector('.progress-container'),
            currentTime: document.getElementById('current-time'),
            totalTime: document.getElementById('total-time'),
            // Desktop Controls
            btnPlay: document.getElementById('btn-play'),
            btnPrev: document.getElementById('btn-prev'),
            btnNext: document.getElementById('btn-next'),
            btnShuffle: document.getElementById('btn-shuffle'),
            btnLoop: document.getElementById('btn-loop'),
            volumeSlider: document.getElementById('volume-slider'),
            // --- General UI ---
            themeToggle: document.getElementById('theme-toggle'),
            searchInput: document.getElementById('search-input'),
            tabs: document.querySelectorAll('.tab'),
            tabContents: document.querySelectorAll('.tab-content'),
            visualizerCanvas: document.getElementById('visualizer'),
            nowPlayingBadge: document.getElementById('now-playing-badge'),
            openYouTubeBtn: document.getElementById('open-youtube-btn'),
            shareBtn: document.getElementById('share-btn'),
            createPlaylistBtn: document.getElementById('create-playlist-btn'),
            // youtubeSyncBtn: document.getElementById('youtube-sync-btn'), // Added dynamically by setupYouTubeSync
            offlineMenuBtn: document.getElementById('offline-menu-btn'), // Offline button
            // --- Modals ---
            modals: { // モーダル要素をここに集約
                createPlaylist: document.getElementById('create-playlist-modal'),
                playlistDetail: document.getElementById('playlist-detail-modal'),
                share: document.getElementById('share-modal'),
                account: document.getElementById('account-modal'),
                offline: document.getElementById('offline-modal') // Add offline modal placeholder
            },
            // --- Modal Close Buttons ---
            modalCloseBtns: document.querySelectorAll('.close-modal-btn'), // 閉じるボタンを一括取得
            // --- Modal Specific Buttons ---
            modalButtons: {
                savePlaylist: document.getElementById('save-playlist-btn'),
                removeFromPlaylist: document.getElementById('remove-from-playlist-btn'),
                sharePlaylist: document.getElementById('share-playlist-btn'),
                copyLink: document.getElementById('copy-link-btn'),
                login: document.getElementById('login-btn'),
                showRegister: document.getElementById('show-register-btn'),
                register: document.getElementById('register-btn'),
                showLogin: document.getElementById('show-login-btn'),
                syncData: document.getElementById('sync-data-btn'),
                logout: document.getElementById('logout-btn'),
                account: document.getElementById('account-btn') // ヘッダーのアカウントボタン
            },
            // --- Account Sections and Fields ---
            accountSections: {
                login: document.getElementById('login-section'),
                register: document.getElementById('register-section'),
                accountInfo: document.getElementById('account-info-section')
            },
            accountFields: {
                loginEmail: document.getElementById('login-email'),
                loginPassword: document.getElementById('login-password'),
                registerName: document.getElementById('register-name'),
                registerEmail: document.getElementById('register-email'),
                registerPassword: document.getElementById('register-password'),
                userName: document.getElementById('user-name'),
                userEmail: document.getElementById('user-email')
            },
            // --- Playlist Related Elements ---
            playlistElements: {
                nameInput: document.getElementById('playlist-name-input'),
                detailTitle: document.getElementById('playlist-detail-title'),
                detailContent: document.getElementById('playlist-detail-content'),
                shareObjectTitle: document.getElementById('share-object-title'),
                shareLinkInput: document.getElementById('share-link-input')
            },
            snackbar: document.getElementById('snackbar'),
            // --- Mobile Bottom Controls ---
            bottomControls: document.getElementById('bottom-controls'),
            btnPlayMobile: document.getElementById('btn-play-mobile'),
            btnPrevMobile: document.getElementById('btn-prev-mobile'),
            btnNextMobile: document.getElementById('btn-next-mobile'),
            btnShuffleMobile: document.getElementById('btn-shuffle-mobile'),
            btnLoopMobile: document.getElementById('btn-loop-mobile'),
            // --- Now Playing Bar Elements ---
            nowPlayingBar: document.getElementById('now-playing-bar'),
            nowPlayingBarInfo: document.getElementById('now-playing-bar-info'),
            nowPlayingBarThumb: document.getElementById('now-playing-bar-thumb'),
            nowPlayingBarTitle: document.getElementById('now-playing-bar-title'),
            nowPlayingBarArtist: document.getElementById('now-playing-bar-artist'),
            btnPlayBar: document.getElementById('btn-play-bar'),
            btnPrevBar: document.getElementById('btn-prev-bar'),
            btnNextBar: document.getElementById('btn-next-bar'),
            nowPlayingBarProgress: document.getElementById('now-playing-bar-progress'),
            nowPlayingBarProgressContainer: document.getElementById('now-playing-bar-progress-container'),
            volumeSliderBar: document.getElementById('volume-slider-bar'),
            volumeIconBar: document.getElementById('now-playing-bar-volume-icon'),
        };
        // Optional: Add checks here to ensure critical elements were found
        if (!elements.btnPlay) console.warn("Desktop Play button not found during initialization.");
        if (!elements.btnPlayMobile) console.warn("Mobile Play button not found during initialization.");
        if (!elements.nowPlayingBar) console.error("Now Playing Bar not found during initialization!");
        if (!elements.playlist) console.error("ERROR: Playlist container not found during initialization!");
        if (!elements.modals.account) console.error("ERROR: Account Modal not found during initialization!");
        if (!elements.visualizerCanvas) console.error("ERROR: Visualizer Canvas not found during initialization!");
        // Add more checks as needed
    }


    // ==========================================================================
    // YouTube Player Initialization
    // ==========================================================================
    function onYouTubeIframeAPIReady() {
      console.log("onYouTubeIframeAPIReady called");
      try {
        appState.player = new YT.Player('youtube-player', {
          height: '100%',
          width: '100%',
          videoId: '', // Start empty
          playerVars: {
            'autoplay': 0, 'controls': 0, 'rel': 0, 'showinfo': 0,
            'modestbranding': 1, 'fs': 0, 'playsinline': 1
          },
          events: {
            'onReady': onPlayerReady,
            'onStateChange': onPlayerStateChange,
            'onError': onPlayerError
          }
        });
      } catch (error) {
          console.error("Error initializing YouTube Player:", error);
          showSnackbar("プレイヤーの初期化に失敗しました。");
      }
    }

    function onPlayerReady(event) {
      console.log("Player Ready");

      // ***** INITIALIZE ELEMENTS HERE *****
      initializeElements();
      // ***** END INITIALIZE ELEMENTS *****

      appState.isPlayerReady = true;
      if(elements.volumeSlider) elements.volumeSlider.value = appState.volume; // Now elements are initialized
      else console.warn("Volume slider element not found after init.");
      if(elements.volumeSliderBar) elements.volumeSliderBar.value = appState.volume; // Init bar slider too

      if(event.target && typeof event.target.setVolume === 'function') {
          try { event.target.setVolume(appState.volume); } catch (e) { console.warn("Failed to set initial volume", e)}
      }

      // Load songs *after* player is ready and elements are initialized
      loadSongsFromYouTube(); // Load from API
      loadUserData(); // Load local data
      initAudioAnalyser(); // Setup visualizer canvas
      setupEventListeners(); // Setup UI interactions *after* elements are initialized
      handleUrlParams(); // Check for shared links etc.
      checkBottomControlsVisibility(); // Setup mobile/desktop view differences

      // Initialize YouTube Sync and Offline features *after* player is ready and elements are known
      setupYouTubeSync();
      // offlinePlayback.init(); // Offline features disabled if service-worker.js is not ready

      console.log("Player initialization sequence complete.");
    }


    function onPlayerStateChange(event) {
      console.log("Player State Changed:", event.data);
      const playerState = event.data;
      const isPlaying = playerState === YT.PlayerState.PLAYING;
      const isPaused = playerState === YT.PlayerState.PAUSED;
      const isEnded = playerState === YT.PlayerState.ENDED;
      const isCued = playerState === YT.PlayerState.CUED;
      const isBuffering = playerState === YT.PlayerState.BUFFERING;

      // --- Start: Visualizer State Update ---
      const previousIsPlaying = appState.isPlaying; // Store previous state
      appState.isPlaying = isPlaying; // Update global state
      // --- End: Visualizer State Update ---

      // --- Update Main Player UI ---
      elements.nowPlayingBadge?.classList.toggle('hidden', !isPlaying);
      elements.shareBtn?.toggleAttribute('disabled', !isPlaying);
      elements.openYouTubeBtn?.toggleAttribute('disabled', !currentSongData()?.id);

      const playIcon = '<i class="fas fa-play"></i>';
      const pauseIcon = '<i class="fas fa-pause"></i>';
      const playLabel = '再生';
      const pauseLabel = '一時停止';

      if (elements.btnPlay) {
          elements.btnPlay.innerHTML = isPlaying ? pauseIcon : playIcon;
          elements.btnPlay.setAttribute('aria-label', isPlaying ? pauseLabel : playLabel);
      }
      if (elements.btnPlayMobile) {
          elements.btnPlayMobile.innerHTML = isPlaying ? pauseIcon : playIcon;
          elements.btnPlayMobile.setAttribute('aria-label', isPlaying ? pauseLabel : playLabel);
      }
      // === Call Update for Now Playing Bar ===
      updateNowPlayingBar();
      // =====================================

      if (isPlaying) {
          console.log("[DEBUG] Player is PLAYING, starting progress update.");
          startProgressUpdate();
          const song = currentSongData();
          if (song) {
              addToHistory(song);
              renderHistoryList();
          }
          // --- Start: Visualizer Loop Start Logic (Modified) ---
          if (appState.visualizer.animationFrameId === null) {
              console.log("[DEBUG] Starting visualizer loop...");
              drawVisualizer(); // Start visualizer loop
          } else {
              console.log("[DEBUG] Visualizer loop already running. ID:", appState.visualizer.animationFrameId);
          }
          // --- End: Visualizer Loop Start Logic ---

      } else if (isPaused || isCued || isEnded || isBuffering) { // Include Buffering here to stop progress
          console.log("[DEBUG] Player is NOT PLAYING (or buffering), stopping progress update. State:", playerState);
          stopProgressUpdate();

          // --- Start: Visualizer Loop Stop Logic (No change needed, handled within drawVisualizer) ---
          // --- End: Visualizer Loop Stop Logic ---

          // Reset progress bar to 0 if song ended or cued
          if (isCued || isEnded) {
              updateProgress(); // Ensure progress bar shows 00:00 / duration
          }
          updateNowPlayingBar(); // Ensure bar reflects paused state
      }

      if (isEnded) {
          handleSongEnd(); // Handle song ending logic (loop, next)
      }
    }
     function onPlayerError(event) {
         console.error("YouTube Player Error:", event.data);
         let errorMessage = "動画の再生中にエラーが発生しました。";
         switch (event.data) {
             case 2: errorMessage = "再生リクエストが無効です。"; break;
             case 5: errorMessage = "プレイヤー内部のエラーが発生しました。"; break;
             case 100: errorMessage = "動画が見つからないか、削除されました。"; break;
             case 101: case 150: errorMessage = "この動画は埋め込み再生が許可されていません。"; break;
             default: errorMessage = `不明なエラーが発生しました (コード: ${event.data})。`;
         }
         showSnackbar(errorMessage);
         // Reset player state visually
         const playIcon = '<i class="fas fa-play"></i>';
         const playLabel = '再生';
         if (elements.btnPlay) {
            elements.btnPlay.innerHTML = playIcon;
            elements.btnPlay.setAttribute('aria-label', playLabel);
         }
         if (elements.btnPlayMobile) {
             elements.btnPlayMobile.innerHTML = playIcon;
             elements.btnPlayMobile.setAttribute('aria-label', playLabel);
         }
         appState.isPlaying = false;
         elements.nowPlayingBadge?.classList.add('hidden');
         stopProgressUpdate();
         // Stop visualizer if running
         if (appState.visualizer.animationFrameId !== null) {
            cancelAnimationFrame(appState.visualizer.animationFrameId);
            appState.visualizer.animationFrameId = null;
            if (appState.visualizer.canvasCtx && appState.visualizer.canvas) {
                 appState.visualizer.canvasCtx.clearRect(0, 0, appState.visualizer.canvas.width, appState.visualizer.canvas.height);
            }
         }
         resetPlayerInfo();
         updateNowPlayingBar(); // Update bar to show reset state
     }

    // ==========================================================================
    // App Initialization Functions
    // ==========================================================================
    async function loadSongsFromYouTube() {
      try {
        // Render loading state
        showLoadingIndicator(elements.playlist);

        // Get latest video IDs and basic info
        const videos = await youtubeAPI.getLatestVideos(15); // Adjust count as needed
        if (videos.length === 0) {
          showSnackbar("新しい動画は見つかりませんでした");
          showEmptyMessage(elements.playlist, "曲が見つかりません"); // Show empty message
          return;
        }
        const videoIds = videos.map(video => video.id.trim());

        // Get duration details for these videos
        const videoDetails = await youtubeAPI.getVideoDetails(videoIds);

        // Merge details (duration) into the video list
        appState.songs = videos.map(video => {
          const details = videoDetails.find(detail => detail.id === video.id) || {};
          return {
            id: video.id.trim(),
            title: video.title,
            duration: details.duration || '--:--', // Use fetched duration or fallback
            thumbnail: video.thumbnail
          };
        });
        appState.filteredSongs = [...appState.songs];
        renderPlaylist(); // Render the updated list
      } catch (error) {
        console.error("動画データの取得または処理に失敗しました", error);
        showSnackbar("動画データの取得に失敗しました");
        showEmptyMessage(elements.playlist, "曲の読み込みに失敗しました"); // Show error message
      }
    }


    function showLoadingIndicator(container) {
        if (!container) return;
        container.innerHTML = `
            <div class="text-center py-8 text-gray-500">
                <i class="fas fa-spinner fa-spin text-3xl mb-4"></i>
                <p>読み込み中...</p>
            </div>`;
    }

    function hideLoadingIndicator(container) {
        // The container's content will be replaced by render functions,
        // so direct removal isn't always needed if render follows immediately.
        // However, if rendering fails, this ensures the spinner is gone.
        const spinner = container?.querySelector('.fa-spinner');
        if (spinner) {
            spinner.parentElement.remove();
        }
    }
     function showEmptyMessage(container, message) {
         if (!container) return;
         container.innerHTML = `<div class="text-center py-8 text-gray-500"><p>${escapeHTML(message)}</p></div>`;
     }


    function loadUserData() {
      console.log("Loading user data from localStorage...");
      try {
          const storedHistory = localStorage.getItem('reiKikuchiPlayerHistory');
          const storedFavorites = localStorage.getItem('reiKikuchiPlayerFavorites');
          const storedPlaylists = localStorage.getItem('reiKikuchiPlayerPlaylists');
          const storedUser = localStorage.getItem('reiKikuchiPlayerUser');
          const savedTheme = localStorage.getItem('reiKikuchiPlayerTheme');

          appState.history = storedHistory ? JSON.parse(storedHistory) : [];
          appState.favorites = storedFavorites ? JSON.parse(storedFavorites) : [];
          appState.userPlaylists = storedPlaylists ? JSON.parse(storedPlaylists) : [];
          appState.loggedInUser = storedUser ? JSON.parse(storedUser) : null;

          // Apply theme preference
          const isDark = savedTheme === 'dark';
          if(elements.body) elements.body.classList.toggle('dark', isDark);
          if(elements.themeToggle) {
              elements.themeToggle.innerHTML = isDark ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
              elements.themeToggle.classList.toggle('btn-active', isDark);
              elements.themeToggle.classList.toggle('btn-inactive', !isDark);
              elements.themeToggle.setAttribute('aria-pressed', isDark);
          }

          // Render lists based on loaded data (render functions handle empty states)
          renderHistoryList();
          renderFavoritesList();
          renderUserPlaylists();
          updateAccountUI(!!appState.loggedInUser); // Update account button/state based on loaded user
          console.log("User data loaded.");
      } catch(error) {
          console.error("Error loading user data:", error);
          showSnackbar("ユーザーデータの読み込みに失敗しました。");
          // Reset to defaults if loading fails?
          appState.history = [];
          appState.favorites = [];
          appState.userPlaylists = [];
          appState.loggedInUser = null;
          // Optionally clear relevant localStorage items
          // localStorage.removeItem('reiKikuchiPlayerHistory');
      }
    }

        // 修正箇所: initAudioAnalyser 関数
        function initAudioAnalyser() {
      console.log("Initializing visualizer...");
      try {
        appState.visualizer.canvas = elements.visualizerCanvas;
        if (!appState.visualizer.canvas) {
            console.error("Visualizer canvas element not found.");
            return;
        }
        appState.visualizer.canvasCtx = appState.visualizer.canvas.getContext('2d');
        if (!appState.visualizer.canvasCtx) {
            console.error("Failed to get 2D context for visualizer canvas.");
            return;
        }
        // Set a buffer length for the simulated data
        appState.visualizer.bufferLength = 64;
        appState.visualizer.dataArray = new Uint8Array(appState.visualizer.bufferLength);
        console.log("Visualizer canvas and context obtained.");

        // --- Start: Initial Resize and Draw (Modified) ---
        // Delay the initial resize/draw slightly using requestAnimationFrame
        // to ensure the rendering context and potentially CSS are ready.
        requestAnimationFrame(() => {
            try {
                 resizeCanvas(); // Set initial size AND trigger an initial draw in the next frame
                 console.log("Initial resizeCanvas called via requestAnimationFrame.");
            } catch(resizeError) {
                 console.error("Error during initial resizeCanvas call:", resizeError);
                 if(elements.visualizerCanvas) elements.visualizerCanvas.style.display = 'none'; // Hide on error
            }
        });
        // --- End: Initial Resize and Draw ---

      } catch (error) {
        console.error('Visualizer setup failed during init:', error); // Log specific init error
        if(elements.visualizerCanvas) elements.visualizerCanvas.style.display = 'none'; // Hide if setup fails
      }
    }

    // ==========================================================================
    // Event Listener Setup
    // ==========================================================================
    function setupEventListeners() {
      console.log("Setting up event listeners...");

      // Player Controls (Desktop) - Add null checks
      elements.btnPlay?.addEventListener('click', togglePlayPause);
      elements.btnNext?.addEventListener('click', playNextSong);
      elements.btnPrev?.addEventListener('click', playPreviousSong);
      elements.btnShuffle?.addEventListener('click', toggleShuffle);
      elements.btnLoop?.addEventListener('click', toggleLoopMode);
      elements.volumeSlider?.addEventListener('input', handleVolumeChange);
      elements.progressContainer?.addEventListener('click', seekToPosition);

       // Player Controls (Mobile) - Add null checks
       elements.btnPlayMobile?.addEventListener('click', togglePlayPause);
       elements.btnNextMobile?.addEventListener('click', playNextSong);
       elements.btnPrevMobile?.addEventListener('click', playPreviousSong);
       elements.btnShuffleMobile?.addEventListener('click', toggleShuffle);
       elements.btnLoopMobile?.addEventListener('click', toggleLoopMode);


      // Header Controls
      elements.themeToggle?.addEventListener('click', toggleTheme);
      elements.searchInput?.addEventListener('input', handleSearch);
      elements.modalButtons.account?.addEventListener('click', showAccountModal); // Header account button
      // elements.youtubeSyncBtn is added dynamically, listener attached in setupYouTubeSync
      // elements.offlineMenuBtn?.addEventListener('click', () => offlinePlayback.showOfflineModal()); // Offline button - Disabled

       // Action Buttons
       elements.shareBtn?.addEventListener('click', showShareModal);
       elements.openYouTubeBtn?.addEventListener('click', handleOpenYouTube);

      // Tab switching
      elements.tabs?.forEach(tab => {
        tab.addEventListener('click', () => switchTab(tab.dataset.tab));
        tab.addEventListener('keydown', (e) => { // Keyboard activation for tabs
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                switchTab(tab.dataset.tab);
            }
        });
      });

      // ---- Event Delegation for Lists ----
      setupListEventListeners(elements.playlist, handlePlaylistClick);
      setupListEventListeners(elements.historyList, handleHistoryClick);
      setupListEventListeners(elements.favoritesList, handleFavoritesClick);
      setupListEventListeners(elements.userPlaylistsList, handleUserPlaylistsClick);
      setupListEventListeners(elements.playlistElements?.detailContent, handlePlaylistDetailClick);

      // My Playlists Tab Button
      elements.createPlaylistBtn?.addEventListener('click', showCreatePlaylistModal);

      // --- Modal Close Buttons ---
       elements.modalCloseBtns?.forEach(btn => {
         btn.addEventListener('click', () => {
             const modalId = btn.dataset.modalId;
             if (modalId) {
                 hideModal(modalId);
             } else {
                 console.error("Close button clicked, but data-modal-id is missing:", btn);
             }
         });
       });

      // --- Modal Specific Action Buttons ---
      elements.modalButtons.savePlaylist?.addEventListener('click', saveNewPlaylist);
      elements.modalButtons.removeFromPlaylist?.addEventListener('click', removeSongFromPlaylist);
      elements.modalButtons.sharePlaylist?.addEventListener('click', sharePlaylist);
      elements.modalButtons.copyLink?.addEventListener('click', copyShareLink);

      // --- Account Modal Action Buttons ---
      elements.modalButtons.showRegister?.addEventListener('click', () => switchAuthSection('register'));
      elements.modalButtons.showLogin?.addEventListener('click', () => switchAuthSection('login'));
      elements.modalButtons.login?.addEventListener('click', handleLogin); // Login button inside modal
      elements.modalButtons.register?.addEventListener('click', handleRegister);
      elements.modalButtons.logout?.addEventListener('click', handleLogout);
      elements.modalButtons.syncData?.addEventListener('click', syncUserData);

       // --- Now Playing Bar Controls ---
       elements.btnPlayBar?.addEventListener('click', togglePlayPause); // Reuse existing function
       elements.btnPrevBar?.addEventListener('click', playPreviousSong); // Reuse existing function
       elements.btnNextBar?.addEventListener('click', playNextSong); // Reuse existing function
       elements.volumeSliderBar?.addEventListener('input', handleVolumeChangeBar); // New handler needed if separate logic
       elements.nowPlayingBarProgressContainer?.addEventListener('click', seekToPositionBar); // New handler needed if separate logic
       // Optional: Click on song info could open full player view or something
       // elements.nowPlayingBarInfo?.addEventListener('click', () => { /* Future action */ });


       // --- Close Modals on Backdrop Click ---
       if (elements.modals) {
           Object.entries(elements.modals).forEach(([modalId, modal]) => { // Use entries to get key/value
               if (modal) {
                   modal.addEventListener('click', (e) => {
                       if (e.target === modal) { // Clicked on the backdrop itself
                           hideModal(modalId);
                       }
                   });
               } else {
                   // console.warn(`Modal element for ID '${modalId}' is null or undefined.`);
               }
           });
       }

       // --- Global Keydowns ---
       document.addEventListener('keydown', handleGlobalKeyDown);

      // --- Window Resize ---
      window.addEventListener('resize', resizeCanvas); // Visualizer canvas resize
      window.addEventListener('resize', checkBottomControlsVisibility); // Mobile controls visibility

      console.log("Event listeners setup complete.");
    }

    // Helper for setting up delegated event listeners on lists
    function setupListEventListeners(listElement, handler) {
        if (listElement) {
            listElement.addEventListener('click', handler);
        } else {
            // console.warn("List element not found for event delegation."); // Less noisy log
        }
    }

    // --- New Handlers for Bar Controls ---
    function handleVolumeChangeBar() {
        if(!elements.volumeSliderBar) return;
        const volume = parseInt(elements.volumeSliderBar.value);
        setVolume(volume); // Reuse existing setVolume function
        // Update volume icon based on level (optional)
        updateVolumeIcon(elements.volumeIconBar, volume);
    }

    function seekToPositionBar(event) {
        if (!appState.isPlayerReady || !currentSongId() || !elements.nowPlayingBarProgressContainer || !appState.player) return;
        const rect = elements.nowPlayingBarProgressContainer.getBoundingClientRect();
        const clickX = event.clientX - rect.left; // Use clientX for fixed bar
        const clampedX = Math.max(0, Math.min(clickX, rect.width));
        if (rect.width <= 0) return;
        const percent = clampedX / rect.width;
        try {
            const duration = appState.player.getDuration();
            if (duration > 0) {
                const seekTime = duration * percent;
                appState.player.seekTo(seekTime, true);
                updateProgress(); // Update both progress bars
            }
        } catch (error) {
            console.error("Error seeking on bar:", error);
            showSnackbar("シーク中にエラーが発生しました。");
         }
    }

     // Helper to update volume icon
     function updateVolumeIcon(iconElement, volume) {
         if (!iconElement) return;
         if (volume === 0) {
             iconElement.className = iconElement.className.replace(/fa-volume-([\w-]+)/, 'fa-volume-mute');
         } else if (volume < 50) {
             iconElement.className = iconElement.className.replace(/fa-volume-([\w-]+)/, 'fa-volume-down');
         } else {
             iconElement.className = iconElement.className.replace(/fa-volume-([\w-]+)/, 'fa-volume-up');
         }
     }

    // ==========================================================================
    // Event Handlers for Delegated List Clicks
    // ==========================================================================
    function handlePlaylistClick(event) {
        const target = event.target;
        const playlistItem = target.closest('.playlist-item');
        const favoriteBtn = target.closest('.favorite-btn');
        const addToPlaylistBtn = target.closest('.add-to-playlist-btn');
        const selectPlaylistLink = target.closest('.select-playlist');

        if (!playlistItem) { // Clicked outside any item
            closeAllPlaylistDropdowns();
            return;
        }

        const songId = playlistItem.dataset.id;

        if (favoriteBtn) {
            event.stopPropagation();
            toggleFavorite(songId);
        } else if (addToPlaylistBtn) {
            event.stopPropagation();
            togglePlaylistDropdown(addToPlaylistBtn);
        } else if (selectPlaylistLink) {
            event.preventDefault();
            event.stopPropagation();
            const playlistId = selectPlaylistLink.dataset.playlistid;
            addSongToPlaylist(songId, playlistId);
            closeAllPlaylistDropdowns();
        } else { // Clicked on the item itself (play song)
            const originalIndex = findSongIndexById(songId);
            if (originalIndex !== -1) {
                playSong(originalIndex);
                closeAllPlaylistDropdowns();
            } else {
                console.warn("Song ID not found in appState.songs:", songId);
                showSnackbar("曲が見つかりませんでした。");
            }
        }
    }

    function handleHistoryClick(event) {
        const target = event.target;
        const historyItem = target.closest('.history-item');
        if (!historyItem) {
            closeAllPlaylistDropdowns();
            return;
        }
        const songId = historyItem.dataset.id;
        const favoriteBtn = target.closest('.favorite-btn');
        const addToPlaylistBtn = target.closest('.add-to-playlist-btn');
        const selectPlaylistLink = target.closest('.select-playlist');

        if (favoriteBtn) {
            event.stopPropagation();
            toggleFavorite(songId);
        } else if (addToPlaylistBtn) {
            event.stopPropagation();
            togglePlaylistDropdown(addToPlaylistBtn);
        } else if (selectPlaylistLink) {
            event.preventDefault();
            event.stopPropagation();
            addSongToPlaylist(songId, selectPlaylistLink.dataset.playlistid);
            closeAllPlaylistDropdowns();
        } else { // Play song
            const originalIndex = findSongIndexById(songId);
            if (originalIndex !== -1) playSong(originalIndex);
            else showSnackbar("曲が見つかりませんでした。");
            closeAllPlaylistDropdowns();
        }
    }

    function handleFavoritesClick(event) {
        const target = event.target;
        const favoriteItem = target.closest('.favorite-item');
         if (!favoriteItem) {
            closeAllPlaylistDropdowns();
            return;
        }
        const songId = favoriteItem.dataset.id;
        const favoriteBtn = target.closest('.favorite-btn');
        const addToPlaylistBtn = target.closest('.add-to-playlist-btn');
        const selectPlaylistLink = target.closest('.select-playlist');

        if (favoriteBtn) {
            event.stopPropagation();
            toggleFavorite(songId); // Will remove it
        } else if (addToPlaylistBtn) {
            event.stopPropagation();
            togglePlaylistDropdown(addToPlaylistBtn);
        } else if (selectPlaylistLink) {
            event.preventDefault();
            event.stopPropagation();
            addSongToPlaylist(songId, selectPlaylistLink.dataset.playlistid);
            closeAllPlaylistDropdowns();
        } else { // Play song
            const originalIndex = findSongIndexById(songId);
            if (originalIndex !== -1) playSong(originalIndex);
            else showSnackbar("曲が見つかりませんでした。");
            closeAllPlaylistDropdowns();
        }
    }

    function handleUserPlaylistsClick(event) {
     const target = event.target;
     const playlistItem = target.closest('.user-playlist-item');
     if (!playlistItem) {
         return; // Click outside items
     }

     const playlistId = playlistItem.dataset.id;
     // console.log(`[DEBUG] UserPlaylists: Clicked item with ID: ${playlistId}`);

     const playBtn = target.closest('.playlist-play-btn'); // Currently commented out in HTML
     const editBtn = target.closest('.playlist-edit-btn'); // View/Edit button
     const deleteBtn = target.closest('.playlist-delete-btn'); // Delete button

     // console.log(`[DEBUG] UserPlaylists: Buttons found - playBtn: ${!!playBtn}, editBtn: ${!!editBtn}, deleteBtn: ${!!deleteBtn}`);

     if (playBtn) { // If play button is ever added back
         event.stopPropagation();
         // console.log("[DEBUG] UserPlaylists: Play button path. Calling playPlaylist...");
         // playPlaylist(playlistId); // Need a playPlaylist function
     } else if (editBtn) { // View/Edit icon click
         event.stopPropagation();
         // console.log("[DEBUG] UserPlaylists: Edit/View button path. Calling viewPlaylist...");
         viewPlaylist(playlistId);
     } else if (deleteBtn) { // Delete icon click
         event.stopPropagation();
         // console.log("[DEBUG] UserPlaylists: Delete button path. Calling deletePlaylist...");
         deletePlaylist(playlistId);
     } else { // Click on the item itself (not buttons)
         // console.log("[DEBUG] UserPlaylists: Item itself clicked. Calling viewPlaylist...");
         viewPlaylist(playlistId); // Default action is view
     }
    }

      function handlePlaylistDetailClick(event) {
          const target = event.target;
          const playlistItem = target.closest('.playlist-item');
          if (!playlistItem) return;

          const songId = playlistItem.dataset.id;
          const favoriteBtn = target.closest('.favorite-btn');
          const checkbox = target.closest('.song-select');

          if (favoriteBtn) {
              event.stopPropagation();
              toggleFavorite(songId);
          } else if (checkbox) {
              event.stopPropagation(); // Allow checkbox default behavior, don't play song
          } else { // Clicked on the item to play
              const originalIndex = findSongIndexById(songId);
              if (originalIndex !== -1) {
                  playSong(originalIndex);
                  hideModal('playlistDetail');
              } else {
                  showSnackbar("曲が見つかりませんでした。");
              }
          }
      }


    // Helper to toggle playlist dropdown visibility
    function togglePlaylistDropdown(buttonElement) {
        if(!buttonElement) return;
        const dropdownContainer = buttonElement.closest('.dropdown'); // Find parent dropdown container
        if (!dropdownContainer) return;
        const dropdownMenu = dropdownContainer.querySelector('.dropdown-menu');
        if (!dropdownMenu) return;

        const isHidden = dropdownMenu.classList.contains('hidden');
        closeAllPlaylistDropdowns(); // Close others first
        if (isHidden) {
            dropdownMenu.classList.remove('hidden');
             // Focus the first item in the dropdown for accessibility
             const firstLink = dropdownMenu.querySelector('a');
             firstLink?.focus();
        }
        // If it was open, closeAllPlaylistDropdowns already handled it
    }

    // Helper to close all open playlist dropdowns
    function closeAllPlaylistDropdowns(exceptButton = null) {
        document.querySelectorAll('.dropdown-menu').forEach(d => {
             // Don't close the one belonging to the button just clicked (if applicable)
             const parentDropdown = d.closest('.dropdown');
             const triggerButton = parentDropdown?.querySelector('.add-to-playlist-btn');
             if (triggerButton !== exceptButton) {
                 d.classList.add('hidden');
             }
        });
    }

    // Global click listener to close dropdowns
    document.addEventListener('click', (e) => {
        // Close dropdown if click is outside any element with class 'dropdown'
        if (!e.target.closest('.dropdown')) {
            closeAllPlaylistDropdowns();
        }
    }, true); // Use capture phase


    // ==========================================================================
    // Render UI Functions
    // ==========================================================================
    function renderPlaylist() {
      const items = appState.filteredSongs;
      const container = elements.playlist;
      if (!container) return;

      if (!items || items.length === 0) {
          let message = "曲が見つかりません";
          if(elements.searchInput?.value) message = "検索結果はありません";
          else message = "楽曲リストは空です";
          showEmptyMessage(container, message);
          return;
      }
      // Render using the generic function
        renderList(
            container,
            items,
            'playlist-item',
            (song) => `data-id="${song.id}"`, // Identify by song ID
            true // Show actions (fav, add to playlist)
        );
        updateActiveListItem(); // Highlight after rendering
    }


    function renderHistoryList() {
        if (!elements.historyList) return;
        const itemsToRender = [...appState.history].reverse(); // Newest first
        renderList(
            elements.historyList,
            itemsToRender,
            'history-item',
            (song) => `data-id="${song.id}"`,
            true // Show actions (fav, add to playlist)
        );
        updateActiveListItem(); // Highlight if current song is in history
    }

    function renderFavoritesList() {
        if (!elements.favoritesList) return;
        renderList(
            elements.favoritesList,
            appState.favorites,
            'favorite-item',
            (song) => `data-id="${song.id}"`,
            true // Show actions (un-fav, add to playlist)
        );
        updateActiveListItem(); // Highlight if current song is a favorite
    }

    // Generic list rendering function (Refined)
    function renderList(container, items, itemClass, dataAttributeFn, showActions) {
        if (!container) return;

        const fragment = document.createDocumentFragment();
        const currentSongId = appState.currentSongIndex !== -1 && appState.songs[appState.currentSongIndex]
                              ? appState.songs[appState.currentSongIndex].id
                              : null;

        if (!items || items.length === 0) {
            let message = "アイテムが見つかりません";
            if (container === elements.historyList) message = "再生履歴はありません";
            else if (container === elements.favoritesList) message = "お気に入りに登録された曲はありません";
            else if (container === elements.playlist && elements.searchInput?.value) message = "検索結果はありません";
            else if (container === elements.playlist) message = "楽曲リストは空です"; // Default for main list if empty
            showEmptyMessage(container, message);
            return;
        }

        items.forEach((song, index) => {
            if (!song || !song.id) {
                console.warn("Invalid song data in list:", song);
                return; // Skip invalid entries
            }
            const isActive = song.id === currentSongId;
            const isFavorite = appState.favorites.some(fav => fav && fav.id === song.id);
            const canAddToPlaylist = appState.loggedInUser && appState.userPlaylists.length > 0;

            const div = document.createElement('div');
            div.className = `${itemClass} p-3 flex items-center justify-between cursor-pointer ${isActive ? 'active' : ''} focusable`; // Added focusable
            div.tabIndex = 0; // Make item focusable

            const attr = dataAttributeFn(song, index);
            if (typeof attr === 'string' && attr.includes('=')) {
                const [key, value] = attr.split('=');
                div.dataset[key.replace('data-', '')] = value.replace(/"/g, ''); // Set dataset property
            } else {
                console.warn("Invalid data attribute format from dataAttributeFn");
            }

             // Keyboard activation for list items
             div.addEventListener('keydown', (e) => {
                 if (e.key === 'Enter' || e.key === ' ') {
                     e.preventDefault();
                     const songId = div.dataset.id;
                     const originalIndex = findSongIndexById(songId);
                     if (originalIndex !== -1) playSong(originalIndex);
                 }
             });

            let playlistActionsHTML = '';
            if (showActions) {
                playlistActionsHTML = `
                    <button class="favorite-btn text-lg mr-2 focusable" data-id="${song.id}" aria-label="${isFavorite ? 'お気に入り解除' : 'お気に入り登録'}">
                        <i class="fas fa-heart ${isFavorite ? 'text-red-500' : 'text-gray-400'}"></i>
                    </button>
                    ${appState.loggedInUser ? `
                    <div class="dropdown relative inline-block">
                        <button class="add-to-playlist-btn text-lg mr-2 focusable ${canAddToPlaylist ? '' : 'opacity-50 cursor-not-allowed'}" data-id="${song.id}" ${canAddToPlaylist ? '' : 'disabled aria-disabled="true"'} aria-label="プレイリストに追加">
                            <i class="fas fa-plus"></i>
                        </button>
                        ${canAddToPlaylist ? `
                        <div class="dropdown-menu absolute right-0 mt-2 w-48 rounded-md shadow-lg hidden z-20" style="background-color: var(--card-color); border: 1px solid var(--border-color);">
                            <div class="py-1 max-h-32 overflow-y-auto">
                                ${appState.userPlaylists.map(playlist => `
                                    <a href="#" class="block px-4 py-2 text-sm hover:bg-gray-100 dark:hover:bg-gray-700 select-playlist focusable" data-id="${song.id}" data-playlistid="${playlist.id}">
                                        ${escapeHTML(playlist.name)} <span class="playlist-count">${playlist.songs?.length ?? 0}</span>
                                    </a>
                                `).join('')}
                            </div>
                        </div>
                        ` : ''}
                    </div>
                    ` : ''}
                `;
            }

            div.innerHTML = `
                <div class="flex items-center overflow-hidden mr-2 flex-grow min-w-0">
                    <div class="w-10 h-10 rounded overflow-hidden mr-3 flex-shrink-0">
                        <img src="${song.thumbnail || ''}" alt="${escapeHTML(song.title)}" class="w-full h-full object-cover" loading="lazy">
                    </div>
                    <div class="flex-grow overflow-hidden min-w-0">
                        <h3 class="text-sm font-medium truncate">${escapeHTML(song.title)}</h3>
                    </div>
                </div>
                ${showActions ? `<div class="flex items-center flex-shrink-0 ml-2">${playlistActionsHTML}</div>` : ''}
            `;
            fragment.appendChild(div);
        });

        container.innerHTML = ''; // Clear previous content
        container.appendChild(fragment);
    }

    function renderUserPlaylists() {
      const container = elements.userPlaylistsList;
      if (!container) return;

      const fragment = document.createDocumentFragment();

      if (appState.userPlaylists.length === 0) {
        showEmptyMessage(container, "マイプレイリストはありません");
        return;
      }

      appState.userPlaylists.forEach(playlist => {
        const div = document.createElement('div');
        div.className = 'user-playlist-item p-3 flex items-center justify-between cursor-pointer focusable'; // Added focusable
        div.dataset.id = playlist.id;
        div.tabIndex = 0; // Make item focusable

         div.addEventListener('keydown', (e) => { // Keyboard activation
             if (e.key === 'Enter' || e.key === ' ') {
                 e.preventDefault();
                 viewPlaylist(playlist.id); // Default action is view
             }
         });

        div.innerHTML = `
          <span class="font-medium truncate mr-2 flex-grow">${escapeHTML(playlist.name)} <span class="playlist-count">${playlist.songs?.length ?? 0}</span></span>
          <div class="user-playlist-actions flex-shrink-0 flex items-center gap-2">
             <!-- Play button (Optional) -->
             <!-- <button class="playlist-play-btn text-lg focusable" data-id="${playlist.id}" aria-label="${escapeHTML(playlist.name)} を再生"><i class="fas fa-play"></i></button> -->
             <!-- Edit/View Button -->
             <button class="playlist-edit-btn text-lg focusable" data-id="${playlist.id}" aria-label="${escapeHTML(playlist.name)} を表示/編集"><i class="fas fa-eye"></i></button>
             <!-- Delete Button -->
             <button class="playlist-delete-btn text-sm text-red-500 hover:text-red-700 dark:hover:text-red-400 focusable" data-id="${playlist.id}" aria-label="${escapeHTML(playlist.name)} を削除">
                 <i class="fas fa-trash"></i>
             </button>
          </div>
        `;
        fragment.appendChild(div);
      });

      container.innerHTML = '';
      container.appendChild(fragment);
    }


    function renderPlaylistDetail(playlist) {
        // console.log(`[DEBUG] renderPlaylistDetail started for playlist ID: ${playlist?.id}`); // Debug log

        // Guard clause: Check if main song list is loaded
        if (!appState.songs || appState.songs.length === 0) {
            showSnackbar("楽曲リストの読み込みが完了していません。");
            console.warn("[DEBUG] renderPlaylistDetail called before appState.songs was populated.");
            const container = elements.playlistElements.detailContent;
            if (container) showEmptyMessage(container, "楽曲リストを読み込み中です...");
            return;
        }

        const container = elements.playlistElements.detailContent;
        const titleEl = elements.playlistElements.detailTitle;
        const removeBtn = elements.modalButtons.removeFromPlaylist;

        if (!container || !titleEl || !removeBtn) {
            console.error("[DEBUG] Playlist detail modal elements not found.");
            if(titleEl) titleEl.textContent = "表示エラー";
            if(container) container.innerHTML = `<p class="text-red-500 text-center py-4">詳細表示に必要な要素が見つかりません。</p>`;
            return;
        }

        if (!playlist || !playlist.id) {
            console.error("[DEBUG] Invalid playlist object passed to renderPlaylistDetail:", playlist);
            titleEl.textContent = "プレイリストエラー";
            container.innerHTML = `<p class="text-red-500 text-center py-4">プレイリストの情報の取得に失敗しました。</p>`;
            removeBtn.classList.add('hidden');
            return;
        }

        titleEl.textContent = escapeHTML(playlist.name);

        // Get the currently playing song's ID safely
        const currentlyPlayingSongId = currentSongId();
        // console.log("[DEBUG] renderPlaylistDetail: Currently playing song ID:", currentlyPlayingSongId);

        const songsInPlaylist = (playlist.songs || [])
                                .map(songId => findSongById(songId)) // Use helper to find song object
                                .filter(song => song); // Filter out null/undefined if song not found

        // console.log(`[DEBUG] renderPlaylistDetail: Found ${songsInPlaylist.length} songs for playlist ${playlist.id}`);

        const fragment = document.createDocumentFragment();

        if (songsInPlaylist.length === 0) {
            showEmptyMessage(container, "このプレイリストには曲が追加されていません");
            removeBtn.classList.add('hidden');
            return;
        }

        songsInPlaylist.forEach(song => {
            const isFavorite = appState.favorites.some(fav => fav && fav.id === song.id);
            const isActive = song.id === currentlyPlayingSongId;
            const div = document.createElement('div');
            div.className = `playlist-item p-3 flex items-center justify-between cursor-pointer ${isActive ? 'active' : ''} focusable`;
            div.dataset.id = song.id;
            div.tabIndex = 0;

            div.addEventListener('keydown', (e) => {
                 if (e.key === 'Enter' || e.key === ' ') {
                    if (!e.target.classList.contains('song-select')) {
                        e.preventDefault();
                        const songId = div.dataset.id;
                        const originalIndex = findSongIndexById(songId);
                        if (originalIndex !== -1) {
                             playSong(originalIndex);
                             hideModal('playlistDetail');
                        } else {
                             showSnackbar("曲が見つかりませんでした。");
                        }
                    }
                 }
             });

            div.innerHTML = `
                <div class="flex items-center overflow-hidden mr-2 flex-grow min-w-0">
                    <input type="checkbox" class="song-select mr-3 flex-shrink-0 focusable" data-id="${song.id}" aria-label="${escapeHTML(song.title)}を選択">
                    <div class="w-10 h-10 rounded overflow-hidden mr-3 flex-shrink-0">
                        <img src="${song.thumbnail || ''}" alt="${escapeHTML(song.title)}" class="w-full h-full object-cover" loading="lazy">
                    </div>
                    <div class="flex-grow overflow-hidden min-w-0">
                        <h3 class="text-sm font-medium truncate">${escapeHTML(song.title)}</h3>
                    </div>
                </div>
                <div class="flex items-center flex-shrink-0 ml-2">
                    <button class="favorite-btn text-lg mr-2 focusable" data-id="${song.id}" aria-label="${isFavorite ? 'お気に入り解除' : 'お気に入り登録'}">
                        <i class="fas fa-heart ${isFavorite ? 'text-red-500' : 'text-gray-400'}"></i>
                    </button>
                </div>
            `;
            fragment.appendChild(div);
        });

        container.innerHTML = '';
        container.appendChild(fragment);
        removeBtn.classList.remove('hidden');

        // console.log("[DEBUG] renderPlaylistDetail finished rendering.");
    }


    // ==========================================================================
    // Player Control Functions
    // ==========================================================================
    function playSong(originalIndex) {
      // Add a check for elements existence, though should be fine if called after onPlayerReady
      if (!elements.currentSongTitle || !elements.currentSongDuration) {
          console.error("Cannot play song: Title or Duration element not found.");
          return;
      }
      if (!appState.isPlayerReady) {
        showSnackbar("プレイヤーの準備ができていません。");
        return;
      }
      if (originalIndex >= 0 && originalIndex < appState.songs.length) {
        const targetSong = appState.songs[originalIndex];
        if (!targetSong || !targetSong.id) {
          console.error("Invalid song data at index:", originalIndex, targetSong);
          showSnackbar("曲データの読み込みに失敗しました。");
          return;
        }

        appState.currentSongIndex = originalIndex; // Update index only if song is valid
        const cleanVideoId = targetSong.id.trim();

        elements.currentSongTitle.textContent = targetSong.title;
        elements.currentSongDuration.textContent = targetSong.duration || '--:--';

        try {
          if (appState.player && typeof appState.player.loadVideoById === 'function') {
            console.log(`Loading video: ${cleanVideoId} (${targetSong.title})`);
            appState.player.loadVideoById(cleanVideoId);
            // Autoplay is handled by onStateChange event (YT.PlayerState.PLAYING)
            // Calling playVideo immediately after load might be redundant or cause issues
            // Let's rely on the state change event triggering play logic
          } else {
            throw new Error("Player or loadVideoById not available.");
          }
        } catch (error) {
          console.error("Error loading video:", error);
          showSnackbar("動画の読み込みに失敗しました。");
          resetPlayerInfo();
          return;
        }

        updateActiveListItem();
        // === Call Update for Now Playing Bar ===
        updateNowPlayingBar();
        // =====================================

        // Disable buttons initially, they will be enabled when playing starts (via onPlayerStateChange)
        if(elements.shareBtn) elements.shareBtn.disabled = true;
        if(elements.openYouTubeBtn) elements.openYouTubeBtn.disabled = true;
      } else {
        console.warn("Invalid song index requested:", originalIndex);
      }
    }

    function togglePlayPause() {
        if (!appState.isPlayerReady || !appState.player) {
            showSnackbar("プレイヤーが利用できません。");
            return;
        }
        const currentId = currentSongId();
        if (!currentId) {
            if(appState.songs.length > 0) playSong(0); // Play first song if none selected
            else showSnackbar("再生する曲がありません。");
            return;
        }

        try {
            const playerState = appState.player.getPlayerState();
            if (playerState === YT.PlayerState.PLAYING) {
                appState.player.pauseVideo();
            } else {
                appState.player.playVideo();
            }
        } catch (error) {
            console.error("Error toggling play/pause:", error);
            showSnackbar("再生/一時停止中にエラーが発生しました。");
        }
    }

    function playNextSong() {
        if (appState.songs.length === 0) return;
        let nextIndex;
        const currentIndex = appState.currentSongIndex;

        if (currentIndex === -1) {
            nextIndex = 0; // Play first if nothing was playing
        } else if (appState.isShuffle) {
            if (appState.songs.length <= 1) {
                nextIndex = 0;
            } else {
                 do {
                     nextIndex = Math.floor(Math.random() * appState.songs.length);
                 } while (nextIndex === currentIndex);
            }
        } else {
            nextIndex = (currentIndex + 1) % appState.songs.length;
        }
        playSong(nextIndex);
    }

    function playPreviousSong() {
        if (appState.songs.length === 0) return;
        let prevIndex;
        const currentIndex = appState.currentSongIndex;

        if (currentIndex === -1) {
            prevIndex = 0; // Play first if nothing was playing
            playSong(prevIndex);
            return;
        }

        try {
            // Restart if played for more than 3 seconds
            if (appState.player && typeof appState.player.getCurrentTime === 'function' && appState.player.getCurrentTime() > 3) {
                appState.player.seekTo(0);
                return;
            }
        } catch (error) {
            console.warn("Could not get current time for previous song logic:", error);
        }

        if (appState.isShuffle) {
             if (appState.songs.length <= 1) {
                 prevIndex = 0;
             } else {
                  do {
                      prevIndex = Math.floor(Math.random() * appState.songs.length);
                  } while (prevIndex === currentIndex);
             }
        } else {
             prevIndex = currentIndex - 1;
             if (prevIndex < 0) {
                 prevIndex = appState.songs.length - 1; // Loop to end
             }
        }
        playSong(prevIndex);
    }

    function handleSongEnd() {
        console.log("Song ended. Loop mode:", appState.loopMode);
        switch (appState.loopMode) {
            case 'one':
                if(appState.player && typeof appState.player.seekTo === 'function' && typeof appState.player.playVideo === 'function') {
                    try {
                        appState.player.seekTo(0);
                        appState.player.playVideo();
                        console.log("Looping one song.");
                    } catch(e){
                        console.error("Error restarting song for loop one:", e);
                        playNextSong(); // Fallback to next song on error
                    }
                } else {
                    playNextSong(); // Fallback if player methods aren't available
                }
                break;
            case 'all':
                console.log("Looping all, playing next.");
                playNextSong();
                break;
            case 'none':
            default:
                // Play next unless it's the absolute last song in non-shuffle mode
                if (!appState.isShuffle && appState.currentSongIndex === appState.songs.length - 1) {
                     console.log("Reached end of playlist, stopping.");
                     // UI should reset via the ENDED state in onPlayerStateChange
                     // No need to explicitly call pause/seek here, let state change handle it.
                     // Update the bar to show stopped state though
                     appState.isPlaying = false; // Explicitly set state for UI update
                     updateNowPlayingBar();
                     updateProgress(); // Ensure main progress is 0
                } else {
                    console.log("Playing next song after end.");
                    playNextSong();
                }
                break;
        }
    }

    function toggleShuffle() {
      appState.isShuffle = !appState.isShuffle;
      const isActive = appState.isShuffle;
      // Update Desktop Button
      elements.btnShuffle?.classList.toggle('btn-active', isActive);
      elements.btnShuffle?.classList.toggle('btn-inactive', !isActive);
      elements.btnShuffle?.setAttribute('aria-pressed', isActive);
       // Update Mobile Button
       elements.btnShuffleMobile?.classList.toggle('btn-active', isActive);
       elements.btnShuffleMobile?.classList.toggle('btn-inactive', !isActive);
       elements.btnShuffleMobile?.setAttribute('aria-pressed', isActive);

      showSnackbar(`シャッフル: ${isActive ? 'オン' : 'オフ'}`);
    }

    function toggleLoopMode() {
      let loopIconHTML = '';
      let loopLabel = '';
      let isActive = true;

      switch (appState.loopMode) {
        case 'none':
          appState.loopMode = 'all';
          loopIconHTML = '<i class="fas fa-repeat"></i>';
          loopLabel = 'リピート: 全曲';
          break;
        case 'all':
          appState.loopMode = 'one';
          // Use a more distinct icon for loop one if possible, or combine
          // Example: using '1' inside repeat (requires FontAwesome Pro or custom icon)
          // For standard FA:
          loopIconHTML = '<i class="fas fa-repeat-1" style="position: relative;"><span class="text-xs absolute -top-1 -right-1 bg-white text-black rounded-full px-1" style="font-family: sans-serif; line-height: 1;">1</span></i>';
          // Fallback simple styling:
          // loopIconHTML = '<i class="fas fa-1" style="font-size: 0.8em; position: relative; top: -0.1em; margin-left: -0.2em;"></i><i class="fas fa-repeat"></i>';
          loopLabel = 'リピート: 1曲';
          break;
        case 'one':
        default: // Fallback to 'none'
          appState.loopMode = 'none';
          loopIconHTML = '<i class="fas fa-repeat"></i>';
          loopLabel = 'リピート: オフ';
          isActive = false;
          break;
      }

        // Update Desktop Button
        if (elements.btnLoop) {
            elements.btnLoop.innerHTML = loopIconHTML;
            elements.btnLoop.classList.toggle('btn-active', isActive);
            elements.btnLoop.classList.toggle('btn-inactive', !isActive);
            elements.btnLoop.setAttribute('aria-label', loopLabel);
        }
        // Update Mobile Button
        if (elements.btnLoopMobile) {
            elements.btnLoopMobile.innerHTML = loopIconHTML;
            elements.btnLoopMobile.classList.toggle('btn-active', isActive);
            elements.btnLoopMobile.classList.toggle('btn-inactive', !isActive);
            elements.btnLoopMobile.setAttribute('aria-label', loopLabel);
        }

      showSnackbar(loopLabel);
    }

    function handleVolumeChange() {
        if(!elements.volumeSlider) return;
        const volume = parseInt(elements.volumeSlider.value);
        setVolume(volume);
    }

     function setVolume(volume) {
         volume = Math.max(0, Math.min(100, volume)); // Clamp
         appState.volume = volume;
         // Update main volume slider
         if(elements.volumeSlider) elements.volumeSlider.value = volume;
         // Update bar volume slider
         if(elements.volumeSliderBar) elements.volumeSliderBar.value = volume;
         // Update player volume
         if (appState.isPlayerReady && appState.player && typeof appState.player.setVolume === 'function') {
              try { appState.player.setVolume(volume); } catch (e) { console.error("Error setting volume:", e); }
         }
          // Update volume icons (both if they exist)
          // Assuming main volume icon has ID 'desktop-volume-icon' or similar if needed
          // updateVolumeIcon(document.getElementById('desktop-volume-icon'), volume);
          updateVolumeIcon(elements.volumeIconBar, volume);
     }

    function adjustVolume(delta) {
        setVolume(appState.volume + delta);
    }

    function seekToPosition(event) {
        if (!appState.isPlayerReady || !currentSongId() || !elements.progressContainer || !appState.player) return;

        // Use pageX for broader compatibility, adjust for container offset
        const rect = elements.progressContainer.getBoundingClientRect();
        const clickX = event.pageX - rect.left - window.scrollX; // Calculate click relative to container start

        // Ensure click is within bounds (0 to rect.width)
        const clampedX = Math.max(0, Math.min(clickX, rect.width));

        if (rect.width <= 0) return; // Avoid division by zero

        const percent = clampedX / rect.width;

        try {
            const duration = appState.player.getDuration();
            if (duration > 0) {
                const seekTime = duration * percent;
                appState.player.seekTo(seekTime, true);
                updateProgress(); // Update UI immediately
            }
        } catch (error) {
            console.error("Error seeking:", error);
            showSnackbar("シーク中にエラーが発生しました。");
        }
    }

     function seekRelative(deltaSeconds) {
         if (!appState.isPlayerReady || !currentSongId() || !appState.player) return;
         try {
             const currentTime = appState.player.getCurrentTime();
             const duration = appState.player.getDuration();
             if (duration > 0) {
                 let seekTime = currentTime + deltaSeconds;
                 seekTime = Math.max(0, Math.min(seekTime, duration)); // Clamp
                 appState.player.seekTo(seekTime, true);
                 updateProgress();
             }
         } catch (error) {
             console.error("Error seeking relative:", error);
         }
     }

    function startProgressUpdate() {
      stopProgressUpdate(); // Clear existing interval
      if (!appState.progressInterval) { // Ensure only one interval runs
           // Use a slightly faster interval for smoother progress bar updates
           appState.progressInterval = setInterval(updateProgress, 250);
      }
      updateProgress(); // Initial update
    }

    function stopProgressUpdate() {
      if (appState.progressInterval) {
        clearInterval(appState.progressInterval);
        appState.progressInterval = null;
      }
    }

    function updateProgress() {
        const progressBar = elements.progressBar;
        const currentTimeEl = elements.currentTime;
        const totalTimeEl = elements.totalTime;

        if (!progressBar || !currentTimeEl || !totalTimeEl) return; // Check elements exist

        const song = currentSongData(); // Get current song data if available

        if (!appState.isPlayerReady || !appState.player || typeof appState.player.getCurrentTime !== 'function' || !song) {
            // Reset progress if player not ready or no song selected
            if (progressBar.style.width !== '0%') progressBar.style.width = '0%';
            currentTimeEl.textContent = '00:00';
            // Use song duration from appState if available, otherwise '00:00'
            totalTimeEl.textContent = song?.duration && song.duration !== '--:--' ? song.duration : '00:00';
             if(elements.currentSongDuration) {
                 elements.currentSongDuration.textContent = song?.duration || '--:--';
             }
             updateNowPlayingBar(); // Ensure bar is also reset/updated
            return;
        }

        try {
            const currentTime = appState.player.getCurrentTime();
            const duration = appState.player.getDuration();

            if (typeof currentTime === 'number' && typeof duration === 'number' && duration > 0) {
                const percent = Math.min(100, Math.max(0, (currentTime / duration) * 100));
                if (!isNaN(percent)) {
                    progressBar.style.width = `${percent}%`;
                } else {
                    if (progressBar.style.width !== '0%') progressBar.style.width = '0%';
                }
                currentTimeEl.textContent = formatTime(currentTime);
                const formattedDuration = formatTime(duration);
                 // Update total time only if it differs or if the known song duration was '--:--'
                if (totalTimeEl.textContent !== formattedDuration || (song && song.duration === '--:--')) {
                     totalTimeEl.textContent = formattedDuration;
                     // Also update the duration displayed under the title
                     if(elements.currentSongDuration) elements.currentSongDuration.textContent = formattedDuration;
                     // Update the duration in the appState.songs array if it was initially unknown
                     if (song && song.duration === '--:--') {
                         song.duration = formattedDuration;
                         // Optional: Re-render the list containing this song to show the updated duration?
                         // This could be expensive, maybe update only the specific item if needed later.
                     }
                }
            } else {
                // Handle cases where times might be 0 or invalid initially (e.g., before playback starts)
                 if (progressBar.style.width !== '0%') progressBar.style.width = '0%';
                 currentTimeEl.textContent = '00:00';
                 // Use known song duration if available
                 const knownDuration = song?.duration && song.duration !== '--:--' ? song.duration : '00:00';
                 if(totalTimeEl.textContent !== knownDuration) totalTimeEl.textContent = knownDuration;
                 if(elements.currentSongDuration && elements.currentSongDuration.textContent !== (song?.duration || '--:--')) {
                      elements.currentSongDuration.textContent = song?.duration || '--:--';
                 }
            }
            // Also update the Now Playing Bar's progress and potentially play/pause state
            updateNowPlayingBar();

        } catch (error) {
            // Don't log frequent errors during normal operation (like getting time before ready)
            // console.error("Error updating progress:", error);
             if (progressBar.style.width !== '0%') progressBar.style.width = '0%';
             currentTimeEl.textContent = '00:00';
             totalTimeEl.textContent = '00:00';
             if(elements.currentSongDuration) elements.currentSongDuration.textContent = '--:--';
             stopProgressUpdate(); // Stop interval if error occurs
             updateNowPlayingBar(); // Update bar even on error
        }
    }

     function resetPlayerInfo() {
         if(elements.currentSongTitle) elements.currentSongTitle.textContent = "選択された曲はありません";
         if(elements.currentSongDuration) elements.currentSongDuration.textContent = "--:--";
         if(elements.progressBar) elements.progressBar.style.width = '0%';
         if(elements.currentTime) elements.currentTime.textContent = "00:00";
         if(elements.totalTime) elements.totalTime.textContent = "00:00";
         if(elements.shareBtn) elements.shareBtn.disabled = true;
         if(elements.openYouTubeBtn) elements.openYouTubeBtn.disabled = true;
         if(elements.nowPlayingBadge) elements.nowPlayingBadge.classList.add('hidden');
         updateActiveListItem(); // Clear highlights
         updateNowPlayingBar(); // Update bar to reset state
     }

    // ==========================================================================
    // Now Playing Bar Update Function
    // ==========================================================================
    function updateNowPlayingBar() {
        const song = currentSongData();
        const isVisible = !!song; // Show bar if a song is selected/playing

        if (appState.isBarVisible !== isVisible) {
             appState.isBarVisible = isVisible;
             elements.nowPlayingBar?.classList.toggle('active', isVisible);
             elements.body?.classList.toggle('has-now-playing-bar', isVisible);
        }

        if (isVisible && song && elements.nowPlayingBar) {
            // Update Bar Content
            if (elements.nowPlayingBarThumb) {
                 elements.nowPlayingBarThumb.src = song.thumbnail || '';
                 elements.nowPlayingBarThumb.alt = song.title || 'Album Art';
            }
            if(elements.nowPlayingBarTitle) elements.nowPlayingBarTitle.textContent = song.title || '不明なタイトル';
            // Artist is fixed in this example, update if dynamic
            if(elements.nowPlayingBarArtist) elements.nowPlayingBarArtist.textContent = 'Rei Kikuchi'; // Assuming fixed artist

             // Update Play/Pause Button Icon in Bar
             const playIconBar = elements.btnPlayBar?.querySelector('i');
             if (playIconBar) {
                 playIconBar.className = `fas ${appState.isPlaying ? 'fa-pause' : 'fa-play'} text-xl`;
             }
              if(elements.btnPlayBar) elements.btnPlayBar.setAttribute('aria-label', appState.isPlaying ? '一時停止' : '再生');

            // Update Progress Bar (in bar)
            if(elements.nowPlayingBarProgress && appState.player) {
                try {
                    const currentTime = appState.player.getCurrentTime();
                    const duration = appState.player.getDuration();
                    if (typeof currentTime === 'number' && typeof duration === 'number' && duration > 0) {
                         const percent = Math.min(100, Math.max(0, (currentTime / duration) * 100));
                         elements.nowPlayingBarProgress.style.width = `${percent}%`;
                    } else {
                         elements.nowPlayingBarProgress.style.width = '0%';
                    }
                } catch(e) { elements.nowPlayingBarProgress.style.width = '0%'; }
            }

            // Update Volume Slider (in bar) & Icon
             if(elements.volumeSliderBar) elements.volumeSliderBar.value = appState.volume;
             updateVolumeIcon(elements.volumeIconBar, appState.volume);

        } else if (!isVisible && elements.nowPlayingBar) {
             // Optionally clear fields when hidden
             if(elements.nowPlayingBarTitle) elements.nowPlayingBarTitle.textContent = '曲が選択されていません';
             if(elements.nowPlayingBarThumb) elements.nowPlayingBarThumb.src = '';
             if(elements.nowPlayingBarProgress) elements.nowPlayingBarProgress.style.width = '0%';
             // Reset play button in bar
             const playIconBar = elements.btnPlayBar?.querySelector('i');
             if (playIconBar) playIconBar.className = 'fas fa-play text-xl';
             if(elements.btnPlayBar) elements.btnPlayBar.setAttribute('aria-label', '再生');
        }
    }


    // ==========================================================================
    // Playlist Functions
    // ==========================================================================
    function showCreatePlaylistModal() {
      if (!appState.loggedInUser) {
        showAccountModal(); // Prompt login first
        showSnackbar('プレイリスト作成にはログインが必要です');
        return;
      }
      if(elements.playlistElements.nameInput) elements.playlistElements.nameInput.value = '';
      // Show modal and focus on input
      showModal('createPlaylist', elements.playlistElements.nameInput);
    }

    function saveNewPlaylist() {
      if(!elements.playlistElements.nameInput) return;
      const name = elements.playlistElements.nameInput.value.trim();
      if (!name) {
        showSnackbar('プレイリスト名を入力してください');
        elements.playlistElements.nameInput.focus();
        return;
      }
      const newPlaylist = {
        id: `pl_${Date.now()}_${Math.random().toString(36).substring(2, 8)}`,
        name: name,
        songs: [],
        created: new Date().toISOString()
      };
      appState.userPlaylists.push(newPlaylist);
      saveUserPlaylists();
      renderUserPlaylists(); // Update the "My Playlists" tab
      // Re-render other lists to update "Add to Playlist" dropdowns/buttons
      renderPlaylist();
      renderHistoryList();
      renderFavoritesList();
      hideModal('createPlaylist');
      showSnackbar(`プレイリスト「${escapeHTML(name)}」を作成しました`);
    }

    function deletePlaylist(playlistId) {
        const playlistIndex = appState.userPlaylists.findIndex(p => p && p.id === playlistId);
        if (playlistIndex === -1) return;

        const playlist = appState.userPlaylists[playlistIndex];
        if (confirm(`プレイリスト「${escapeHTML(playlist.name)}」を削除してもよろしいですか？`)) {
            appState.userPlaylists.splice(playlistIndex, 1);
            saveUserPlaylists();
            renderUserPlaylists();
            // Re-render other lists to update dropdowns
            renderPlaylist();
            renderHistoryList();
            renderFavoritesList();

            // If the deleted playlist detail was open, close it
            if (appState.currentSelectedPlaylistId === playlistId) {
                hideModal('playlistDetail');
                appState.currentSelectedPlaylistId = null;
            }
            showSnackbar(`プレイリスト「${escapeHTML(playlist.name)}」を削除しました`);
        }
    }

    function addSongToPlaylist(songId, playlistId) {
      const playlist = appState.userPlaylists.find(p => p && p.id === playlistId);
      const song = findSongById(songId); // Use helper

      if (!playlist || !song) {
           console.error("Playlist or Song not found for adding:", playlistId, songId);
           showSnackbar("プレイリストまたは曲が見つかりません。");
           return;
      }
      if (!playlist.songs) playlist.songs = []; // Ensure songs array exists

      if (!playlist.songs.includes(songId)) {
        playlist.songs.push(songId);
        saveUserPlaylists();
        renderUserPlaylists(); // Update counts in the main "My Playlists" list
        // If the detail view for this playlist is currently open, refresh it
        if (appState.currentSelectedPlaylistId === playlistId && elements.modals.playlistDetail?.classList.contains('show')) {
             renderPlaylistDetail(playlist);
        }
         // Update dropdowns/buttons in other lists by re-rendering them
         renderPlaylist();
         renderHistoryList();
         renderFavoritesList();
         showSnackbar(`「${escapeHTML(song.title)}」を「${escapeHTML(playlist.name)}」に追加しました`);
      } else {
        showSnackbar(`「${escapeHTML(song.title)}」は既に「${escapeHTML(playlist.name)}」に存在します`);
      }
       closeAllPlaylistDropdowns(); // Close dropdown after action
    }

    function viewPlaylist(playlistId) {
      // console.log(`[DEBUG] viewPlaylist called for ID: ${playlistId}`); // Debug log
      if (!appState.songs || appState.songs.length === 0) {
          showSnackbar("楽曲リストの読み込みが完了していません。");
          console.warn("[DEBUG] viewPlaylist called before appState.songs was populated.");
          return;
      }

      const playlist = appState.userPlaylists.find(p => p && p.id === playlistId);
      if (!playlist) {
          showSnackbar("プレイリストが見つかりません。");
          console.error(`[DEBUG] viewPlaylist: Playlist not found for ID: ${playlistId}`);
          return;
      }
      // console.log("[DEBUG] viewPlaylist: Found playlist:", playlist);
      appState.currentSelectedPlaylistId = playlistId; // Store the ID of the viewed playlist
      renderPlaylistDetail(playlist); // Render the content
      showModal('playlistDetail'); // Show the modal
      // console.log("[DEBUG] viewPlaylist finished."); // Debug log
    }

    function removeSongFromPlaylist() {
      const playlistId = appState.currentSelectedPlaylistId;
      const playlist = appState.userPlaylists.find(p => p && p.id === playlistId);
      if (!playlist || !playlist.songs || !elements.playlistElements.detailContent) return;

      const selectedCheckboxes = elements.playlistElements.detailContent.querySelectorAll('.song-select:checked');
      const selectedSongIds = Array.from(selectedCheckboxes).map(el => el.dataset.id);

      if (selectedSongIds.length === 0) {
        showSnackbar('削除する曲を選択してください');
        return;
      }

      const initialLength = playlist.songs.length;
      playlist.songs = playlist.songs.filter(songId => !selectedSongIds.includes(songId));
      const removedCount = initialLength - playlist.songs.length;

      if (removedCount > 0) {
           saveUserPlaylists();
           renderUserPlaylists(); // Update counts in the main list
           renderPlaylistDetail(playlist); // Re-render the detail view
           showSnackbar(`${removedCount}曲をプレイリストから削除しました`);
      }
    }

    function sharePlaylist() {
        const playlistId = appState.currentSelectedPlaylistId;
        const playlist = appState.userPlaylists.find(p => p && p.id === playlistId);
        if (!playlist || !elements.playlistElements.shareLinkInput || !elements.playlistElements.shareObjectTitle) {
            showSnackbar("共有するプレイリストが見つかりません。");
            return;
        }

        const shareLink = `${window.location.origin}${window.location.pathname}?sharedPlaylistId=${playlistId}`;
        const shareTitle = `プレイリスト: ${escapeHTML(playlist.name)}`;

        elements.playlistElements.shareLinkInput.value = shareLink;
        elements.playlistElements.shareObjectTitle.textContent = shareTitle;
        hideModal('playlistDetail'); // Close detail modal first
        showModal('share'); // Show the generic share modal
    }

    // ==========================================================================
    // Share Functions
    // ==========================================================================
    function showShareModal() {
        const song = currentSongData(); // Use helper

        if (!song) {
            showSnackbar('共有する曲を再生してください');
            return;
        }

        const shareLink = `https://www.youtube.com/watch?v=${song.id}`;
        const shareTitle = `曲: ${escapeHTML(song.title)}`;

        if(!elements.playlistElements.shareLinkInput || !elements.playlistElements.shareObjectTitle || !elements.modals.share) {
             console.error("Share modal elements missing.");
             return;
        }

        elements.playlistElements.shareLinkInput.value = shareLink;
        elements.playlistElements.shareObjectTitle.textContent = shareTitle;

        // Setup social media share buttons
        const encodedLink = encodeURIComponent(shareLink);
        const encodedTitle = encodeURIComponent(`${shareTitle} - Rei Kikuchi Premium Player`); // Add context

        const twitterBtn = elements.modals.share.querySelector('button[style*="1DA1F2"]');
        if (twitterBtn) twitterBtn.onclick = () => window.open(`https://twitter.com/intent/tweet?text=${encodedTitle}&url=${encodedLink}`, '_blank');

        const facebookBtn = elements.modals.share.querySelector('button[style*="4267B2"]');
        if (facebookBtn) facebookBtn.onclick = () => window.open(`https://www.facebook.com/sharer/sharer.php?u=${encodedLink}`, '_blank');

        showModal('share', elements.modalButtons.copyLink); // Focus copy button initially
    }

    function copyShareLink() {
      const shareLinkInput = elements.playlistElements.shareLinkInput;
      if (!shareLinkInput || !shareLinkInput.value) {
          showSnackbar('コピーするリンクがありません。');
          return;
      }

      navigator.clipboard.writeText(shareLinkInput.value).then(() => {
          showSnackbar('リンクをクリップボードにコピーしました');
      }).catch(err => {
          console.warn('Clipboard API copy failed, trying fallback: ', err);
          try {
              shareLinkInput.select();
              shareLinkInput.setSelectionRange(0, 99999); // For mobile
              const successful = document.execCommand('copy');
              if (successful) showSnackbar('リンクをクリップボードにコピーしました');
              else showSnackbar('リンクのコピーに失敗しました');
          } catch (errFallback) {
              console.error('Fallback copy failed: ', errFallback);
              showSnackbar('リンクのコピーに失敗しました');
          }
          window.getSelection()?.removeAllRanges(); // Deselect
      });
    }

    // ==========================================================================
    // "Open on YouTube" Function
    // ==========================================================================
    function handleOpenYouTube() {
      const song = currentSongData(); // Use helper
      if (!song) {
          showSnackbar('再生中の曲がありません。');
          return;
      }
      const youtubeUrl = `https://www.youtube.com/watch?v=${song.id}`;
      window.open(youtubeUrl, '_blank');
    }

    // ==========================================================================
    // Account Functions
    // ==========================================================================
    function showAccountModal() {
      console.log("showAccountModal called. Current user:", appState.loggedInUser);
      const isLoggedIn = !!appState.loggedInUser;

      // 1. Update account button appearance immediately
      updateAccountUI(isLoggedIn);

      // 2. Determine which section to show and switch *before* showing modal
      if (isLoggedIn) {
        console.log("User is logged in. Switching to account info section.");
        switchAuthSection('accountInfo');
      } else {
        console.log("User is not logged in. Switching to login section.");
        switchAuthSection('login');
      }

      // 3. Show the modal container
      console.log("Showing account modal container.");
      showModal('account'); // Show the actual modal element
    }

    function switchAuthSection(section) {
      console.log("Attempting to switch auth section to:", section);
      if(!elements.accountSections) {
          console.error("elements.accountSections is not defined!");
          return;
      }
      // Hide all sections first
      Object.values(elements.accountSections).forEach(el => {
          if(el) el.classList.add('hidden');
      });

      // Show the target section
      const sectionToShow = elements.accountSections[section];
      if (sectionToShow) {
        sectionToShow.classList.remove('hidden');
        console.log(`Section '${section}' should now be visible.`);

        // Focus on the first focusable element in the newly shown section
        const firstFocusable = sectionToShow.querySelector('button, [href], input:not([type="hidden"]), select, textarea, [tabindex]:not([tabindex="-1"])');
        if (firstFocusable) {
           // Delay focus slightly to ensure element is fully visible after class change
           setTimeout(() => firstFocusable.focus(), 50);
        }
      } else {
        console.error("Invalid section requested in switchAuthSection:", section);
      }
    }

     function showLoadingState(button, isLoading) {
         if (!button) return;
         button.disabled = isLoading;
         if (isLoading) {
             button.innerHTML = '<i class="fas fa-spinner fa-spin"></i>'; // Show spinner
         } else {
             // Restore original button text (needs a way to store/retrieve it)
             // For simplicity, let's assume the text is static for now
             if (button.id === 'login-btn') button.textContent = 'ログイン';
             else if (button.id === 'register-btn') button.textContent = '登録';
             else if (button.id === 'sync-data-btn') button.innerHTML = '<i class="fas fa-sync mr-2"></i> データを同期';
             else if (button.id === 'logout-btn') button.innerHTML = '<i class="fas fa-sign-out-alt mr-2"></i> ログアウト';
             // Add more cases as needed
         }
     }

    function handleLogin() {
      const emailInput = elements.accountFields.loginEmail;
      const passwordInput = elements.accountFields.loginPassword;
      if(!emailInput || !passwordInput) return false;

      const email = emailInput.value.trim();
      const password = passwordInput.value;

      if (!email || !password) {
          showSnackbar("メールアドレスとパスワードを入力してください。");
          return false;
      }

      console.log("Attempting mock login for:", email);
      showLoadingState(elements.modalButtons.login, true);

      // Simulate server response
      setTimeout(() => {
        const mockUser = { name: "デモユーザー", email: email };
        appState.loggedInUser = mockUser;
        saveToLocalStorage('reiKikuchiPlayerUser', mockUser);
        updateAccountUI(true); // Update UI reflecting logged-in state
        showSnackbar('ログインしました！');
        hideModal('account'); // Close modal on success
        showLoadingState(elements.modalButtons.login, false);
      }, 1000);

      return false; // Prevent potential form submission
    }

    function handleRegister() {
       const nameInput = elements.accountFields.registerName;
       const emailInput = elements.accountFields.registerEmail;
       const passwordInput = elements.accountFields.registerPassword;
       if(!nameInput || !emailInput || !passwordInput) return false;

       const name = nameInput.value.trim();
       const email = emailInput.value.trim();
       const password = passwordInput.value;

       if (!name || !email || !password) { // Add password validation later
           showSnackbar("すべての項目を入力してください。");
           return false;
       }

       console.log("Attempting mock registration for:", name, email);
       showLoadingState(elements.modalButtons.register, true);

       setTimeout(() => {
         const mockUser = { name: name, email: email };
         appState.loggedInUser = mockUser;
         saveToLocalStorage('reiKikuchiPlayerUser', mockUser);
         updateAccountUI(true); // Update UI
         showSnackbar('登録が完了しました。ようこそ！');
         hideModal('account'); // Close modal on success
         showLoadingState(elements.modalButtons.register, false);
       }, 1500);
       return false; // Prevent potential form submission
    }

    function handleLogout() {
        if (confirm("ログアウトしてもよろしいですか？")) {
            showLoadingState(elements.modalButtons.logout, true); // Show loading state
            setTimeout(() => { // Simulate logout delay
                appState.loggedInUser = null;
                localStorage.removeItem('reiKikuchiPlayerUser');
                // Optionally clear other local data on logout?
                // appState.history = []; saveToLocalStorage('reiKikuchiPlayerHistory', []);
                // appState.favorites = []; saveToLocalStorage('reiKikuchiPlayerFavorites', []);
                // appState.userPlaylists = []; saveToLocalStorage('reiKikuchiPlayerPlaylists', []);
                updateAccountUI(false); // Update UI to logged-out state
                showSnackbar('ログアウトしました');
                hideModal('account'); // Ensure modal is closed if open
                showLoadingState(elements.modalButtons.logout, false); // Hide loading state
                // Re-render lists that depend on login state (like showing '+' button)
                renderPlaylist();
                renderHistoryList();
                renderFavoritesList();
                renderUserPlaylists();
             }, 500);
        }
    }

    // Update Account UI (Refined - focuses only on UI elements affected by login state)
    function updateAccountUI(isLoggedIn) {
      console.log("Updating Account UI elements, loggedIn:", isLoggedIn);

      // Update Header Account Button appearance
      if (elements.modalButtons.account) {
          if (isLoggedIn) {
              elements.modalButtons.account.innerHTML = '<i class="fas fa-user-check"></i>';
              elements.modalButtons.account.classList.remove('btn-inactive');
              elements.modalButtons.account.classList.add('btn-active');
              elements.modalButtons.account.setAttribute('aria-label', 'アカウント (ログイン済み)');
          } else {
              elements.modalButtons.account.innerHTML = '<i class="fas fa-user"></i>';
              elements.modalButtons.account.classList.add('btn-inactive');
              elements.modalButtons.account.classList.remove('btn-active');
              elements.modalButtons.account.setAttribute('aria-label', 'アカウント (未ログイン)');
          }
      }

      // Update User Info fields inside the modal
      if (elements.accountFields.userName && elements.accountFields.userEmail) {
          if (isLoggedIn && appState.loggedInUser) {
              elements.accountFields.userName.textContent = appState.loggedInUser.name;
              elements.accountFields.userEmail.textContent = appState.loggedInUser.email;
          } else {
              elements.accountFields.userName.textContent = ''; // Clear fields if logged out
              elements.accountFields.userEmail.textContent = '';
          }
      }

      // Update visibility/state of buttons/actions dependent on login state
      // Example: Create Playlist button
      if(elements.createPlaylistBtn) {
          elements.createPlaylistBtn.style.display = isLoggedIn ? 'inline-block' : 'none';
      }
      // Example: Sync Data button (in modal)
      if(elements.modalButtons.syncData) {
          // Usually shown only when logged in, handled by switchAuthSection
      }

      // Re-render lists only if their content or actions explicitly change based on login
      // (e.g., visibility of "Add to Playlist" buttons)
      renderPlaylist();
      renderHistoryList();
      renderFavoritesList();
      renderUserPlaylists();
    }

    function syncUserData() {
        // Placeholder for actual data sync logic
        if (!appState.loggedInUser) {
            showSnackbar("同期するにはログインしてください。");
            showAccountModal(); // Show login prompt
            return;
        }
        console.log("Attempting data sync for user:", appState.loggedInUser.email);
        showLoadingState(elements.modalButtons.syncData, true);
        showSnackbar("データをサーバーと同期中... (デモ)");

        setTimeout(() => {
            showSnackbar('データ同期が完了しました (デモ)');
            showLoadingState(elements.modalButtons.syncData, false);
            // Optionally re-render lists if data could have changed
            // loadUserData(); // Or selectively merge/render
        }, 2000);
    }

    // ==========================================================================
    // Utility Functions
    // ==========================================================================
    // Get current song ID safely
    function currentSongId() {
        return appState.currentSongIndex !== -1 ? appState.songs[appState.currentSongIndex]?.id : null;
    }
    // Get current song data safely
    function currentSongData() {
        return appState.currentSongIndex !== -1 ? appState.songs[appState.currentSongIndex] : null;
    }
    // Find song index by ID safely
    function findSongIndexById(songId) {
        if (!songId) return -1;
        return appState.songs.findIndex(song => song && song.id === songId);
    }
    // Find song object by ID safely (Used in various places)
    function findSongById(songId) {
        if (!songId) return null;
        return appState.songs.find(song => song && song.id === songId);
    }


    function formatTime(seconds) {
      if (isNaN(seconds) || seconds < 0) return '00:00';
      seconds = Math.floor(seconds);
      const minutes = Math.floor(seconds / 60);
      const remainingSeconds = seconds % 60;
      return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
    }

    function toggleTheme() {
        if(!elements.body || !elements.themeToggle) return;
        elements.body.classList.toggle('dark');
        const isDark = elements.body.classList.contains('dark');
        elements.themeToggle.innerHTML = isDark ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
        elements.themeToggle.classList.toggle('btn-active', isDark);
        elements.themeToggle.classList.toggle('btn-inactive', !isDark);
        elements.themeToggle.setAttribute('aria-pressed', isDark);
        localStorage.setItem('reiKikuchiPlayerTheme', isDark ? 'dark' : 'light');
        // Redraw visualizer immediately to reflect theme change, even if paused
        // Call resize which implicitly calls draw if needed.
        resizeCanvas();
    }

    function handleSearch() {
      if(!elements.searchInput) return;
      const searchTerm = elements.searchInput.value.toLowerCase().trim();
      appState.filteredSongs = appState.songs.filter(song =>
          song && song.title.toLowerCase().includes(searchTerm)
      );
      renderPlaylist(); // Re-render the main playlist
      if (appState.currentTab !== 'playlist') {
          switchTab('playlist'); // Switch to playlist tab on search
      }
    }

    function switchTab(tabName) {
        if (appState.currentTab === tabName || !elements.tabs || !elements.tabContents) return;

        appState.currentTab = tabName;
        elements.tabs.forEach(tab => {
            const isSelected = tab.dataset.tab === tabName;
            tab.classList.toggle('active', isSelected);
            tab.setAttribute('aria-selected', isSelected);
             tab.setAttribute('tabindex', isSelected ? '0' : '-1'); // Manage tabindex for focus
        });
        elements.tabContents.forEach(content => {
             if(content) content.classList.toggle('hidden', content.id !== `${tabName}-tab`);
        });
        updateActiveListItem(); // Highlight active song if relevant to the new tab
        console.log("Switched to tab:", tabName);
    }

    function addToHistory(song) {
      if (!song || !song.id) return;
      // Remove existing entry to move to end (most recent)
      appState.history = appState.history.filter(item => item && item.id !== song.id);
      // Add copy to prevent potential mutations if song object is modified elsewhere
      appState.history.push({ ...song });
      // Limit history size
      if (appState.history.length > MAX_HISTORY) {
        appState.history = appState.history.slice(-MAX_HISTORY); // Keep the last MAX_HISTORY items
      }
      saveToLocalStorage('reiKikuchiPlayerHistory', appState.history);
      // History list is rendered when playing starts (onPlayerStateChange) or when tab is switched to
    }

    function toggleFavorite(songId) {
        const songIndexInFavorites = appState.favorites.findIndex(fav => fav && fav.id === songId);
        const song = findSongById(songId); // Use helper

        if (!song) {
            console.warn("Cannot toggle favorite for unknown song ID:", songId);
            return;
        }

        if (songIndexInFavorites > -1) {
            appState.favorites.splice(songIndexInFavorites, 1); // Remove
            showSnackbar(`「${escapeHTML(song.title)}」をお気に入りから削除しました`);
        } else {
            appState.favorites.push({ ...song }); // Add a copy
            showSnackbar(`「${escapeHTML(song.title)}」をお気に入りに追加しました`);
        }
        saveToLocalStorage('reiKikuchiPlayerFavorites', appState.favorites);

        // Update UI (buttons in all lists and potentially the detail modal)
        updateFavoriteButtonsUI(songId); // Update all fav buttons for this song
        renderFavoritesList(); // Re-render the favorites tab content
         // Also re-render other lists as they contain favorite buttons
        // renderPlaylist(); // Avoid full re-render if only icon changes
        // renderHistoryList();
        // Re-render detail modal if open and relevant
        if (appState.currentSelectedPlaylistId && elements.modals.playlistDetail?.classList.contains('show')) {
             const playlist = appState.userPlaylists.find(p => p.id === appState.currentSelectedPlaylistId);
             if(playlist && playlist.songs.includes(songId)) {
                  renderPlaylistDetail(playlist); // Re-render needed if content changes
             }
        }
    }

    // Helper to update only the favorite button icons for a specific song ID across all lists
    function updateFavoriteButtonsUI(songId) {
        const isFavorite = appState.favorites.some(fav => fav && fav.id === songId);
        const favoriteButtons = document.querySelectorAll(`.favorite-btn[data-id="${songId}"]`);
        favoriteButtons.forEach(button => {
            const icon = button.querySelector('i');
            if (icon) {
                icon.classList.toggle('text-red-500', isFavorite);
                icon.classList.toggle('text-gray-400', !isFavorite);
                button.setAttribute('aria-label', isFavorite ? 'お気に入り解除' : 'お気に入り登録');
            }
        });
    }

    function saveUserPlaylists() {
      saveToLocalStorage('reiKikuchiPlayerPlaylists', appState.userPlaylists);
    }

     function saveToLocalStorage(key, data) {
         try {
             localStorage.setItem(key, JSON.stringify(data));
         } catch (error) {
             console.error("Error saving to localStorage:", key, error);
             showSnackbar("設定の保存中にエラーが発生しました。");
         }
     }

    // --- Modal Management ---
    let lastFocusedElement = null;

    function showModal(modalId, elementToFocusInitially = null) {
      const modal = elements.modals[modalId];
      if (!modal || modal.classList.contains('show')) {
         if (modal && modal.classList.contains('show') && elementToFocusInitially) {
             // If already shown but focus target provided, try to focus
             setTimeout(() => elementToFocusInitially.focus(), 50);
         }
        return; // Don't re-show if already showing
      }

      console.log("Showing modal:", modalId);
      lastFocusedElement = document.activeElement;

      modal.style.display = 'flex';
      void modal.offsetWidth; // Force reflow for transition
      modal.classList.add('show');
      appState.activeModalId = modalId;
      if(elements.body) elements.body.style.overflow = 'hidden'; // Prevent background scroll

      // Focus trap setup
      const focusableElements = Array.from(
          modal.querySelectorAll('button, [href], input:not([type="hidden"]), select, textarea, [tabindex]:not([tabindex="-1"])')
      ).filter(el => el.offsetParent !== null && !el.disabled); // Find visible, enabled elements

      const firstFocusable = focusableElements[0];
      const lastFocusable = focusableElements[focusableElements.length - 1];

      // Remove previous listener before adding new one
      if (modal._keyDownListener) {
          modal.removeEventListener('keydown', modal._keyDownListener);
      }
      modal._keyDownListener = (e) => handleModalKeyDown(e, firstFocusable, lastFocusable, modalId);
      modal.addEventListener('keydown', modal._keyDownListener);

      // Set initial focus (improved logic)
      setTimeout(() => {
          let targetElement = elementToFocusInitially; // Prioritize passed element

          if (!targetElement) { // If no specific element, use conventions
              if (modalId === 'createPlaylist') targetElement = elements.playlistElements.nameInput;
              else if (modalId === 'account' && !appState.loggedInUser) targetElement = elements.accountFields.loginEmail;
              else if (modalId === 'account' && appState.loggedInUser) targetElement = elements.modalButtons.syncData; // Or logout btn?
              else if (modalId === 'share') targetElement = elements.modalButtons.copyLink;
              else if (modalId === 'offline') targetElement = modal.querySelector('#cache-current-btn'); // Example for offline modal
              else if (modalId === 'playlistDetail') targetElement = modal.querySelector('.modal-close-btn'); // Focus close btn for detail
              // Fallback to first focusable element found
              else targetElement = firstFocusable;
          }

          // Ensure targetElement is focusable before attempting focus
          if (targetElement && typeof targetElement.focus === 'function') {
            targetElement.focus();
          } else if (modal && typeof modal.focus === 'function') {
            modal.focus(); // Focus modal itself as last resort
          }
          // console.log("Attempted initial focus on:", targetElement || modal);
      }, 150); // Delay slightly longer than transition
    }

    function hideModal(modalId) {
        console.log(`Attempting to hide modal: ${modalId}`);
        const modal = elements.modals[modalId];
        if (!modal || !modal.classList.contains('show')) {
            return;
        }

        modal.classList.remove('show'); // Start fade out
        // Only clear activeModalId if this IS the active modal
        if (appState.activeModalId === modalId) {
            appState.activeModalId = null;
        }

        // Actions after transition completes
        setTimeout(() => {
            modal.style.display = 'none'; // Hide element

            // Remove listener only if it exists for this modal
            if (modal._keyDownListener) {
                modal.removeEventListener('keydown', modal._keyDownListener);
                delete modal._keyDownListener; // Clean up
            }

            // Restore focus and body scroll *only if* no other modals are currently active
             const anyOtherModalOpen = Object.values(elements.modals).some(
                 m => m && m.id !== modal.id && m.classList.contains('show')
             );

            if (!anyOtherModalOpen) {
                 if(elements.body) elements.body.style.overflow = ''; // Restore scroll
                 if (lastFocusedElement && typeof lastFocusedElement.focus === 'function') {
                     lastFocusedElement.focus();
                 }
                 lastFocusedElement = null; // Reset for next time
            }

            // Reset specific modal states if needed
            if (modalId === 'playlistDetail') appState.currentSelectedPlaylistId = null;
            if (modalId === 'share' && elements.playlistElements.shareLinkInput) elements.playlistElements.shareLinkInput.value = '';
            if (modalId === 'createPlaylist' && elements.playlistElements.nameInput) elements.playlistElements.nameInput.value = '';
            if (modalId === 'offline' && elements.modals.offline) {
                // If offline modal was dynamically created, remove it on close? Or just hide?
                // elements.modals.offline.remove();
                // delete elements.modals.offline;
            }

        }, 300); // Match CSS transition duration
    }

     function handleModalKeyDown(e, firstFocusable, lastFocusable, modalId) {
         if (e.key === 'Escape') {
             hideModal(modalId);
             return;
         }
         if (e.key === 'Tab' && firstFocusable) { // Trap focus only if focusable elements exist
             if (e.shiftKey) { // Shift + Tab
                 if (document.activeElement === firstFocusable) {
                     lastFocusable?.focus(); // Wrap to last
                     e.preventDefault();
                 }
             } else { // Tab
                 if (document.activeElement === lastFocusable) {
                     firstFocusable?.focus(); // Wrap to first
                     e.preventDefault();
                 }
             }
              // Prevent tabbing out if only one element
             if (firstFocusable === lastFocusable && document.activeElement === firstFocusable) {
                  e.preventDefault();
             }
         }
     }

    // --- Snackbar ---
    function showSnackbar(message) {
        const snackbar = elements.snackbar;
        if (!snackbar) return;
        snackbar.textContent = message;

        if (appState.snackbarTimeoutId) {
            clearTimeout(appState.snackbarTimeoutId);
            snackbar.classList.remove('show');
            // Force reflow to restart animation smoothly
            void snackbar.offsetWidth;
        }

        // Add class to trigger transition
        snackbar.classList.add('show');

        // Set timeout to hide it
        appState.snackbarTimeoutId = setTimeout(() => {
            snackbar.classList.remove('show');
            appState.snackbarTimeoutId = null;
        }, 3000);
    }

     // --- Global Keydown Handler ---
    function handleGlobalKeyDown(event) {
        const activeElement = document.activeElement;
        const isInputFocused = activeElement && ['INPUT', 'TEXTAREA', 'SELECT'].includes(activeElement.tagName);

        // Ignore if a modal is active OR if typing in an input (except for Esc maybe?)
        if (appState.activeModalId || (isInputFocused && event.key !== 'Escape')) {
            return;
        }

        // Basic player controls (add more as needed)
        switch (event.key) {
            case ' ': // Space bar for Play/Pause
                 if (!isInputFocused) { // Prevent space in input fields triggering pause
                      event.preventDefault();
                      togglePlayPause();
                 }
                 break;
            case 'ArrowRight':
                event.preventDefault();
                if (event.ctrlKey || event.metaKey) seekRelative(SEEK_STEP);
                else playNextSong();
                break;
            case 'ArrowLeft':
                event.preventDefault();
                if (event.ctrlKey || event.metaKey) seekRelative(-SEEK_STEP);
                else playPreviousSong();
                break;
            case 'ArrowUp':
                 if (!elements.volumeSlider || activeElement !== elements.volumeSlider) { // Prevent clash with range slider keys
                     event.preventDefault();
                     adjustVolume(VOLUME_STEP);
                 }
                 break;
            case 'ArrowDown':
                 if (!elements.volumeSlider || activeElement !== elements.volumeSlider) { // Prevent clash with range slider keys
                     event.preventDefault();
                     adjustVolume(-VOLUME_STEP);
                 }
                 break;
            case 'f': // Focus search input
                 if (!isInputFocused) {
                     event.preventDefault();
                     elements.searchInput?.focus();
                 }
                 break;
             case 't': // Toggle theme (example)
                  event.preventDefault();
                  toggleTheme();
                  break;

            // You could add more: 's' for shuffle, 'l' for loop, 'm' for mute etc.
        }
    }

    // --- Visualizer Drawing (Simulation, Corrected Loop Logic) ---
        // --- Visualizer Drawing (Simulation, Corrected Loop Logic) ---
        function drawVisualizer() {
        // Guard clause: Check essential elements
        if (!appState.visualizer.canvasCtx || !appState.visualizer.dataArray || !appState.visualizer.canvas) {
             // console.warn("[DEBUG] Visualizer draw cancelled: canvas/ctx/dataArray missing"); // Reduce log noise
             appState.visualizer.animationFrameId = null; // Ensure loop stops if elements are gone
             return;
        }

        const bufferLength = appState.visualizer.bufferLength;
        const dataArray = appState.visualizer.dataArray;
        // Get the *current* playing state within the loop frame
        const isPlayingNow = appState.isPlaying;

        // Simulate audio data based on current state
        let hasPositiveValue = false; // Track if any bar has significant height for decay continuation
        for (let i = 0; i < bufferLength; i++) {
            if (isPlayingNow) {
                 // Make simulation more dynamic and visually interesting
                 const timeFactor = Date.now() * 0.002 + i * 0.08; // Slower time, more frequency variation
                 const randomFactor = Math.random() * 30; // Less randomness
                 const sineValue = (Math.sin(timeFactor) + 1) / 2; // 0 to 1
                 const baseHeight = 10; // Minimum base activity
                 dataArray[i] = Math.max(0, Math.min(255, baseHeight + (sineValue * 150) + randomFactor)); // Adjusted scale
                 if (dataArray[i] > 1) hasPositiveValue = true; // Check against a small threshold
            } else {
                 // Decay effect: Smoother decay, ensures it reaches zero eventually
                 dataArray[i] = Math.max(0, dataArray[i] * 0.96 - 0.5); // Slower decay rate, small constant reduction
                 if (dataArray[i] > 1) hasPositiveValue = true; // Check if still decaying significantly
            }
        }
        // console.log("[DEBUG] Visualizer data (first 5):", dataArray.slice(0, 5)); // Frequent log, disable normally

        const canvas = appState.visualizer.canvas;
        const canvasCtx = appState.visualizer.canvasCtx;
        const width = canvas.width;
        const height = canvas.height;

        // Guard clause: Check for valid canvas dimensions
        if (width <= 0 || height <= 0) {
             // console.warn("[DEBUG] Visualizer draw cancelled: canvas dimensions invalid (", width, "x", height, ")"); // Reduce log noise
             appState.visualizer.animationFrameId = null; // Stop loop if canvas has no size
             return;
        }

        // --- Drawing Logic ---
        canvasCtx.clearRect(0, 0, width, height);

        // Get colors safely with fallbacks
        const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim() || '#8e24aa'; // Fallback purple
        const secondaryColor = getComputedStyle(document.documentElement).getPropertyValue('--secondary-color').trim() || '#5e35b1'; // Fallback darker purple

        const gradient = canvasCtx.createLinearGradient(0, 0, 0, height); // Gradient covers full height
        gradient.addColorStop(0, primaryColor);
        gradient.addColorStop(1, secondaryColor);
        canvasCtx.fillStyle = gradient;

        const barWidthRatio = 0.7; // Make bars slightly narrower relative to space
        const spacingRatio = 0.4; // Increase spacing relative to bar width
        const totalBarWidth = width / bufferLength; // Max space per bar
        const barWidth = Math.max(1, totalBarWidth * barWidthRatio); // Actual bar width
        const spacing = Math.max(1, totalBarWidth * spacingRatio); // Spacing between bars
        const totalBarAndSpaceWidth = barWidth + spacing; // Width occupied by one bar + space

        // Calculate how many bars actually fit BEFORE calculating offset
        const numBarsThatFit = totalBarAndSpaceWidth > 0 ? Math.floor((width + spacing) / totalBarAndSpaceWidth) : 0; // Avoid division by zero
        const actualBufferLength = Math.min(bufferLength, numBarsThatFit);

        // Adjust offset to center bars properly (use actualBufferLength now)
        const totalDrawingWidth = actualBufferLength * totalBarAndSpaceWidth - (actualBufferLength > 0 ? spacing : 0); // Subtract last spacing only if bars exist
        const offsetX = Math.max(0, (width - totalDrawingWidth) / 2); // Center the bars

        let x = offsetX;

        for (let i = 0; i < actualBufferLength; i++) { // <<< Use the pre-calculated actualBufferLength
            // Scale bar height, ensure minimum height for visibility when active
            const rawHeight = (dataArray[i] / 255) * height * 0.95; // Scale height (95% of canvas height max)
            const barHeight = Math.max(1, rawHeight); // Ensure at least 1px height if data > 0
            const borderRadius = Math.min(3, barWidth / 3); // Smaller radius

            // Draw rounded rectangle (Simplified drawing for potentially better performance)
            canvasCtx.beginPath();
             // Use Math.round for potentially sharper pixels
             const startX = Math.round(x);
             const startY = Math.round(height);
             const endX = Math.round(x + barWidth);
             const endY = Math.round(height - barHeight); // Top Y coordinate

             // No need for complex arcs if borderRadius is small, rect is often sufficient
             if (barHeight > 1) { // Only draw if height is visible
                 canvasCtx.moveTo(startX, startY);
                 canvasCtx.lineTo(startX, endY + borderRadius); // To top-left radius point (approx)
                 // Simple rounded top using quadraticCurveTo (or just rect for performance)
                 canvasCtx.quadraticCurveTo(startX, endY, startX + borderRadius, endY);
                 canvasCtx.lineTo(endX - borderRadius, endY);
                 canvasCtx.quadraticCurveTo(endX, endY, endX, endY + borderRadius);
                 canvasCtx.lineTo(endX, startY);
                 // No need to close path explicitly with fill
             }
             canvasCtx.fill(); // Fill the path

            x += totalBarAndSpaceWidth;
        }
        // --- End Drawing Logic ---

        // --- Schedule Next Frame ---
        // Continue the loop if the player is playing OR if the animation hasn't fully decayed
        if (isPlayingNow || hasPositiveValue) {
             appState.visualizer.animationFrameId = requestAnimationFrame(drawVisualizer);
        } else {
             // Stop the loop completely if not playing and animation has fully decayed
             // Optional: Clear canvas one last time? Or let the last frame stay?
             // canvasCtx.clearRect(0, 0, width, height); // Final clear if desired
             appState.visualizer.animationFrameId = null;
             console.log("[DEBUG] Visualizer loop stopped naturally (decayed).");
        }
    }


    // --- Canvas Resize ---
        // --- Canvas Resize ---
        function resizeCanvas() {
        const canvas = appState.visualizer.canvas; // Get canvas from state
        if (!canvas) return;
        const parent = canvas.parentElement;
        if (!parent) return;
        const rect = parent.getBoundingClientRect();

        // Only resize if dimensions actually changed AND are valid positive numbers
        if (rect.width > 0 && rect.height > 0 && (canvas.width !== rect.width || canvas.height !== rect.height)) {
            canvas.width = rect.width;
            canvas.height = rect.height;
            console.log("Resized visualizer canvas to:", rect.width, rect.height);

             // --- Start: Trigger Redraw on Resize ---
             // Always attempt to draw one frame after resize to reflect the new size,
             // even if the animation loop isn't currently running (e.g., paused state).
             // The drawVisualizer function will handle whether to continue the loop.
             if (appState.visualizer.animationFrameId === null) {
                 // If the loop isn't running, draw a single frame now.
                 // This ensures the visualizer isn't blank after resize when paused.
                 drawVisualizer();
             }
             // If the loop *is* running (animationFrameId is not null),
             // the next frame requested by the loop will automatically use the new size.
             // --- End: Trigger Redraw on Resize ---
        } else if (rect.width === 0 || rect.height === 0) {
            // console.warn("Visualizer parent has zero width or height, cannot resize canvas.");
        }
    }


     // --- Highlight Active Song ---
     function updateActiveListItem() {
         const currentId = currentSongId(); // Use helper
         const listContainers = [
             elements.playlist, elements.historyList, elements.favoritesList,
             elements.playlistElements?.detailContent // Check if detailContent exists
         ];

         listContainers.forEach(container => {
             if (container) {
                 // Remove active class from previously active item(s) within this container
                 const previouslyActive = container.querySelector('.active');
                 previouslyActive?.classList.remove('active');

                 // Add active class to the current song if it exists in this container
                 if (currentId) {
                     const activeItem = container.querySelector(`.playlist-item[data-id="${currentId}"], .history-item[data-id="${currentId}"], .favorite-item[data-id="${currentId}"]`);
                     if (activeItem) {
                         activeItem.classList.add('active');
                         // Scroll into view only if the container is visible (in active tab or modal)
                         const isVisible = !activeItem.closest('.tab-content.hidden, .modal:not(.show)');
                         if(isVisible) {
                             // Check if item is already fully visible to prevent unnecessary scrolling
                             const itemRect = activeItem.getBoundingClientRect();
                             const containerRect = container.getBoundingClientRect();
                             // Check if container has non-zero height (important for initially hidden tabs)
                             const containerHasHeight = containerRect.height > 0;
                             const isFullyVisible = containerHasHeight && itemRect.top >= containerRect.top && itemRect.bottom <= containerRect.bottom;

                             if (!isFullyVisible && containerHasHeight) {
                                activeItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                             }
                         }
                     }
                 }
             }
         });
     }

      // --- Handle URL Parameters ---
      function handleUrlParams() {
          try {
              const urlParams = new URLSearchParams(window.location.search);
              const sharedPlaylistId = urlParams.get('sharedPlaylistId');
              const songIdToPlay = urlParams.get('playSongId');

              if (sharedPlaylistId) {
                  // Attempt to view playlist even if user data isn't fully loaded yet
                  // Requires playlists to be accessible without login or loaded early
                  const playlist = appState.userPlaylists.find(p => p && p.id === sharedPlaylistId);
                  if (playlist) {
                      showSnackbar(`共有されたプレイリスト「${escapeHTML(playlist.name)}」を表示します`);
                      viewPlaylist(sharedPlaylistId);
                      switchTab('user-playlists'); // Switch to the relevant tab
                  } else {
                      showSnackbar("共有されたプレイリストが見つかりませんでした。");
                  }
                  // Clean URL param after processing? Optional.
                  // history.replaceState(null, '', window.location.pathname);
              } else if (songIdToPlay) {
                  // Attempt to play song. Requires songs to be loaded.
                  const originalIndex = findSongIndexById(songIdToPlay);
                  if (originalIndex !== -1) {
                      playSong(originalIndex);
                      showSnackbar(`共有された曲を再生します`);
                  } else {
                       // If songs aren't loaded yet, maybe try again after load?
                       // For now, just show not found.
                       showSnackbar("共有された曲が見つかりませんでした。");
                  }
                  // Clean URL param after processing? Optional.
                  // history.replaceState(null, '', window.location.pathname);
              }
          } catch(e) {
              console.error("Error handling URL parameters:", e);
          }
      }

      // --- HTML Escaping Utility ---
      function escapeHTML(str) {
          if (typeof str !== 'string') return '';
          const map = {
              '&': '&amp;',
              '<': '&lt;',
              '>': '&gt;',
              '"': '&quot;',
              "'": '&#39;' // Use HTML entity for single quote for better compatibility
          };
          return str.replace(/[&<>"']/g, (m) => map[m]);
      }

       // --- Mobile Bottom Controls Visibility ---
       function checkBottomControlsVisibility() {
         const isMobile = window.innerWidth < 1024; // lg breakpoint in Tailwind
         if (elements.bottomControls) {
             elements.bottomControls.classList.toggle('hidden', !isMobile);
         }
         if(elements.body) {
            elements.body.classList.toggle('has-bottom-controls', isMobile);
         }
         // Adjust layout/padding based on visibility if needed elsewhere
       }

    // ==========================================================================
    // YouTube API Object (No changes needed here)
    // ==========================================================================
     const youtubeAPI = {
        apiKey: 'AIzaSyCbzvjP9vFa5I8N1qLI5H9LUpYim0nkQS4', // Replace with your key if needed
        channelId: 'UCYAuSEKhuk3v4ZKzm5Lqb1Q',

        async getLatestVideos(maxResults = 15) { // Default to 15
            console.log(`Fetching latest ${maxResults} videos...`);
            try {
                const response = await fetch(`https://www.googleapis.com/youtube/v3/search?part=snippet&channelId=${this.channelId}&maxResults=${maxResults}&order=date&type=video&key=${this.apiKey}`);
                if (!response.ok) {
                    // Try to get error message from response
                     let errorMsg = `YouTube Search API error: ${response.status}`;
                     try {
                         const errorData = await response.json();
                         errorMsg = `YouTube Search API error: ${response.status} - ${errorData?.error?.message || 'Unknown error'}`;
                     } catch (e) {/* Ignore JSON parsing error */}
                     throw new Error(errorMsg);
                }
                const data = await response.json();

                if (!data.items) {
                    console.warn("No items found in YouTube search response.");
                    return [];
                }

                console.log(`Found ${data.items.length} videos from search.`);
                return data.items.map(item => ({
                    id: item.id.videoId,
                    title: item.snippet.title,
                    description: item.snippet.description, // Keep description if needed
                    thumbnail: item.snippet.thumbnails.high?.url || item.snippet.thumbnails.medium?.url || item.snippet.thumbnails.default?.url, // Get highest available thumbnail
                    publishedAt: item.snippet.publishedAt,
                    duration: null // Duration needs separate call
                }));
            } catch (error) {
                console.error('YouTube Search API error:', error);
                showSnackbar('YouTube動画の取得に失敗しました');
                return [];
            }
        },

        async getVideoDetails(videoIds) {
            if (!videoIds || videoIds.length === 0) return [];
            console.log(`Fetching details for ${videoIds.length} video(s)...`);
            // Split into chunks of 50 for API limit
            const MAX_IDS_PER_REQUEST = 50;
            let allDetails = [];

            for (let i = 0; i < videoIds.length; i += MAX_IDS_PER_REQUEST) {
                const chunkIds = videoIds.slice(i, i + MAX_IDS_PER_REQUEST);
                try {
                    const response = await fetch(`https://www.googleapis.com/youtube/v3/videos?part=contentDetails,statistics&id=${chunkIds.join(',')}&key=${this.apiKey}`);
                     if (!response.ok) {
                        let errorMsg = `YouTube Videos API error: ${response.status}`;
                         try {
                             const errorData = await response.json();
                             errorMsg = `YouTube Videos API error: ${response.status} - ${errorData?.error?.message || 'Unknown error'}`;
                         } catch (e) {/* Ignore JSON parsing error */}
                         throw new Error(errorMsg);
                     }
                    const data = await response.json();

                    if (data.items) {
                        const chunkDetails = data.items.map(item => ({
                            id: item.id,
                            duration: item.contentDetails?.duration ? this.convertDuration(item.contentDetails.duration) : '--:--',
                            viewCount: item.statistics?.viewCount // Optional: get view count
                        }));
                        allDetails = allDetails.concat(chunkDetails);
                    }
                } catch (error) {
                    console.error(`YouTube Videos API error (chunk ${i / MAX_IDS_PER_REQUEST}):`, error);
                    // Continue fetching other chunks, but report error
                    showSnackbar('動画詳細の一部の取得に失敗しました');
                }
            }
            console.log(`Fetched details for ${allDetails.length} video(s).`);
            return allDetails;
        },

        convertDuration(isoDuration) {
            // Regex to parse ISO 8601 duration format (handles hours, minutes, seconds)
             const regex = /P(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?T(?:(\d+)H)?(?:(\d+)M)?(?:(\d+(?:\.\d+)?)S)?/;
             const matches = isoDuration.match(regex);

             if (!matches) return '--:--'; // Invalid format

             // Extract parts, default to 0 if not present
             const hours = parseInt(matches[5] || 0);
             const minutes = parseInt(matches[6] || 0);
             const seconds = Math.floor(parseFloat(matches[7] || 0)); // Floor seconds

             let formattedTime = "";

             if (hours > 0) {
                 formattedTime += `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
             } else {
                 formattedTime += `${minutes}:${seconds.toString().padStart(2, '0')}`;
             }

             return formattedTime;
        },

        async updatePlaylist() {
            try {
                showSnackbar('YouTubeから最新の曲を取得中...');

                const latestVideos = await this.getLatestVideos(25); // Fetch more initially if needed
                if (latestVideos.length === 0) {
                    showSnackbar('新しい曲は見つかりませんでした');
                    return;
                }

                const videoIds = latestVideos.map(video => video.id);
                const videoDetails = await this.getVideoDetails(videoIds);

                const videosWithDetails = latestVideos.map(video => {
                    const details = videoDetails.find(detail => detail.id === video.id) || {};
                    return {
                        ...video, // Include all data from search (title, thumbnail, etc.)
                        duration: details.duration || '--:--', // Add duration
                    };
                });

                const currentSongIds = new Set(appState.songs.map(s => s.id));
                const newSongs = videosWithDetails.filter(video => !currentSongIds.has(video.id));

                if (newSongs.length === 0) {
                    showSnackbar('新しい曲は見つかりませんでした');
                    return;
                }

                // Add new songs to the beginning of the list
                appState.songs.unshift(...newSongs.map(video => ({ // Map to desired app structure
                   id: video.id,
                   title: video.title,
                   duration: video.duration,
                   thumbnail: video.thumbnail
                })));

                // Limit total songs if necessary? Maybe not needed for now.
                // const MAX_TOTAL_SONGS = 100;
                // if (appState.songs.length > MAX_TOTAL_SONGS) {
                //    appState.songs = appState.songs.slice(0, MAX_TOTAL_SONGS);
                // }

                appState.filteredSongs = [...appState.songs]; // Update filtered list
                renderPlaylist(); // Update UI

                showSnackbar(`${newSongs.length}曲の新しい曲を追加しました`);
            } catch (error) {
                console.error('プレイリスト更新エラー:', error);
                showSnackbar(`プレイリストの更新に失敗しました: ${error.message || '不明なエラー'}`);
            }
        },

        startAutoSync(intervalMinutes = 60) {
           console.log(`Starting auto-sync every ${intervalMinutes} minutes.`);
           // Don't run initial sync here, let it be triggered by user or on load
           // this.updatePlaylist();

           // Set interval
           const intervalId = setInterval(() => {
                console.log("Auto-sync triggered.");
                this.updatePlaylist();
           }, intervalMinutes * 60 * 1000);

           return intervalId; // Return ID to allow stopping later if needed
        }
    };

    // Sync button setup moved here, called from onPlayerReady
    function setupYouTubeSync() {
      // Check if button already exists to prevent duplicates if onPlayerReady runs again
      if (document.getElementById('youtube-sync-btn')) return;

      const syncButton = document.createElement('button');
      syncButton.id = 'youtube-sync-btn';
      // Use existing Tailwind classes + custom style vars
      syncButton.className = 'px-3 py-1 rounded-md text-sm focusable';
      syncButton.style.backgroundColor = 'var(--primary-color)';
      syncButton.style.color = 'white'; // Ensure text color contrasts
      syncButton.innerHTML = '<i class="fab fa-youtube mr-1"></i> 新曲を同期';

      // Find the container for action buttons below the player
      const buttonContainer = document.querySelector('.player-main-column .flex.justify-end.mb-2.gap-2');
      if (buttonContainer) {
        buttonContainer.prepend(syncButton); // Add to the beginning of the button group
        // Add click listener
        syncButton.addEventListener('click', () => {
          youtubeAPI.updatePlaylist();
        });
        console.log("YouTube Sync button added.");
      } else {
        console.error("Could not find button container to add YouTube Sync button.");
      }

      // Start auto-sync (optional)
      // youtubeAPI.startAutoSync(60); // Start checking every 60 minutes
    }


    // ==========================================================================
    // Offline Playback Functionality (Service Worker based) - COMMENTED OUT or Use Actual Implementation
    // ==========================================================================
    /* // Remove this line if you have a working service-worker.js
    const offlinePlayback = {
        // ... (Keep the offlinePlayback object definition here if using service worker) ...
        // Make sure registerServiceWorker uses the correct scope: { scope: '/ReiKikuchi/' }
        async init() {
            console.log('Initializing Offline Playback module...');
            const registration = await this.registerServiceWorker(); // Wait for registration attempt
            this.setupOfflineDetection();
             // Add UI elements only if SW registration was potentially successful or supported
            if (registration || 'serviceWorker' in navigator) {
                // Delay UI setup slightly to ensure elements are definitely ready
                setTimeout(() => this.addOfflineUI(), 100);
            }
            console.log('Offline Playback module initialization complete.');
         }
    };
    */ // Remove this line if you have a working service-worker.js


    // ==========================================================================
    // DOMContentLoaded Listener
    // ==========================================================================
    document.addEventListener('DOMContentLoaded', function() {
      console.log("DOM fully loaded and parsed.");

      // --- Viewport Height Setup ---
      function setCorrectViewportHeight() {
        let vh = window.innerHeight * 0.01;
        document.documentElement.style.setProperty('--vh', `${vh}px`);
      }
      setCorrectViewportHeight(); // Initial call
      window.addEventListener('resize', setCorrectViewportHeight); // Update on resize

      // Don't initialize elements or setup listeners here, wait for onPlayerReady
      // checkBottomControlsVisibility(); // Initial check for mobile controls can happen here

      console.log("DOMContentLoaded setup finished. Waiting for YT API...");
    });

    // --- Final log ---
    console.log("Player script parsed. Waiting for YouTube API ready event...");

  </script>

</body>

</html>
